<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.ff31de0ff">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Cardano2vn Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Cardano2vn Blog Atom Feed"><title data-react-helmet="true">Week 02 - Validation | Cardano2vn</title><meta data-react-helmet="true" property="og:url" content="https://cardano2vn.io/docs/dr-lars-lession/week2"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Week 02 - Validation | Cardano2vn"><meta data-react-helmet="true" name="description" content="Đây là tài liệu Bài giảng \#2, Dr. Lars."><meta data-react-helmet="true" property="og:description" content="Đây là tài liệu Bài giảng \#2, Dr. Lars."><link data-react-helmet="true" rel="shortcut icon" href="/img/2.png"><link data-react-helmet="true" rel="canonical" href="https://cardano2vn.io/docs/dr-lars-lession/week2"><link data-react-helmet="true" rel="alternate" href="https://cardano2vn.io/docs/dr-lars-lession/week2" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://cardano2vn.io/docs/dr-lars-lession/week2" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.8b54419c.css">
<link rel="preload" href="/assets/js/runtime~main.00983322.js" as="script">
<link rel="preload" href="/assets/js/main.349a1baa.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/2.png" alt="Cardano2vn Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/img/2.png" alt="Cardano2vn Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><strong class="navbar__title">Cardano2vn</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/getting-started/overview">Bắt đầu</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/cardano2vn" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_cxYs react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/2.png" alt="Cardano2vn Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/img/2.png" alt="Cardano2vn Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><strong class="navbar__title">Cardano2vn</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/docs/getting-started/overview">Bắt đầu</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/cardano2vn" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_lDyR"><div class="docSidebarContainer_0YBq" role="complementary"><div class="sidebar_a3j0"><div class="menu menu--responsive thin-scrollbar menu_cyFh"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_iZzd" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Getting Started</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/getting-started/overview">Tổng quan</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Tạo Hợp đồng thông minh</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/smart-contracts/overview">Tổng quan</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/smart-contracts/marlowe">Marlowe</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/smart-contracts/plutus">Plutus</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Tích hợp với Cardano</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/integrate-cardano/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/integrate-cardano/creating-wallet-faucet">Tao Wallet Faucet</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/integrate-cardano/multi-witness-transactions-cli">Multi witness transaction cli</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/integrate-cardano/listening-for-payments-cli">Listening for payment cli</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/integrate-cardano/listening-for-payments-wallet">Listening for payment wallets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/integrate-cardano/testnet-faucet">Testnet faucet</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Vận hành một Stake Pool</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/operate-a-stake-pool/overview">Tổng quan</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Khoá đào tạo Plutus của Dr. Lars</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dr-lars-lession/overview">Plutus Pioneer Program</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dr-lars-lession/week1">Week 01 - English Auction</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/dr-lars-lession/week2">Week 02 - Validation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dr-lars-lession/week3">Week 03 - Script Context</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dr-lars-lession/week4">Week 04 - Monads</a></li></ul></li></ul></div></div></div><main class="docMainContainer_r8cw"><div class="container padding-vert--lg docItemWrapper_NJLN"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><header><h1 class="docTitle_-X99">Week 02 - Validation</h1></header><div class="markdown"><p>Đây là tài liệu <a href="https://youtu.be/7nDGZkUIeUQ" target="_blank" rel="noopener noreferrer">Bài giảng #2, Dr. Lars</a>.</p><p>Nó bao gồm mức thấp và mức cao tập lệnh xác thực on-chain.</p><blockquote><p>Mã trong bài giảng này sử dụng cam kết Plutus
81ba78edb1d634a13371397d8c8b19829345ce0d
:::</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="trước-khi-bắt-đầu"></a>Trước khi bắt đầu<a class="hash-link" href="#trước-khi-bắt-đầu" title="Direct link to heading">#</a></h2><p>Hãy nói về một điểm quan trọng được đưa ra bởi một trong những người
tiên phong sau bài giảng số 1.</p><p>Bạn sẽ gọi lại trong ví dụ đấu giá, chúng tôi tạo ra ba endpoints -
<code>start</code>, <code>bid</code> và <code>close</code>. <code>close</code> có hai kịch bản. Nếu có giá thầu đủ
cao, mã thông báo sẽ được chuyển đến người đặt giá thầu cao nhất. Nếu
không có giá thầu đủ cao, mã thông báo sẽ quay trở lại người bán.</p><p>Điều gì sẽ xảy ra nếu <code>endpoint close</code> không có ở đó? Tiền có thể bị
khóa mãi mãi trong hợp đồng không?</p><p>Đây là một điểm thực sự quan trọng, bởi vì những gì bạn phải nhận ra là
UTxO trên blockchain chỉ là dữ liệu, chúng hoàn toàn thụ động. Để bất cứ
điều gì xảy ra phải có một giao dịch. Để đạt được tiến bộ và thay đổi
trạng thái của blockchain, phải có một giao dịch mới được gửi sử dụng
các UTxO khác nhau và tạo ra các UTxO mới.</p><p>Chỉ có các giao dịch mới thay đổi trạng thái. UTxO sẽ không bao giờ tự
hoạt động và thực hiện điều gì đó. Bạn không thể có một hợp đồng thông
minh nằm trên blockchain và vào một thời điểm nào đó, đột nhiên thực
hiện một hành động.</p><p>Vì vậy, chúng tôi thực sự cần <code>endpoint close</code> nếu chúng tôi muốn cuộc
đấu giá được giải quyết. Trong trường hợp của chúng tôi, điểm cuối được
kích hoạt theo cách thủ công. Bạn có thể viết một hợp đồng chạy trong ví
sẽ tự động tạo closegiao dịch - có thể viết mã ngoài chuỗi khá phức tạp.</p><p>Tuy nhiên, theo quan điểm của blockchain, nó luôn là một yếu tố kích
hoạt bên ngoài thực hiện điều gì đó. Không có gì xảy ra nếu nó không
được kích hoạt từ bên ngoài.</p><p>Vì vậy, nếu không có <code>endpoint close</code> , hoặc <code>endpoint close</code> không bao
giờ được kích hoạt, thì tiền sẽ vẫn nằm ở địa chỉ tập lệnh mãi mãi.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="giới-thiệu"></a>Giới thiệu<a class="hash-link" href="#giới-thiệu" title="Direct link to heading">#</a></h2><p>Trong bài giảng đầu tiên, chúng ta đã thấy rằng hợp đồng thông minh có
hai mặt - một phần trong chuỗi và một phần ngoài chuỗi.</p><p>Phần on-chain là về xác nhận. Nó cho phép các nút xác thực một giao dịch
nhất định và liệu nó có được phép sử dụng một UTxO nhất định hay không.</p><p>Phần off-chain nằm trong ví của người dùng. Nó xây dựng và gửi các giao
dịch phù hợp.</p><p>Cả hai đều là chủ đề quan trọng. Chúng tôi phải thành thạo cả hai để
viết hợp đồng thông minh, nhưng hiện tại chúng tôi sẽ tập trung vào phần
on-chain.</p><p>Hãy nhớ lại mô hình UTxO mở rộng mà ý tưởng là chúng tôi giới thiệu một
loại địa chỉ mới.</p><p><img src="/assets/images/1-5f05ed3c68345659a94e4ed6f7502471.png"></p><p>Trong mô hình UTxO đơn giản, cái gọi là địa chỉ khóa công khai, trong đó
địa chỉ được cung cấp bởi hàm băm của khóa công khai. Nếu một UTxO nằm ở
địa chỉ khóa công khai như vậy, thì một giao dịch có thể sử dụng UTxO đó
làm đầu vào nếu chữ ký thuộc khóa công khai đó được bao gồm trong giao
dịch.</p><p>Những gì mô hình (E) UTxO làm là mở rộng điều này bằng cách thêm các địa
chỉ tập lệnh có thể chạy logic tùy ý.</p><p>Khi một giao dịch muốn sử dụng UTxO ở một địa chỉ tập lệnh được xác thực
bởi một nút, thì nút đó sẽ chạy tập lệnh và sau đó, tùy thuộc vào kết
quả của tập lệnh, quyết định xem giao dịch có hợp lệ hay không.</p><p>Và nhớ lại rằng hai là ba bổ sung nữa:</p><p>Thay vì chỉ có chữ ký trên các giao dịch, chúng tôi có cái gọi là Người
nhận thừa - các phần dữ liệu tùy ý. Ở phía đầu ra UTxO, chúng tôi có một
phần dữ liệu tùy ý bổ sung được gọi là Datum, bạn có thể coi đây là một
phần nhỏ của trạng thái nằm trên UTxO. Cuối cùng, chúng ta có bối cảnh.
Có nhiều lựa chọn khác nhau về bối cảnh này có thể là gì. Nó có thể rất
hạn chế, chỉ bao gồm Chúa cứu thế (như trong Bitcoin) hoặc rất toàn cầu,
bao gồm toàn bộ trạng thái của blockchain (như trong Etheum). Trong
Cardano, đó là giao dịch đang được xác thực, bao gồm tất cả các đầu vào
và đầu ra của nó.</p><p>Vì vậy, có ba phần dữ liệu mà một tập lệnh Plutus nhận được. Datum, đặt
tại UTxO, người mua lại, đến từ đầu vào và xác thực, và ngữ cảnh, bao
gồm giao dịch đang được xác thực và các đầu vào và đầu ra của nó.</p><p>Trong một triển khai cụ thể như Plutus, những phần thông tin này cần
được biểu diễn bằng một kiểu dữ liệu cụ thể - kiểu dữ liệu Haskell. Khi
nó xảy ra, lựa chọn đã được thực hiện để sử dụng cùng một kiểu dữ liệu
cho cả ba người trong số họ. Ít nhất là ở mức độ thực hiện thấp.</p><p>Chúng ta sẽ xem xét điều đó đầu tiên, nhưng trong cuộc sống thực không
ai thực sự sử dụng phương pháp tiếp cận cấp thấp này. Có nhiều cách
thuận tiện hơn để sử dụng các kiểu dữ liệu phù hợp hơn cho những việc
này, và chúng ta sẽ đề cập đến vấn đề đó ở phần sau của bài giảng này.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="plutustxdata"></a>PlutusTx.Data<a class="hash-link" href="#plutustxdata" title="Direct link to heading">#</a></h2><p>Như đề cập, the datum, redeemer and context chia sẻ một kiểu dữ liệu.</p><p>Kiểu dữ liệu đó được đống gói trong <code>plutus-core</code>, trong mô-đul
<code>PlutusCore.Data</code>.</p><p>Nó đực gọi đơn giản là <code>Data</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data Data =</span></div><div class="token-line" style="color:#393A34"><span class="token plain">     Constr Integer [Data]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   | Map [(Data, Data)]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   | List [Data]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   | I Integer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   | B BS.ByteString</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   deriving stock (Show, Eq, Ord, Generic)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   deriving anyclass (NFData)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nó có 5 hàm tạo.</p><ul><li><code>Constr</code> lấy một Số nguyên và, một cách đệ quy, một danh sách <code>Data</code></li><li><code>Map</code> lấy một danh sách các cặp <em>Data</em>. Bạn có thể coi đây là một
bảng tra cứu các cặp khóa-giá trị trong đó cả khóa và giá trị đều
thuộc loại <code>Data</code></li><li><code>List</code> lấy một danh sách <code>Data</code></li><li><code>I</code> lấy một số nguyên duy nhất</li><li><code>B</code> lấy một chuỗi Byte</li></ul><p>Đối với những người quen thuộc với định dạng JSON, điều này rất giống.
Các hàm tạo không hoàn toàn giống nhau, nhưng giống như JSON, bạn có thể
biểu diễn số, chuỗi, danh sách dữ liệu và các cặp khóa-giá trị. Nó có
thể đại diện cho dữ liệu tùy ý, điều này làm cho nó rất phù hợp với mục
đích của chúng tôi.</p><p>Chúng ta cũng có thể khám phá loại này trong REPL.</p><p>Chạy phần sau từ kho lưu trữ chương trình tiên phong của plutus. Bạn có
thể cần khởi động nix-shell từ kho lưu trữ Plutus trước khi thay đổi vào
thư mục <code>week02</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><div tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">cd code/week02</span></div><div class="token-line" style="color:#393A34"><span class="token plain">cabal repl</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Từ REPL, chúng ta cần import <code>PlutusTx</code> để chúng có quyền truy cập
vào<code>Data</code> . <code>Data</code> không được định nghĩa trong <code>PlutusTx</code>, nhưng nó được
tái xuất từ đó.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><div tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">import PlutusTx</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>chúng ta có thể thấy thông tin về <code>Data</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><div tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">:i Data</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Điều này chung ta có thể nhận được một số thông tin về <em>Data</em>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Week02.Burn&gt; import PlutusTx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx Week02.Burn&gt; :i Data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">type Data :: *</span></div><div class="token-line" style="color:#393A34"><span class="token plain">data Data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  = Constr Integer [Data]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  | Map [(Data, Data)]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  | List [Data]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  | I Integer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  | B bytestring-0.10.12.0:Data.ByteString.Internal.ByteString</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        -- Defined in ‘plutus-core-0.1.0.0:PlutusCore.Data’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Eq Data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-core-0.1.0.0:PlutusCore.Data’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Ord Data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-core-0.1.0.0:PlutusCore.Data’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Show Data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-core-0.1.0.0:PlutusCore.Data’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance IsData Data -- Defined in ‘PlutusTx.IsData.Class’</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bây giờ chúng ta có thể chơi với nó. Chúng ta có thể sử dụng hàm <code>I</code> tạo
để tạo một giá trị của kiểu <code>Data</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx.Data Week02.Burn&gt; I 42</span></div><div class="token-line" style="color:#393A34"><span class="token plain">I 42</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng ta có thể hỏi loại của nó và xác nhận rằng nó thực sự thuộc loại
<code>Data</code>:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx.Data Week02.Burn&gt; :t I 42</span></div><div class="token-line" style="color:#393A34"><span class="token plain">I 42 :: Data</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>TCách dễ nhất để tạo một giá trị kiểu <code>Data</code> bằng cách sử dụng hàm <code>B</code>
tạo là sử dụng Phần mở rộng GHC <code>OverloadedStrings</code>. Điều này cho phép
các chuỗi ký tự được sử dụng thay cho các kiểu dữ liệu giống chuỗi và
trình biên dịch sẽ diễn giải chúng như kiểu dự định của chúng.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx.Data Week02.Burn&gt; :set -XOverloadedStrings</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx.Data Week02.Burn&gt; :t B &quot;Haskell&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">B &quot;Haskell&quot; :: Data</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng ta cũng có thể sử dụng các hàm tạo phức tạp hơn, như <code>Map</code> and
<code>List</code>:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx.Data Week02.Burn&gt; :t Map [(I 42, B &quot;Haskell&quot;), (List [I 0], I 1000)]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Map [(I 42, B &quot;Haskell&quot;), (List [I 0], I 1000)] :: Data</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="plutus-validator"></a>Plutus Validator<a class="hash-link" href="#plutus-validator" title="Direct link to heading">#</a></h2><p>Bây giờ chúng tôi đã sẵn sàng triển khai trình xác thực đầu tiên của
mình..</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ví-dụ-1---hợp-đồng-gift"></a>Ví dụ 1 - Hợp đồng Gift<a class="hash-link" href="#ví-dụ-1---hợp-đồng-gift" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="the-code"></a>The Code<a class="hash-link" href="#the-code" title="Direct link to heading">#</a></h4><p>Chúng tôi bắt đầu tập lệnh bằng cách sao chép, dán danh sách các phần mở
rộng ngôn ngữ GHC, cộng với một số phần nhập phụ thuộc từ ví dụ mà chúng
tôi đã sử dụng trong bài giảng trước.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">{-# LANGUAGE DataKinds           #-}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">{-# LANGUAGE FlexibleContexts    #-}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">...</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">module Week02.Gift where</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">import           Control.Monad       hiding (fmap)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">import           Data.Map            as Map</span></div><div class="token-line" style="color:#393A34"><span class="token plain">...</span></div><div class="token-line" style="color:#393A34"><span class="token plain">import           Text.Printf         (printf)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Sau đó, chúng tôi viết trình xác nhận. Cuối cùng, trình xác thực sẽ là
một tập lệnh, sống trên blockchain trong Plutus Core, là một ngôn ngữ
cấp thấp hơn dựa trên phép tính lambda. Nhưng, chúng ta không cần phải
viết Plutus Core. Chúng ta có thể viết Haskell và sau này chúng ta sẽ
xem cách chúng ta chuyển đổi Haskell đó thành tập lệnh Plutus Core.</p><p>Vì vậy, chúng tôi viết một hàm Haskell đại diện cho trình xác thực của
chúng tôi. Như chúng ta đã biết, trình xác thực là một tập lệnh có ba
phần đầu vào - dữ liệu, trình đổi và ngữ cảnh, tương ứng, ở cấp thấp
nhất được biểu thị bằng <code>Data</code> kiểu dữ liệu.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: Data -&gt; Data -&gt; Data -&gt; ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Hơi ngạc nhiên, kết quả của hàm là <code>()</code>. Trong Haskell <code>Unit</code> kiểu,
tương tự như <code>void</code> trong một số ngôn ngữ khác, như C hoặc C # hoặc
Java - đó là kiểu không mang thông tin.</p><p><code>Unit</code> là một kiểu tích hợp sẵn trong Haskell và nó chỉ có một giá trị,
được viết theo cùng một cách với chính kiểu đó, như chúng ta có thể thấy
từ REPL.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Week02.Gift&gt; ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Week02.Gift&gt; :t ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">() :: ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Một hàm có kiểu trả về <code>()</code> là khá bất thường trong Haskell. Trong các
ngôn ngữ chính thống hơn, việc các hàm hoặc thủ tục không trả về giá trị
là điều khá phổ biến. Trong những tình huống này, các hàm chỉ quan trọng
đối với các tác dụng phụ của chúng, chẳng hạn như hàm Java in nội dung
nào đó ra bảng điều khiển.</p><p>Nhưng Haskell là một ngôn ngữ thuần túy. Nếu bạn muốn có tác dụng phụ,
điều này sẽ được hiển thị bởi hệ thống loại. Ví dụ: nếu mkValidator thực
hiện bất kỳ IO nào, nó sẽ có chữ ký kiểu:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: Data -&gt; Data -&gt; Data -&gt; IO ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Điều này sẽ chỉ ra một hàm thực hiện các tác dụng phụ IO nhưng không có
giá trị trả về thú vị.</p><p>Nhưng, như chúng ta biết rằng <code>mkValidator</code> hàm thực không thực hiện tác
dụng phụ và không trả về giá trị nào, thực sự không có gì hữu ích mà nó
có thể làm được.</p><p>Tuy nhiên, có điều gì đó mà hàm có thể làm cũng như trả về <code>()</code>, cụ thể
là nó có thể ném ra một ngoại lệ hoặc có lỗi. Và đó là những gì Plutus
sử dụng.</p><p>Ý tưởng là nếu <code>mkValidatorhàm</code> không gặp lỗi hoặc đưa ra một ngoại lệ,
thì quá trình xác nhận sẽ thành công. Nếu nó xuất hiện một lỗi thì việc
xác thực không thành công và giao dịch bị từ chối.</p><p>Hãy viết trình xác nhận đơn giản nhất mà chúng ta có thể.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: Data -&gt; Data -&gt; Data -&gt; ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator _ _ _ = ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Đối số đầu tiên là dữ liệu, đối số thứ hai là trình chuộc và đối số thứ
ba là ngữ cảnh. Điều đơn giản nhất mà chúng ta có thể làm là hoàn toàn
bỏ qua cả ba đối số và quay trở lại ngay lập tức <code>()</code>.</p><p>Điều này có nghĩa là địa chỉ tập lệnh tương ứng với trình xác thực này
không quan tâm đến dữ liệu, nó không quan tâm đến trình đổi và không
quan tâm đến ngữ cảnh. Nó sẽ luôn thành công và điều này có nghĩa là bất
kỳ giao dịch nào cũng có thể sử dụng tập lệnh tại địa chỉ này làm đầu
vào. Không quan trọng dữ liệu nào tồn tại cho UTxO tại địa chỉ tập lệnh
này, không quan trọng công cụ đổi quà nào được sử dụng cho giao dịch và
giao dịch có cấu trúc nào không quan trọng.</p><p>Nếu bạn gửi bất kỳ khoản tiền nào đến địa chỉ tập lệnh này, bất kỳ ai
cũng có thể nhận ngay.</p><p>Hàm này chưa phải là mã Plutus, nó chỉ là một hàm Haskell. Để biến nó
thành một tập lệnh Plutus, chúng ta cần phải biên dịch nó.</p><p>Kết quả của quá trình biên dịch của chúng tôi sang Plutus sẽ thuộc loại
<code>Validator</code>. Bên dưới hàm trong <code>Gift.hs</code>, chúng tôi thêm đoạn mã sau.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">validator :: Validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">validator = mkValidatorScript $$(PlutusTx.compile [|| mkValidator ||])</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Các chức năng <code>mkValidatorScript</code> mang kiểu
<code>CompiledCode (Data -&gt; Data -&gt; Data -&gt; ()) -&gt; Validator</code>. Nhằm mục đích
tạo kiểu này và biên dịch tập lệnh <code>mkValidator</code> bằng cách sử dụng một
thứ gọi là Template Haskell.</p><p>Template Haskell là một tính năng nâng cao của Haskell giải quyết một
vấn đề tương tự như các hệ thống macro trong các ngôn ngữ khác. Macro là
thứ được mở rộng tại thời điểm biên dịch.</p><p>Vì vậy, với mã này</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">$$(PlutusTx.compile [|| mkValidator ||])</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng tôi đang yêu cầu trình biên dịch viết mã cho hàm <code>validator</code> tại
thời điểm biên dịch dựa trên <code>mkValidatorhàm</code> của chúng ta , và sau đó
tiến hành biên dịch bình thường.</p><p>Bạn không cần phải hiểu nhiều về Template Haskell để viết Plutus vì nó
luôn luôn giống nhau. Khi bạn đã xem một vài ví dụ, bạn có thể ít nhiều
chỉ cần sao chép và dán.</p><p>Mẫu Haskell hy vọng tất cả mã sẽ có sẵn trong Oxford Brackets - <code>[| |]</code>.</p><p>Với các trình xác thực phức tạp hơn, bạn có thể sẽ dựa vào nhiều hàm trợ
giúp và bạn không muốn phải thêm chúng vào trong Dấu ngoặc đơn Oxford.
Để tránh điều này, có một điều chúng ta cần làm đối với <code>mkValidator</code>
hàm và đó là làm cho nó có thể nhập được bằng cách thêm thông số
<code>INLINABLE</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">{-# INLINABLE mkValidator #-}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: Data -&gt; Data -&gt; Data -&gt; ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator _ _ _ = ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bạn sẽ thấy điều này thường xuyên trong các tập lệnh Plutus và nó thường
là một dấu hiệu cho thấy một hàm được sử dụng trong một tập lệnh xác
thực. Tất cả các chức năng mà trình xác nhận phụ thuộc phải có thể nhập
được.</p><p>Hãy quay lại REPL và xem xét trình xác nhận.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">:l src/Week02/Gift.hs</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Ok, one module loaded.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx Week02.Gift&gt; import Ledger.Scripts</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx Ledger.Scripts Week02.Gift&gt; validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Validator { &lt;script&gt; }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng tôi có thể yêu cầu thông tin về <code>Validator</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx Ledger.Scripts Week02.Gift&gt; :i Validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">type Validator :: *</span></div><div class="token-line" style="color:#393A34"><span class="token plain">newtype Validator = Validator {getValidator :: Script}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        -- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Eq Validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Ord Validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Show Validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng ta thấy rằng nó là một lớp bao bọc xung quanh <code>getValidator</code></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx Ledger.Scripts Week02.Gift&gt; getValidator validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">&lt;Script&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Sau đó, chúng ta có thể lấy một số thông tin về <code>Script</code></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx Ledger.Scripts Week02.Gift&gt; :i Script</span></div><div class="token-line" style="color:#393A34"><span class="token plain">type Script :: *</span></div><div class="token-line" style="color:#393A34"><span class="token plain">newtype Script</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  = Script {unScript :: plutus-core-0.1.0.0:UntypedPlutusCore.Core.Type.Program</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                          plutus-core-0.1.0.0:PlutusCore.DeBruijn.Internal.DeBruijn</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                          plutus-core-0.1.0.0:PlutusCore.Default.Universe.DefaultUni</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                          plutus-core-0.1.0.0:PlutusCore.Default.Builtins.DefaultFun</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                          ()}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        -- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Eq Script</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Ord Script</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Show Script</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Và ở đây chúng ta thấy rằng chúng ta có một unScripthàm, chúng ta có thể
chạy</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx Ledger.Scripts Week02.Gift&gt; unScript $ getValidator validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Program () (Version () 1 0 0) (Apply () (Apply () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (Apply () (Apply () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (Apply () (Apply () (Apply () (Apply () (Apply () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (Apply () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (LamAbs () (DeBruijn {dbnIndex = 0}) (Var () (DeBruijn {dbnIndex = 1}))) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Var () (DeBruijn {dbnIndex = 5})))))))) (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (Var () (DeBruijn {dbnIndex = 1}))))) (LamAbs () (DeBruijn {dbnIndex = 0}) (Var () (DeBruijn {dbnIndex = 1})))))))))) (LamAbs () (DeBruijn {dbnIndex = 0}) (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (Var () (DeBruijn {dbnIndex = 5})) (Var () (DeBruijn {dbnIndex = 6}))))))))))) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (Apply () (Var () (DeBruijn {dbnIndex = 4})) (Var () (DeBruijn {dbnIndex = 7}))) (Var () (DeBruijn {dbnIndex = 6})))))))))))) (LamAbs () (DeBruijn {dbnIndex = 0}) (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (Var () (DeBruijn {dbnIndex = 3})) (Var () (DeBruijn {dbnIndex = 6}))))))))))) (LamAbs () (DeBruijn {dbnIndex = 0}) (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (Var () (DeBruijn {dbnIndex = 2})) (Var () (DeBruijn {dbnIndex = 6}))))))))))) (LamAbs () (DeBruijn {dbnIndex = 0}) (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (Var () (DeBruijn {dbnIndex = 1})) (Var () (DeBruijn {dbnIndex = 6}))))))))))) (LamAbs () (DeBruijn {dbnIndex = 0}) (Var () (DeBruijn {dbnIndex = 1}))))))) (Delay () (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Var () (DeBruijn {dbnIndex = 2}))))))) (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (Apply () (Var () (DeBruijn {dbnIndex = 1})) (Var () (DeBruijn {dbnIndex = 4}))) (Var () (DeBruijn {dbnIndex = 3})))))))))) (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (Var () (DeBruijn {dbnIndex = 1}))))))) (Delay () (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (LamAbs () (DeBruijn {dbnIndex = 0}) (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (Apply () (Apply () (Var () (DeBruijn {dbnIndex = 1})) (Var () (DeBruijn {dbnIndex = 3}))) (Var () (DeBruijn {dbnIndex = 2})))))))))) (Delay () (Delay () (LamAbs () (DeBruijn {dbnIndex = 0}) (Var () (DeBruijn {dbnIndex = 1}))))))</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Và ở đây bạn có thể thấy bản trình bày trung thực đến tốt đẹp của tập
lệnh Plutus Core cho trình xác thực.</p><p>Quay lại mã.</p><p>Bây giờ chúng tôi có trình xác thực đầu tiên của mình, có hai loại nữa
mà chúng tôi có thể xác định.</p><p>Một là \&#x27;\&#x27;ValidatorHash\&#x27;\&#x27;, như tên cho thấy, là băm của trình xác
nhận.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">valHash :: Ledger.ValidatorHash</span></div><div class="token-line" style="color:#393A34"><span class="token plain">valHash = Scripts.validatorHash validator</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Và, chúng tôi cũng có thể biến trình xác thực thành địa chỉ tập lệnh, là
địa chỉ của tập lệnh trên blockchain.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">scrAddress :: Ledger.Address</span></div><div class="token-line" style="color:#393A34"><span class="token plain">scrAddress = ScriptAddress valHash</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bây giờ chúng ta có một địa chỉ tập lệnh được biểu diễn dưới dạng
<code>scrAddress</code>.</p><p>Chúng ta có thể xem xét hai kết quả này trong REPL</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI haskell"><div tabindex="0" class="prism-code language-haskell codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx Ledger.Scripts Week02.Gift</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">valHash</span></div><div class="token-line" style="color:#393A34"><span class="token plain">c3168d465a84b7f50c2eeb51ccacd53a305bd7883787adb54236d8d17535ca14</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx Ledger.Scripts Week02.Gift</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">scrAddress Address</span></div><div class="token-line" style="color:#393A34"><span class="token plain">{addressCredential = ScriptCredential</span></div><div class="token-line" style="color:#393A34"><span class="token plain">c3168d465a84b7f50c2eeb51ccacd53a305bd7883787adb54236d8d17535ca14,</span></div><div class="token-line" style="color:#393A34"><span class="token plain">addressStakingCredential = Nothing}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Ngoại trừ hàm logic <code>mkValidator</code> (trong trường hợp của chúng ta là một
dòng), phần còn lại của mã chúng ta đã viết cho đến nay là bản soạn sẵn
và sẽ rất giống nhau đối với tất cả các tập lệnh Plutus.</p><p>Để thực sự thử tập lệnh này, chúng tôi cần mã ví. Trọng tâm của bài
giảng này là xác nhận và không phải mã ví, nhưng ngắn gọn, đây là phần
còn lại của mã.</p><p>Hai điểm cuối được xác định. Điểm cuối là cách để người dùng kích hoạt
một thứ gì đó với các tham số đầu vào.</p><p><code>Endpoint give</code> sẽ lấy một đối số <code>Integer</code> để chỉ định số lượng
lovelace sẽ được gửi vào hợp đồng.</p><p><code>Endpoint grab</code> sẽ không có đối số và sẽ đơn giản tìm kiếm các UTxO tại
địa chỉ tập lệnh này và sử dụng chúng.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">type GiftSchema =</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Endpoint &quot;give&quot; Integer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        .\/ Endpoint &quot;grab&quot; ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p><code>endpoint give</code> ử dụng hàm trợ giúp <code>mustPayToOtherScript</code> hàm này lấy
<code>valHash</code> của tập lệnh người nhận và một hàm <code>Datum</code> Cái mà trong ví dụ
này là hoàn toàn bị bỏ qua. nó sử dụng hàm tạo <code>Datum</code> để biến <code>Data</code>
thành <code>Datum</code>. Trong trường hợp này <code>Data</code> được sử dụng bằng cách sử
dụng <code>Constr</code> hàm tạo lấy 0 và một danh sách trống.</p><p>Cuối cùng số tiền cần gửi đến địa chỉ được chỉ định bằng cách sử dụng
chức năng trợ giúp <code>ADA.lovelaceValueOf</code>.</p><p>Giao dịch sau đó được gửi đi, tập lệnh chờ nó được xác nhận và sau đó in
thông báo nhật ký.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">give :: AsContractError e =&gt; Integer -&gt; Contract w s e ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">give amount = do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   let tx = mustPayToOtherScript valHash (Datum $ Constr 0 []) $ ADA.lovelaceValueOf amount</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   ledgerTx &lt;- submitTx tx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   void $ awaitTxConfirmed $ txId ledgerTx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   logInfo @String $ printf &quot;made a gift of %d lovelace&quot; amount</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p><code>endpoint grab</code> phức tạp hơn một chút.</p><p>Chúng tôi sử dụng <code>utxoAt</code> địa chỉ tập lệnh mới của mình <code>scrAddress</code> để
tra cứu tất cả các UTxO ở địa chỉ đó. Sau đó, chúng tôi cần tra cứu, sẽ
được sử dụng bởi ví để tạo giao dịch. Tại đây, chúng tôi cho ví biết nơi
tìm tất cả các UTxO và chúng tôi thông báo cho ví về trình xác thực. Hãy
nhớ rằng, nếu bạn muốn sử dụng UTxO ở một địa chỉ tập lệnh, thì giao
dịch chi tiêu cần cung cấp mã xác thực, trong khi giao dịch tạo ra UTxO
chỉ cần cung cấp hàm băm.</p><p>Sau đó, chúng tôi xác định giao dịch bằng cách sử dụng
<code>mustSpendScriptOutput</code> cho mỗi UTxO được tìm thấy. Điều này nói lên
rằng mọi UTxO ở địa chỉ tập lệnh này phải được chi tiêu bằng giao dịch
mà chúng tôi đang xây dựng.</p><p>Chúng tôi cũng chuyển một công cụ đổi quà hoàn toàn bị bỏ qua trong ví
dụ của chúng tôi, vì vậy chúng tôi có thể đặt bất kỳ thứ gì ở đó - trong
trường hợp này, một công cụ đổi quà được tạo bằng cách sử dụng hàm tạo
<code>I</code> của loại <code>Data</code> có giá trị là <code>17</code>.</p><p>Một lần nữa, chúng tôi gửi, chờ xác nhận và sau đó viết thông báo nhật
ký.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">grab :: forall w s e. AsContractError e =&gt; Contract w s e ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">grab = do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   utxos &lt;- utxoAt scrAddress</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   let orefs   = fst &lt;$&gt; Map.toList utxos</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      lookups  = Constraints.unspentOutputs utxos      &lt;&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                 Constraints.otherScript validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      tx :: TxConstraints Void Void</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      tx       = mconcat [mustSpendScriptOutput oref $ Redeemer $ I 17 | oref &lt;- orefs]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   ledgerTx &lt;- submitTxConstraintsWith @Void lookups tx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   void $ awaitTxConfirmed $ txId ledgerTx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   logInfo @String $ &quot;collected gifts&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Cuối cùng, chúng tôi đặt tất cả lại với nhau trong hàm <code>endpoints</code>. Đây
là mã soạn sẵn thông báo cho ví cung cấp tùy chọn của một số điểm cuối
nhất định cho người dùng và sau đó, khi một điểm cuối đã được chọn, sẽ
lặp lại và tiếp tục cung cấp các tùy chọn tương tự lặp đi lặp lại. Trong
trường hợp của <code>give</code> người dùng sẽ được yêu cầu cung cấp đối số
<code>Integer</code> .</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">endpoints :: Contract () GiftSchema Text ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">endpoints = (give&#x27; `select` grab&#x27;) &gt;&gt; endpoints</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    give&#x27; = endpoint @&quot;give&quot; &gt;&gt;= give</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    grab&#x27; = endpoint @&quot;grab&quot; &gt;&gt;  grab</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Sau đó, chúng tôi có một lệnh nhỏ.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkSchemaDefinitions &#x27;&#x27;GiftSchema</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Và sau đó một số mã chỉ được sử dụng bởi Plutus Playground cho phép
chúng tôi chỉ định các mã thông báo bổ sung có thể được sử dụng để thử
nghiệm.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkKnownCurrencies []</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Thử Nghiệm +++++++</p><p>Bây giờ chúng tôi sẽ thử nghiệm script <code>Gift</code> trong playground.</p><p>Bạn Copy <code>Gift</code> vào playground, sau đó biên dịch tập lệnh trong
playground and nhấn nút <code>Simulate</code>.</p><p><img src="/assets/images/playground_week2_1-84fa9ef5e0adf20ce81d4328f8f57ab2.png"></p><p>Giờ hãy thêm một chiếc ví thứ ba và cung cấp cho tất cả các ví 10 ADA
(10 triệu lovelace).</p><p><img src="/assets/images/pic__00024-fc070116d4be973a3ba383b03c005097.png"></p><p>Chúng tôi sẽ tạo một kịch bản trong đó ví 1 và 2 cho cảm giác yêu thích
và ví 3 lấy tất cả.</p><p>Bạn sẽ thấy rằng sân chơi đã hiển thị các nút giao diện người dùng cho
hai endpoints <code>give</code> và <code>grab</code>. Sử dung <code>endpoint give</code> để tạo ví 1 tặng
4 ADA và để tạo ví 2 tặng 6 ADA. Sau đó, thêm hành động chờ để đợi 1
khối, và sau đó sử dụng vào endpoints <code>grab</code> để tạo ví 3 lấy tiền. Sau
đó, thêm một hành động chờ khác để đợi 1 khối.</p><p><img src="/assets/images/pic__00025-cb338f1f02e5efb286814c5e7ff077c8.png"></p><p>Và bây giờ hãy nhấp vào <code>Evaluate</code>. Chúng tôi thấy rằng đã có bốn giao
dịch.</p><p>Giao dịch đầu tiên, như mọi khi, là giao dịch khởi đầu phân phối các
khoản tiền ban đầu vào ví.</p><p><img src="/assets/images/pic__00026-fd4fa5d1c6c90705682a40f0802c175f.png"></p><p>Và có hai giao dịch xảy ra tại khe 1. Chúng là hai giao dịch <code>give</code></p><p>Lệnh đầu tiên, Tx 0, là từ ví 2. Thứ tự ở đây không được xác định bởi
thứ tự mà chúng tôi đã tạo các giao dịch trong trình mô phỏng. Điều quan
trọng cần lưu ý là cả hai giao dịch <code>give</code> đều xảy ra tại cùng một thời
điểm.</p><p>Chúng tôi thấy ba kết quả đầu ra. Đầu ra đầu tiên là phí 10 lovelace
được trả bằng ví 2. Đầu ra thứ hai là 6 ADA được gửi đến địa chỉ tập
lệnh và đầu ra thứ ba là trả về thay đổi cho ví 2, là 4 ADA trừ đi phí.</p><p><img src="/assets/images/pic__00027-e8009bfb355342d158a40571df197cac.png"></p><p>Và thứ hai, Tx 1, là từ ví 1. Một lần nữa, với các UTxO đầu ra tương tự.</p><p>Bây giờ chúng ta có hai UTxO ở địa chỉ tập
lệnh.</p><p><img src="/assets/images/pic__00028-66b232b1994c20e6619f4af11449506f.png"></p><p>Sau đó, chúng tôi có <code>grab</code> tại vị trí 2 được kích hoạt bởi ví 3. Chúng
tôi thấy hai UTxO từ tập lệnh là đầu vào và sau đó là hai đầu ra. Một
đầu ra là phí và đầu ra còn lại, được trả cho ví 3, là 10 ADA trừ đi các
khoản phí đó. Bạn sẽ nhận thấy rằng phí hiện cao hơn chúng ta đã thấy
trước đây và điều này là do một tập lệnh hiện đã được thực thi, điều này
làm cho nó đắt hơn. Tuy nhiên, các khoản phí ở đây vẫn chưa được hiệu
chỉnh hoàn toàn với những khoản phí sẽ được tính trên blockchain thực.</p><p><img src="/assets/images/pic__00029-2a114f78397694fc83c5e65c55af660a.png"></p><p>Và, bằng cách cuộn xuống, chúng tôi thấy số dư cuối cùng của ví.</p><p><img src="/assets/images/pic__00030-beb4a9a337af2382a2b37dbee182a890.png"></p><p>Nếu bạn cuộn xuống sâu hơn, bạn sẽ thấy một số dấu vết và kết quả đầu ra
nhật ký sẽ cung cấp thêm chi tiết về việc thực thi.</p><p>Như đã đề cập, tập lệnh này sử dụng trình xác thực đơn giản nhất có thể,
một trình xác thực luôn thành công. Nhưng trình xác thực nhỏ ngớ ngẩn
này có thể hữu ích trong tình huống ai đó muốn đóng góp một số biểu
tượng tình yêu cho cộng đồng và để lại cho bạn!</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ví-dụ-2---burn"></a>Ví dụ 2 - Burn<a class="hash-link" href="#ví-dụ-2---burn" title="Direct link to heading">#</a></h3><p>Hãy xem ví dụ thứ hai về trình xác nhận.</p><p>Chúng ta sẽ bắt đầu bằng cách sao chép <code>Gift.hs</code>và đổi tên nó <code>Burn.hs</code>.</p><p>Trong ví dụ <code>Gift</code>, chúng tôi có một trình xác nhận luôn thành công.
Trong ví dụ này, chúng tôi muốn làm ngược lại - một trình xác nhận luôn
không thành công.</p><p>Nhớ lại rằng trình xác thực chỉ ra sự thất bại bằng cách ném ra một lỗi.
Vì vậy, chúng tôi có thể sửa đổi trình xác thực của mình cho phù hợp.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: Data -&gt; Data -&gt; Data -&gt; ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator _ _ _ = error ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nếu chúng tôi tải mô-đun trong REPL và nhìn thấy <em>error</em></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Week02.Burn&gt; :t error</span></div><div class="token-line" style="color:#393A34"><span class="token plain">error :: [Char] -&gt; a</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng tôi thấy định nghĩa cho chức năng <code>error</code> được xác định trong
Haskell tiêu chuẩn <code>Prelude</code>. Tuy nhiên, một trong phạm vi trong mã của
chúng tôi trên thực tế là chức năng <code>error</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Week02.Burn&gt; :t PlutusTx.Prelude.error</span></div><div class="token-line" style="color:#393A34"><span class="token plain">PlutusTx.Prelude.error :: () -&gt; a</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Thông thường trong Haskell, bạn có hàm <code>error</code> nhận một chuỗi thông báo
lỗi và gây ra lỗi. Trong Plutus, hàm <code>error</code>không nhận một chuỗi - nó
chỉ nhận khiểu trống <code>()</code> và trả về một kiểu tùy ý.</p><p>Và điều đó đưa chúng ta đến một điểm quan trọng.</p><p>Chúng tôi đã đề cập trước đó rằng chúng tôi sử dụng <code>INLINABLE</code> trên hàm
<code>mkValidator</code> để cho phép nó được sử dụng bởi mã Haskell Prelude. Trong
Haskell có nhiều chức năng có sẵn thông qua mô-đun <code>Prelude</code>, nhưng
những chức năng này sẽ không thể sử dụng được trong Plutus vì chúng
không được định nghĩa là có thể nhập được. Vì vậy, nhóm Plutus đã cung
cấp một Đoạn dạo đầu thay thế có thể được sử dụng để xác nhận.</p><p>Cách mà Plutus Prelude có thể được ưu tiên hơn Haskell Prelude, thường
có trong phạm vi theo mặc định, là sử dụng <code>LANGUAGE</code> trong mã.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">{-# LANGUAGE NoImplicitPrelude   #-}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Sau đó, bằng cách nhập PlutusTx.Prelude, các chức năng của nó được sử
dụng thay cho các chức năng Prelude tiêu chuẩn.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">import PlutusTx.Prelude hiding (Semigroup(..), unless)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bạn cũng có thể nhận thấy rằng Prelude tiêu chuẩn cũng được nhập khẩu.
Tuy nhiên, nó chỉ nhằm mang lại một số chức năng không liên quan gì đến
xác thực mà chỉ dành cho mã off-chain và playground.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">import Prelude (IO, Semigroup (..), String)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nó có thể gây nhầm lẫn. Rất nhiều chức năng trong Plutus Prelude có cùng
chữ ký và hành vi giống như tên gọi của chúng trong Prelude tiêu chuẩn,
nhưng điều đó không phải lúc nào cũng đúng và đây errorlà một ví dụ.</p><p>Chỉ cần nhớ rằng khi bạn đang sử dụng một cái gì đó trong tập lệnh
Plutus trông giống như một hàm từ Đoạn dạo đầu tiêu chuẩn, thì những gì
bạn thực sự đang sử dụng là một hàm từ Đoạn dạo đầu Plutus. Thường thì
chúng sẽ có cùng một chữ ký, nhưng chúng không phải lúc nào cũng giống
hệt nhau - ví dụ: tiền lệ của toán tử có thể không giống nhau</p><p>Nhìn lại trình xác thực mới của chúng tôi, bây giờ chúng ta có một trình
xác thực sẽ luôn không thành công.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: Data -&gt; Data -&gt; Data -&gt; ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator _ _ _ = error ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng tôi sẽ để mọi thứ khác như cũ và kiểm tra tác dụng của sự thay đổi
này, bằng cách sử dụng sân chơi. Sau khi nhấp <code>Compile</code>, kịch bản trước
đó vẫn sẽ xuất hiện trong trình mô phỏng. Và sau khi nhấp <code>Evaluate</code> và
cuộn xuống một chút, chúng ta có thể thấy ví 1 và 2 đã tạo quà tặng
nhưng ví 3 không thể lấy được.</p><p><img src="/assets/images/pic__00031-3f2f868104960170ff2ddbe80dbf1c0d.png"></p><p>Nếu chúng tôi cuộn xuống thêm, chúng tôi sẽ tìm thấy một thông báo nhật
ký cho thấy rằng việc xác thực không thành công.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.}"><div tabindex="0" class="prism-code language-{.} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">, Slot 2: 00000000-0000-4000-8000-000000000002 {Contract instance for wallet 3}:</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      Contract instance stopped with error: &quot;WalletError (ValidationError (ScriptFailure (EvaluationError [])))&quot; ]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Vì vậy, trong ví dụ đầu tiên của chúng tôi, chúng tôi có một trình xác
thực luôn thành công và cho phép bất kỳ ai lấy UTxO từ nó. Trong ví dụ
thứ hai, chúng tôi có trình xác thực luôn không thành công và bất kỳ
UTxO nào được gửi đến địa chỉ tập lệnh này không bao giờ có thể được
truy xuất. Về cơ bản đây là một cách để đốt tiền, có thể hữu ích trong
một số trường hợp.</p><p>Khi nhìn vào nhật ký, chúng tôi thấy rằng quá trình xác nhận không thành
công, nhưng chúng tôi không biết tại sao nó không thành công. đây là một
cách để thay đổi điều đó bằng cách sử dụng một biến thể của lỗi -
<code>traceError</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Week02.Burn&gt; :t PlutusTx.Prelude.traceError</span></div><div class="token-line" style="color:#393A34"><span class="token plain">PlutusTx.Prelude.traceError :: PlutusTx.Builtins.String -&gt; a      </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Hàm nhận một chuỗi, nhưng không phải là một chuỗi Haskell. Nó là một
chuỗi Plutus. Để biên dịch cái này, chúng ta cần sử dụng
OverloadedStringsphần mở rộng GHC.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">{-# LANGUAGE OverloadedStrings   #-}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Sau đó, chúng tôi có thể cập nhật trình xác thực của mình.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator _ _ _ = traceError &quot;BURNT!&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nếu bây giờ chúng tôi chạy cùng một kịch bản trong sân chơi với mã mới,
chúng tôi sẽ thấy thông báo lỗi tùy chỉnh mà chúng tôi đã thêm.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.}"><div tabindex="0" class="prism-code language-{.} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">, Slot 2: 00000000-0000-4000-8000-000000000002 {Contract instance for wallet 3}:</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      Contract instance stopped with error: &quot;WalletError (ValidationError (ScriptFailure (EvaluationError [\&quot;BURNT!\&quot;])))&quot; ]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p><img src="/assets/images/pic__00032-9f3b4bf174a2262ab7a70932ae78d756.png"></p><p>Ví dụ 3 - Forty Two (42) ~~~~~~~~~~~~~~~~~~~~~</p><p>Đối với ví dụ tiếp theo, chúng tôi sẽ viết một trình xác nhận không hoàn
toàn bỏ qua tất cả các đối số của nó. Chúng tôi sẽ viết một bài báo mong
đợi một người mua lại đơn giản.</p><p>Bây giờ chúng ta quan tâm đến người đổi quà, chúng ta cần có thể tham
khảo nó. Hãy gọi nó <code>r</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">{-# INLINABLE mkValidator #-}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: Data -&gt; Data -&gt; Data -&gt; ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator _ r _</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Giả sử rằng chúng tôi muốn xác thực được thông qua nếu người đổi <code>I 42</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">{-# INLINABLE mkValidator #-}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: Data -&gt; Data -&gt; Data -&gt; ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator _ r _</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   | r == I 42 = ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   | otherwise = traceError &quot;wrong redeemer&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nếu chúng ta chạy điều này ngay bây giờ trong sân chơi, việc xác nhận sẽ
luôn không thành công. Chúng tôi cần sửa đổi mã off-chain để thêm đầu
vào cho Endpoint <code>grab</code> để ví 3 có thể chuyển vào một điểm <code>Integer</code> mà
sau đó chúng tôi có thể chuyển cho trình xác thực với tư cách là
redeemer.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">type GiftSchema =</span></div><div class="token-line" style="color:#393A34"><span class="token plain">          Endpoint &quot;give&quot; Integer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      .\/ Endpoint &quot;grab&quot; Integer</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chung tôi thêm đối số redeemer vào khai báo <code>grab</code>. Lưu ý rằng việc thêm
số <code>Integer</code> trong chức năng ký, cũng như tham số <code>n</code> cái mà làm tham
chiếu.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">grab :: forall w s e. AsContractError e =&gt; Integer -&gt; Contract w s e ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">grab n = do</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Sau đó, chúng ta có thể chuyển nó vào hàm <code>mustSpendScriptOutput</code> thay
vì giá trị vứt bỏ mà chúng ta đã sử dụng trước đó.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">tx = mconcat [mustSpendScriptOutput oref $ Redeemer $ I n | oref &lt;- orefs]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Một thay đổi nữa, chúng ta cần thay đổi <code>&gt;&gt;</code> thành <code>&gt;&gt;=</code> trong đoạn mã
sau, và bây giờ <code>grab</code> có một đối số. Bạn có thể sử dụng REPL để thấy
<code>&gt;&gt;</code> và <code>&gt;&gt;=</code> và bây giờ tại sao dừng cái thứ hai. Về cơ bản, cả hai đều
trình tự các hành động, nhưng <code>&gt;&gt;</code> không lấy giá trị đầu múp,con <code>&gt;&gt;=</code>
truy cập giá trị được bao bọc và chuyển nó cho hành động tiếp theo.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">grab&#x27; = endpoint @&quot;grab&quot; &gt;&gt;= grab</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bây giờ chúng ta có thể thử nó trong sân chơi. Sau khi thêm mã mới và
nhấp vào <code>Simulate</code> bạn sẽ nhận thấy rằng kịch bản cũ đã biến mất. Đó là
bởi vì các điểm cuối (Endpoint) đã thay đổi và kịch bản cũ không còn hợp
lệ.</p><p>Hãy thiết lập một kịch bản chỉ sử dụng hai ví. Ví một sẽ cung cấp cho 3
ADA oo hợp đồng và ví 2 sẽ cố gắng lấy chúng, nhưng lần này, ví 2 sẽ cần
chuyển vào một giá trị sẽ được sử dụng để tạo người đổi.</p><p>Đối với lần thử đầu tiên, chúng tôi sẽ thêm giá trị người đổi sai, trong
trường hợp này là 100.</p><p><img src="/assets/images/pic__00033-2e906ca07048920ceb7b8359ca9c2dcb.png"></p><p>Nếu chúng tôi nhấp vào <code>Evaluate</code>, chúng ta thấy rằng chúng ta chỉ có
hai giao dịch và chúng ta thấy rằng ADA vẫn còn trong tập lệnh, điều này
cho thấy rằng ví 2 không lấy được nó.</p><p><img src="/assets/images/pic__00034-24c9f7957e25d3fc89ce197500cd9a90.png"></p><p>Các số dư cuối cùng cũng cho thấy điều này.</p><p><img src="/assets/images/pic__00035-921fa0d0ea272d4601e0b224d17ca44c.png"></p><p>Và, nếu chúng ta nhìn vào dấu vết, chúng ta sẽ tìm ra lỗi.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.}"><div tabindex="0" class="prism-code language-{.} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">, Slot 2: 00000000-0000-4000-8000-000000000001 {Contract instance for wallet 2}:</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      Contract instance stopped with error: &quot;WalletError (ValidationError (ScriptFailure (EvaluationError [\&quot;wrong redeemer\&quot;])))&quot; ]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nếu chúng ta quay lại kịch bản, thay đổi giá trị thành <code>42</code> và nhấp
<code>Evaluate</code> lại, chúng ta sẽ thấy rằng xác thực thành công.</p><p><img src="/assets/images/pic__00036-53ad6359b95bf3bf4551234df46cfdb9.png"></p><p>Bây giờ chúng ta thấy giao dịch thứ ba trong đó ví 2 quản lý để thu
tiền, trừ đi phí.</p><p><img src="/assets/images/pic__00037-5c16dde25c9a6d7d6da48a306310e820.png"></p><p>Chúng tôi thấy rằng số dư cuối cùng là như chúng tôi mong đợi và các bản
ghi cũng cho thấy rằng việc xác thực không gây ra lỗi, điều đó có nghĩa
là quá trình xác thực đã thành công.</p><p>Vì vậy, đó là ví dụ đầu tiên về trình xác thực xem xét ít nhất một trong
các đối số của nó.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ví-dụ-4---typed"></a>Ví dụ 4 - Typed<a class="hash-link" href="#ví-dụ-4---typed" title="Direct link to heading">#</a></h3><p>Nó đã được đề cập ở phần đầu của bài giảng, đây là Plutus cấp thấp và
trên thực tế, không ai sẽ viết các hàm xác nhận như thế này.</p><p>Bây giờ chúng ta sẽ xem nó thực sự được thực hiện như thế nào bằng cách
sử dụng một phiên bản đã đánh máy.</p><p>Mặc dù kiểu <code>Data</code>này mạnh mẽ và bạn có thể mã hóa tất cả các loại dữ
liệu vào nó, nhưng nó không thực sự giống Haskell. Nó gần giống như bạn
đang viết bằng một ngôn ngữ không định kiểu như Javascript hoặc Python.
Nó giống như một khối dữ liệu, nó có thể chứa bất cứ thứ gì nên bạn
không thực sự có bất kỳ loại an toàn nào. Bạn sẽ luôn cần kiểm tra, ví
dụ, nếu bạn đang mong đợi một số nguyên mà bạn thực sự được cung cấp một
số nguyên.</p><p>Nó đặc biệt tệ với đối số thứ ba, bối cảnh. Mặc dù thật dễ dàng để tưởng
tượng rằng bằng cách nào đó bạn có thể mã hóa một giao dịch với các đầu
vào và đầu ra của nó thành kiểu <code>Data</code>, nhưng hoàn toàn không rõ ràng
điều đó được thực hiện như thế nào.</p><p>Chúng tôi muốn sử dụng các kiểu dữ liệu cụ thể hơn được điều chỉnh cho
phù hợp với logic nghiệp vụ.</p><p>Điều này thực sự có thể thực hiện được với cái gọi là Typed Validators.
Điều này có nghĩa là chúng ta có thể thay thế các lần xuất hiện <code>Data</code>
trong <code>mkValidator</code> chữ ký bằng các kiểu phù hợp hơn.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: Data -&gt; Data -&gt; Data -&gt; ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Trong ví dụ nhỏ ngớ ngẩn của chúng tôi, chúng tôi hoàn toàn bỏ qua
Datum, vì vậy một loại phù hợp hơn sẽ chỉ là loại Unit - ().</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: () -&gt; Data -&gt; Data -&gt; ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Đối với redeemer, trong ví dụ này, chúng tôi chỉ xử lý các số nguyên, vì
vậy có lẽ sẽ hợp lý hơn khi sử dụng Số nguyên thay thế..</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: () -&gt; Integer -&gt; Data -&gt; ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Đối với context, có một kiểu hay hơn nhiều được gọi là <code>ScriptContext</code>
được tạo ra chính xác cho mục đích này.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: () -&gt; Integer -&gt; ScriptContext -&gt; ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Cuối cùng, chúng tôi đã đề cập rằng hơi bất thường khi sử dụng <code>()</code> làm
kiểu trả về. Tự nhiên hơn nhiều sẽ được sử dụng <code>Bool</code> để chỉ ra xác
thực thành công hay thất bại.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: () -&gt; Integer -&gt; ScriptContext -&gt; Bool</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Vì vậy, đây là một cách tốt hơn để viết mã xác nhận. Hai loại cuối cùng
<code>SciprtContext</code> và <code>Bool</code>, nhưng hai loại đầu tiên có thể khác nhau tùy
thuộc vào tình huống.</p><p>Trong trường hợp này, bây giờ chúng ta hãy viết lại hàm cho phù hợp bằng
cách sử dụng các kiểu mới này. Tham số r bây giờ không còn là kiểu
<code>Data</code> nữa- nó là một kiểu <code>Integer</code>, vì vậy chúng ta có thể chỉ cần
kiểm tra xem nó bằng 42 thay vì kiểm tra nó với một kiểu <code>Data</code> đã xây
dựng .</p><p>Và, khi chúng ta trả về a Bool, chúng ta có thể biến hàm thành một biểu
thức boolean.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">{-# INLINABLE mkValidator #-}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: () -&gt; Integer -&gt; ScriptContext -&gt; Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator _ r _ = r == 42</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Điều này sẽ có cùng một vấn đề mà chúng tôi đã gặp trước đó, trong
trường hợp có lỗi, chúng tôi sẽ không nhận được thông báo lỗi đẹp. Có
một hàm Plutus hay được gọi là hàm <code>traceIfFalse</code> nó nhẫn <code>String</code> và
<code>Bool</code> sau đó trả về <code>Bool</code>. Nếu đầu tiên <code>Bool</code> là <code>True</code>, thì kết quả
sẽ là <code>True</code> và <code>String</code> sẽ bỏ qua. Tuy nhiên nếu đầu tiên <code>Bool</code> là
<code>False</code>, thì kết quả là <code>False</code> và <code>String</code> được ghi lại.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">PlutusTx.Prelude.traceIfFalse</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      :: PlutusTx.Builtins.String -&gt; Bool -&gt; Bool</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Đây chính xác là những gì chúng ta cần.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">{-# INLINABLE mkValidator #-}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: () -&gt; Integer -&gt; ScriptContext -&gt; Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator _ r _ = traceIfFalse &quot;wrong redeemer&quot; $ r == 42</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Điều này sẽ chưa được biên dịch vì các phần khác của mã chưa được nhập
chính xác. Chúng tôi cần phải điều chỉnh bảng nấu của chúng tôi.</p><p>Đầu tiên, chúng tôi giới thiệu một kiểu dữ liệu giả mới, ở đây chúng tôi
gọi là <code>Typed</code>, đơn giản dựa trên tên của tập lệnh. Đối với loại này,
chúng tôi phải cung cấp một phiên bản của <code>Scripts.ValidatorTypes</code>.</p><p>Mục đích của trường hợp này là khai báo các loại cho datum và redeemer.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data Typed</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Scripts.ValidatorTypes Typed where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    type instance DatumType Typed = ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    type instance RedeemerType Typed = Integer</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Đây là Haskell khá nâng cao, được gọi là lập trình mức kiểu, nhưng cũng
giống như Template Haskell mà chúng ta đã gặp, bạn không thực sự cần
hiểu sâu về nó vì tất cả các script sẽ tuân theo cùng một khuôn mẫu.</p><p>Bây giờ chúng ta cần biên dịch trình xác nhận. Nơi trước đây chúng ta đã
sử dụng <code>mkValidatorScript</code>,, bây giờ chúng ta sử dụng một cái gì đó
được gọi là <code>mkTypedValidator</code>, lấy kiểu dữ liệu mới của chúng ta làm
tham số và tạo ra một cái gì đó có kiểu <code>TypedValidator</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">typedValidator :: Scripts.TypedValidator Typed</span></div><div class="token-line" style="color:#393A34"><span class="token plain">typedValidator = Scripts.mkTypedValidator @Typed</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    $$(PlutusTx.compile [|| mkValidator ||])</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    $$(PlutusTx.compile [|| wrap ||])</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    wrap = Scripts.wrapValidator @() @Integer</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Điều này tương tự với mã <code>mkValidator</code>, nhưng loại này chúng tôi cũng
biên dịch một hàm <code>wrapValidator</code> nhận kiểu dữ liệu và redeemer.</p><p>Để điều này hoạt động, trước tiên, chúng ta cần thêm một import.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">import qualified Ledger.Typed.Scripts as Scripts</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Trong ví dụ này, nó đang được nhập đủ điều kiện và sử dụng tiền tố
<code>Scripts</code> , nhưng điều này là tùy ý và bạn có thể chọn một số cách khác
để tham chiếu đến mô-đun.</p><p>Chúng tôi thực hiện những thay đổi này, mã Haskell sẽ được biên dịch và
bây giờ chúng tôi cần thay đổi bản soạn thảo Haskell Mẫu tạo ra hàm
<code>validator</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">validator :: Validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">validator = Scripts.validatorScript typedValidator</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Ở đây chúng tôi đã sử dụng hàm <code>validatorScript</code> để tạo trình xác thực
không định kiểu từ phiên bản đã nhập của chúng tôi.</p><p>Tất nhiên, để có được hàm băm, chúng ta có thể sử dụng trình xác thực mà
chúng ta có và biến nó thành một trình xác thực như <code>ValidatorHash</code>
chúng ta đã làm trước đây, nhưng có một cách trực tiếp hơn, trông giống
hệt nhau, nhưng trong trường hợp <code>Scripts</code>này là đến từ mô-đun
<code>Ledger.Typed.Scripts</code> hơn là <code>Ledger.Scripts</code>. Phiên bản này lấy trực
tiếp trình xác thực đã nhập.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">valHash :: Ledger.ValidatorHash</span></div><div class="token-line" style="color:#393A34"><span class="token plain">valHash = Scripts.validatorHash typedValidator</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Địa chỉ tập lệnh được tính như trước đây.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">scrAddress :: Ledger.Address</span></div><div class="token-line" style="color:#393A34"><span class="token plain">scrAddress = scriptAddress validator</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Trong ví dụ cực kỳ đơn giản này, nó có vẻ không đáng để nỗ lực, nhưng
đối với các hợp đồng thực tế, làm như thế này sẽ tốt hơn nhiều.</p><p>Mã off-chain gần như giống hệt nhau.</p><p>Có một thay đổi nhỏ đối với giveđiểm cuối. Mặc dù chúng tôi vẫn chưa xem
xét chi tiết phần này của mã, nhưng có thể thực hiện các thay đổi sau.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">let tx = mustPayToTheScript () $ ADA.lovelaceValueOf amount</span></div><div class="token-line" style="color:#393A34"><span class="token plain">ledgerTx &lt;- submitTxConstraints inst tx</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Hàm <code>mustPayToOtherScript</code> đã được thay thế bằng <code>mustPayToTheScript</code>.
Đây là một script tiện lợi cho phép chúng ta truyền chỉ vào () vì chúng
ta còn cần phải xây dựng một giá trị của kiểu Data. Chúng ta cũng không
cần chuyển mã băm tập lệnh nữa.</p><p>Hành vi của mã này sẽ giống với hành vi trong ví dụ trước, vì vậy chúng
tôi sẽ không xem qua nó trong sân chơi.</p><p>Bây giờ chúng tôi sẽ giải thích cách hoạt động thực sự của nó. Làm cách
nào để Plutus chuyển đổi các kiểu dữ liệu tùy chỉnh này thành kiểu triển
khai cấp thấp thực tế - Datakiểu.</p><p>Chúng ta có thể xem mã trong mô-đun PlutusTx.IsData.Class .</p><p>Ở đây chúng ta thấy rằng có một lớp kiểu khá đơn giản được định nghĩa
được gọi là <code>IsData</code>.</p><p><img src="/assets/images/pic__00037-5c16dde25c9a6d7d6da48a306310e820.png"></p><p>Lớp này cung cấp hai chức năng</p><ul><li><code>toData</code> nhận một giá trị và chuyển đổi nó thành <code>Data</code></li><li><code>fromData</code> nhận một giá trị của kiểu <code>Data</code> cố gắng chuyển đổi nó
thành một thể hiện của kiểu <code>IsData</code>. Điều này có thể không thành
công vì không phải tất cả các giá trị của kiểu <code>Data</code> sẽ được chuyển
đổi thành kiểu đích..</li></ul><p>Hãy thử điều này trong REPL.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Week02.Typed&gt; import PlutusTx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx Week02.Typed&gt; import PlutusTx.IsData.Class</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx PlutusTx.IsData.Class Week02.Typed&gt; :i IsData</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng tôi biết điều đó <code>()</code> and <code>Integer</code> cả hai đều là trường hợp của
<code>IsData</code> vì chúng đã hoạt động trong ví dụ của chúng tôi.</p><p>Hãy chuyển đổi <code>Integer</code> thành <code>Data</code></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx PlutusTx.IsData.Class Week02.Typed&gt; toData (42 :: Integer)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">I 42</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng tôi thấy rằng điều này đã được chuyển đổi thành một phiên bản của
kiểu Data bằng cách sử dụng hàm tạo I , mà chúng tôi đã thực hiện theo
cách thủ công trước khi chúng tôi sử dụng xác thực.</p><p>Bây giờ hãy làm theo cách khác</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx PlutusTx.IsData.Class Week02.Typed&gt; fromData (I 42) :: Maybe Integer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Just 42</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng tôi nhận được một <code>Just 42</code> back - <code>Just</code> là <code>Maybe</code> tạo khi
<code>Maybe</code> là <code>Nothing</code>.</p><p>Và khi nó không thành công, khi nó không thể chuyển đổi sang loại đích,
chúng ta sẽ lấy lại <code>Nothing</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx PlutusTx.IsData.Class Week02.Typed&gt; fromData (List []) :: Maybe Integer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Nothing</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nếu chúng ta kiểm tra<code>IsData</code>. Chúng ta có thể thấy tất cả các kiểu mà
mẫu này sẽ hoạt động cho tất cả các kiểu là <code>IsData</code> được xác định.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx PlutusTx.IsData.Class Week02.Typed&gt; :i IsData</span></div><div class="token-line" style="color:#393A34"><span class="token plain">type IsData :: * -&gt; Constraint</span></div><div class="token-line" style="color:#393A34"><span class="token plain">class IsData a where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  toData :: a -&gt; Data</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  fromData :: Data -&gt; Maybe a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  {-# MINIMAL toData, fromData #-}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        -- Defined in ‘PlutusTx.IsData.Class’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance IsData a =&gt; IsData (Maybe a)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance (IsData a, IsData b) =&gt; IsData (Either a b)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance IsData Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance (IsData a, IsData b, IsData c, IsData d) =&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">         IsData (a, b, c, d)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance (IsData a, IsData b, IsData c) =&gt; IsData (a, b, c)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance (IsData a, IsData b) =&gt; IsData (a, b)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance IsData ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance IsData a =&gt; IsData [a]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘PlutusTx.IsData.Class’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance IsData Integer -- Defined in ‘PlutusTx.IsData.Class’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance (TypeError ...) =&gt; IsData Int</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  -- Defined in ‘PlutusTx.IsData.Class’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance IsData Data -- Defined in ‘PlutusTx.IsData.Class’</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Đây vẫn là một danh sách khá ngắn về các loại có thể. Chúng tôi muốn sử
dụng nhiều loại hơn thế này cho dữ liệu và công cụ đổi quà của chúng
tôi.</p><p>Để làm được điều này, thông thường chúng ta cần xác định một IsDatathể
hiện cho bất kỳ kiểu nào mà chúng ta muốn sử dụng. Điều này sẽ cho phép
chúng tôi cho trình biên dịch biết cách thực hiện chuyển đổi qua lại.
Tuy nhiên, điều này một lần nữa sẽ rất tẻ nhạt vì nó là một quá trình
máy móc. Vì vậy, có một cơ chế trong Plutus thực hiện điều này cho chúng
ta.</p><p>Ví dụ 5 - Các kiểu IsData tùy chỉnh
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>Bây giờ chúng ta hãy nói về các kiểu dữ liệu tùy chỉnh. Hãy xác định một
cái ngớ ngẩn và sử dụng nó trong hàm xác nhận của chúng tôi.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">newtype MySillyRedeemer = MySillyRedeemer Integer</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">PlutusTx.unstableMakeIsData &#x27;&#x27;MySillyRedeemer</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">{-# INLINABLE mkValidator #-}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: () -&gt; MySillyRedeemer -&gt; ScriptContext -&gt; Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator () (MySillyRedeemer r) _ = traceIfFalse &quot;wrong redeemer&quot; $ r == 42</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>::: {.note}
::: {.title}
Note
:::</p><p>Ngoài ra còn có một phiên bản ổn định của hàm
PlutusTx.unstableMakeIsData và phiên bản ổn định phải luôn được sử dụng
trong mã sản xuất. Sự khác biệt giữa cả hai là, trong trường hợp yêu cầu
Data nhiều hơn một hàm tạo, phiên bản không ổn định sẽ không đảm bảo,
giữa các phiên bản Plutus, thứ tự của các hàm tạo sẽ được giữ nguyên.
:::</p><p>Và chúng ta cần thay đổi một số tấm boilerplate.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data Typed</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Scripts.ValidatorTypes Typed where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">...</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   type instance RedeemerType Typed = MySillyRedeemer</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">typedValidator :: Scripts.TypedValidator Typed</span></div><div class="token-line" style="color:#393A34"><span class="token plain">...</span></div><div class="token-line" style="color:#393A34"><span class="token plain">where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   wrap = Scripts.wrapValidator @() @MySillyRedeemer</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>We also need to change some off-chain code in the <code>grab</code> endpoint.</p><p>Instead of using <code>I r</code>, we will use <code>toData (MySillyRedeemer r)</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">grab :: forall w s e. AsContractError e =&gt; Integer -&gt; Contract w s e ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">grab r = do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    utxos &lt;- utxoAt scrAddress</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let orefs   = fst &lt;$&gt; Map.toList utxos</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        lookups = Constraints.unspentOutputs utxos      &lt;&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                  Constraints.otherScript validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        tx :: TxConstraints Void Void</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        tx      = mconcat [mustSpendScriptOutput oref $ Redeemer $ PlutusTx.toData (MySillyRedeemer r) | oref &lt;- orefs]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    ledgerTx &lt;- submitTxConstraintsWith @Void lookups tx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    void $ awaitTxConfirmed $ txId ledgerTx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    logInfo @String $ &quot;collected gifts&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nếu chúng ta cố gắng biên dịch mã ngay bây giờ, trên dòng lệnh hoặc
trong sân chơi, chúng ta sẽ gặp lỗi vì Plutus không biết cách chuyển đổi
qua lại giữa <code>IsData</code> and <code>MySillyRedeemer</code>.</p><p>Chúng tôi có thể viết một ví dụ của IsData cho MySillyRedeemer bằng tay.
Nhưng, chúng ta không cần phải làm vậy.</p><p>Thay vào đó, chúng ta có thể sử dụng một chút phép thuật của Template
Haskell.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">PlutusTx.unstableMakeIsData &#x27;&#x27;MySillyRedeemer</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Tại thời điểm biên dịch, trình biên dịch sẽ sử dụng Template Haskell để
viết một IsDatathể hiện cho chúng ta. Và bây giờ, nó sẽ biên dịch.</p><p>Hãy kiểm tra nó trong REPL.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx PlutusTx.IsData.Class&gt; :l src/Week02/IsData.hs</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Ok, one module loaded.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude PlutusTx PlutusTx.IsData.Class Week02.IsData&gt; toData (MySillyRedeemer 42)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Constr 0 [I 42]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nếu bạn thử mã này IsData.hs, trong sân chơi, bạn sẽ thấy rằng nó hoạt
động theo cách giống như trước đây.</p><p>Tóm lược -------</p><p>Chúng tôi đã thấy một vài ví dụ về trình xác nhận đơn giản.</p><p>Chúng tôi đã bắt đầu với một trình xác thực sẽ luôn thành công, hoàn
toàn bỏ qua các lập luận của nó. Sau đó, chúng tôi xem xét một trình xác
thực luôn không thành công, một lần nữa hoàn toàn bỏ qua các đối số của
nó. Sau đó, chúng tôi xem xét một công cụ kiểm tra người mua lại của nó
để kiểm tra một giá trị được xác định trước nhất định.</p><p>Sau đó, chúng tôi đã biến trình xác thực này thành một phiên bản đã
nhập, phiên bản này sẽ được sử dụng trong thực tế. Đầu tiên, chúng tôi
sử dụng các kiểu dữ liệu tích hợp và sau đó chúng tôi xem cách chúng tôi
có thể sử dụng các kiểu dữ liệu tùy chỉnh.</p><p>Chúng tôi vẫn chưa xem xét các ví dụ trong đó dữ liệu hoặc bối cảnh được
kiểm tra, điều này sẽ được yêu cầu để có các ví dụ thực tế hơn.</p><p>Chúng ta sẽ xem xét điều đó trong bài giảng tiếp theo.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/cardano2vn/cardanovn-portal/edit/main/docs/dr-lars-lession/week2.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/dr-lars-lession/week1"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Week 01 - English Auction</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/dr-lars-lession/week3"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Week 03 - Script Context »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#trước-khi-bắt-đầu" class="table-of-contents__link">Trước khi bắt đầu</a></li><li><a href="#giới-thiệu" class="table-of-contents__link">Giới thiệu</a></li><li><a href="#plutustxdata" class="table-of-contents__link">PlutusTx.Data</a></li><li><a href="#plutus-validator" class="table-of-contents__link">Plutus Validator</a><ul><li><a href="#ví-dụ-1---hợp-đồng-gift" class="table-of-contents__link">Ví dụ 1 - Hợp đồng Gift</a></li><li><a href="#ví-dụ-2---burn" class="table-of-contents__link">Ví dụ 2 - Burn</a></li><li><a href="#ví-dụ-4---typed" class="table-of-contents__link">Ví dụ 4 - Typed</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Tài liệu</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/getting-started/overview">Bắt đầu</a></li></ul></div><div class="col footer__col"><div class="footer__title">Cộng đồng</div><ul class="footer__items"><li class="footer__item"><a href="https://t.me/cardano2vn" target="_blank" rel="noopener noreferrer" class="footer__link-item">Telegram</a></li><li class="footer__item"><a href="https://www.youtube.com/channel/UCJTdAQPGJntJet5v-nk9ebA" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://github.com/cardano2vn" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/about-us">About Us</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 cardano2vn.io,. Break the blocks</div></div></div></footer></div>
<script src="/assets/js/runtime~main.00983322.js"></script>
<script src="/assets/js/main.349a1baa.js"></script>
</body>
</html>
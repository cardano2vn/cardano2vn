<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.ff31de0ff">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Cardano2vn Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Cardano2vn Blog Atom Feed"><title data-react-helmet="true">Week 03 - Script Context | Cardano2vn</title><meta data-react-helmet="true" property="og:url" content="https://cardano2vn.io/docs/dr-lars-lession/week3"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Week 03 - Script Context | Cardano2vn"><meta data-react-helmet="true" name="description" content="Đây là phiên bản đã dịch của Bài giảng số 3 Dr. Lars."><meta data-react-helmet="true" property="og:description" content="Đây là phiên bản đã dịch của Bài giảng số 3 Dr. Lars."><link data-react-helmet="true" rel="shortcut icon" href="/img/logo/2.png"><link data-react-helmet="true" rel="canonical" href="https://cardano2vn.io/docs/dr-lars-lession/week3"><link data-react-helmet="true" rel="alternate" href="https://cardano2vn.io/docs/dr-lars-lession/week3" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://cardano2vn.io/docs/dr-lars-lession/week3" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.8b54419c.css">
<link rel="preload" href="/assets/js/runtime~main.af40557b.js" as="script">
<link rel="preload" href="/assets/js/main.97b62b7d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo/2.png" alt="Cardano2vn Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/img/logo/2.png" alt="Cardano2vn Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><strong class="navbar__title">Cardano2vn</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/getting-started/overview">Bắt đầu</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/cardano2vn" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_cxYs react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo/2.png" alt="Cardano2vn Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/img/logo/2.png" alt="Cardano2vn Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><strong class="navbar__title">Cardano2vn</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/docs/getting-started/overview">Bắt đầu</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/cardano2vn" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_lDyR"><div class="docSidebarContainer_0YBq" role="complementary"><div class="sidebar_a3j0"><div class="menu menu--responsive thin-scrollbar menu_cyFh"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_iZzd" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Getting Started</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/getting-started/overview">Overview</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Tạo Hợp đồng thông minh</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/smart-contracts/overview">Tổng quan</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/smart-contracts/marlowe">Ngôn ngữ Marlowe</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/smart-contracts/plutus">Ngôn ngữ Plutus</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Tích hợp với Cardano</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/integrate-cardano/note">Note</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Vận hành một Stake Pool</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/operate-a-stake-pool/note">Note</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Khoá đào tạo Plutus của Dr. Lars</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dr-lars-lession/overview">Plutus Pioneer Program</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dr-lars-lession/week1">Week 01 - English Auction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dr-lars-lession/week2">Week 02 - Validation</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/dr-lars-lession/week3">Week 03 - Script Context</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dr-lars-lession/week4">Week 04 - Monads</a></li></ul></li></ul></div></div></div><main class="docMainContainer_r8cw"><div class="container padding-vert--lg docItemWrapper_NJLN"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><header><h1 class="docTitle_-X99">Week 03 - Script Context</h1></header><div class="markdown"><p>Đây là phiên bản đã dịch của <a href="https://youtu.be/WG3uw-TkW2k" target="_blank" rel="noopener noreferrer">Bài giảng số 3 Dr. Lars</a>.</p><p>Trong bài giảng này, chúng ta tìm hiểu về context script (đối số xác thực thứ ba), thời gian xử lý và các hợp đồng được tham số hóa.</p><p>Đoạn mã trong bài giảng này sử dụng Plutus commit là <code>81ba78edb1d634a13371397d8c8b19829345ce0d</code>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="trước-khi-chúng-ta-bắt-đầu"></a>Trước khi chúng ta bắt đầu<a class="hash-link" href="#trước-khi-chúng-ta-bắt-đầu" title="Direct link to heading">#</a></h2><p>Kể từ bài giảng cuối cùng đã có một bản cập nhật cho sân chơi, có trong bản cam kết Plutus mà chúng tôi đang sử dụng cho bài giảng này (xem ghi chú ở trên).</p><p>Đã xảy ra sự cố khi thời gian chờ được mã hóa cứng vào sân chơi quá ngắn. Điều này sẽ khiến mô phỏng không thành công nếu chúng mất nhiều thời gian hơn thời gian chờ mã cứng.</p><p>Bây giờ có một tùy chọn khi bạn khởi động Máy chủ sân chơi Plutus cho phép bạn chỉ định thời gian chờ. Ví dụ sau đặt thời gian chờ thành 120 giây.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.}"><div tabindex="0" class="prism-code language-{.} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">plutus-playground-server -i 120s</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="tóm-tắt-lại"></a>Tóm tắt lại<a class="hash-link" href="#tóm-tắt-lại" title="Direct link to heading">#</a></h2><p>Khi chúng tôi đã giải thích (E) UTxO mô hình trong bài giảng đầu tiên, chúng tôi đề cập rằng để mở khóa một địa chỉ kịch bản, kịch bản gắn liền với địa chỉ được chạy, và kịch bản mà được ba mẩu thông tin -
<em>datum</em>,  <em>redeemer</em> và <em>context</em>.</p><p>Trong bài giảng thứ hai, chúng ta đã xem các ví dụ về điều đó và chúng ta đã thấy nó thực sự hoạt động như thế nào trong Haskell.</p><p>Chúng tôi đã thấy việc triển khai cấp thấp, trong đó cả ba đối số đều được biểu thị bằng kiểu <code>Data</code>. Chúng tôi cũng thấy rằng trong thực tế điều này không được sử dụng.</p><p>Thay vào đó, chúng tôi sử dụng phiên bản đã nhập, trong đó dữ liệu và công cụ đổi có thể là kiểu tùy chỉnh (miễn là chúng triển khai lớp kiểu <code>IsData</code>) và trong đó đối số thứ ba là kiểu <code>ScriptContext</code>.</p><p>Trong các ví dụ mà chúng tôi đã thấy cho đến nay, chúng tôi đã xem xét dữ liệu và công cụ đổi, nhưng chúng tôi luôn bỏ qua ngữ cảnh. Nhưng bối cảnh, tất nhiên, rất quan trọng. Vì vậy, trong bài giảng này, chúng ta sẽ bắt đầu xem xét context.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="scriptcontext"></a>ScriptContext<a class="hash-link" href="#scriptcontext" title="Direct link to heading">#</a></h2><p><code>ScriptContext</code> được định nghĩa trong gói <code>plutus-ledger-api</code>, mà là một gói phần mềm đó, cho đến bây giờ, chúng tôi đã không cần thiết. Nhưng bây giờ chúng tôi cần nó, và nó đã được đưa vào files <code>.cabal</code> của tuần này . Nó được định nghĩa trong mô-đun <code>Plutus.V1.Ledger.Contexts</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data ScriptContext = ScriptContext { </span></div><div class="token-line" style="color:#393A34"><span class="token plain">            scriptContextTxInfo :: TxInfo, </span></div><div class="token-line" style="color:#393A34"><span class="token plain">            scriptContextPurpose :: ScriptPurpose </span></div><div class="token-line" style="color:#393A34"><span class="token plain">      }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nó là một loại bản ghi có hai trường.</p><p>Trường thứ hai thuộc loại <code>ScriptPurpose</code>, được xác định trong cùng một mô-đun. Nó xác định mục đích mà một tập lệnh đang được chạy.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data ScriptPurpose</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   = Minting CurrencySymbol</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   | Spending TxOutRef</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   | Rewarding StakingCredential</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   | Certifying DCert</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Đối với chúng tôi, quan trọng nhất là <code>Spending</code>. Đây là những gì chúng ta đã nói cho đến nay trong context của mô hình (E) UTxO. Đây là khi một tập lệnh được chạy để xác thực đầu vào chi tiêu cho một giao dịch.</p><p>Các <code>Minting</code> dùng khi bạn muốn định nghĩa một token gốc. Mục đích của nó là chúng tôi mô tả trong những trường hợp nào token gốc có thể được đúc hoặc đốt.</p><p>Ngoài ra còn có hai mục đích hoàn toàn mới -<code>Rewarding</code>-  liên quan đến đặt cược và <em><code>Certifying</code></em>  liên quan đến ủy quyền cổ phần.</p><p>Trường thú vị nhất, trường chứa ngữ cảnh thực tế <code>scriptContextTxInfo</code> là trường thuộc loại <code>TxInfo</code>, cũng được xác định trong cùng một mô-đun.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data TxInfo = TxInfo</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   { txInfoInputs      :: [TxInInfo] -- ^ Transaction inputs</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , txInfoOutputs     :: [TxOut] -- ^ Transaction outputs</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , txInfoFee         :: Value -- ^ The fee paid by this transaction.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , txInfoForge       :: Value -- ^ The &#x27;Value&#x27; forged by this transaction.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , txInfoDCert       :: [DCert] -- ^ Digests of certificates included in this transaction</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , txInfoWdrl        :: [(StakingCredential, Integer)] -- ^ Withdrawals</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , txInfoValidRange  :: SlotRange -- ^ The valid range for the transaction.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , txInfoSignatories :: [PubKeyHash] -- ^ Signatures provided with the transaction, attested that they all signed the tx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , txInfoData        :: [(DatumHash, Datum)]</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , txInfoId          :: TxId</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   -- ^ Hash of the pending transaction (excluding witnesses)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   } deriving (Generic)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nó mô tả giao dịch chi tiêu. Trong mô hình (E) UTxO, bối cảnh xác thực là giao dịch chi tiêu và các đầu vào và đầu ra của nó. Bối cảnh này được thể hiện trong <code>TxInfo</code>.</p><p>Có một số trường là toàn cầu cho toàn bộ giao dịch và cụ thể là chúng tôi có danh sách tất cả các đầu vào <code>txInfoInputs</code> và danh sách tất cả các đầu ra <code>txInfoOutputs</code>. Mỗi người trong số họ có nhiều lĩnh vực khác nhau để đi sâu vào từng đầu vào hoặc đầu ra riêng lẻ.</p><p>Chúng tôi cũng thấy các trường về phí <code>txFee</code>, giá trị giả mạo <code>txInfoForge</code>, được sử dụng khi đúc hoặc đốt các token gốc.</p><p>Sau đó, chúng tôi có một danh sách các chứng chỉ ủy quyền trong <code>txInfoDCert</code> và một trường <code>txInfoWdrl</code> để nắm giữ thông tin về việc rút tiền đặt cược.</p><p>Trường <code>txInfoValidRange</code> mà chúng ta sẽ xem xét chi tiết hơn trong giây lát, xác định phạm vi vị trí mà giao dịch này hợp lệ.</p><p><code>txInfoSignatories</code> là danh sách các khóa công khai đã ký kết giao dịch này.</p><p>Các giao dịch sử dụng đầu ra tập lệnh cần phải bao gồm dữ liệu của đầu ra tập lệnh. Các <code>txInfoData</code> lĩnh vực là một danh sách liên kết datums với băm tương ứng của họ. Nếu có một đầu ra giao dịch tới một địa chỉ tập lệnh mang một số dữ liệu nào đó, bạn không cần phải bao gồm dữ liệu đó, bạn chỉ có thể bao gồm băm dữ liệu. Tuy nhiên, các tập lệnh sử dụng một đầu ra cần phải bao gồm dữ liệu, trong trường hợp đó, nó sẽ được đưa vào danh sách <code>txInfoData</code> .</p><p>Cuối cùng, trường <code>txInfoId</code> là ID của giao dịch này.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="txinfovalidrange"></a>txInfoValidRange<a class="hash-link" href="#txinfovalidrange" title="Direct link to heading">#</a></h3><p>Mặc dù có rất nhiều thông tin chứa trong kiểu <code>txInfo</code>, nhưng đối với ví dụ đầu tiên của chúng tôi về cách sử dụng đối số thứ ba để xác thực, chúng tôi sẽ tập trung vào trường <code>txInfoValidRange</code> này.</p><p>Điều này đưa chúng ta đến một tình huống khó xử thú vị. Chúng tôi đã nhấn mạnh nhiều lần rằng lợi thế lớn mà Cardano có so với một thứ như Ethereum là việc xác thực có thể xảy ra trong ví. Nhưng chúng tôi cũng đã lưu ý rằng một giao dịch vẫn có thể không thành công on-chain sau khi xác thực, nếu khi giao dịch trên blockchain, nó đã bị người khác sử dụng. Trong trường hợp này, giao dịch không thành công mà không phải trả phí.</p><p>Điều không bao giờ nên xảy ra trong các trường hợp bình thường là một tập lệnh xác thực chạy và sau đó không thành công. Điều này là do bạn luôn có thể chạy xác thực trong cùng một điều kiện trong ví, vì vậy nó sẽ không thành công trước khi bạn gửi nó.</p><p>Vì vậy, đó là một tính năng rất hay, nhưng không rõ ràng là làm thế nào để quản lý thời gian trong context đó. Thời gian rất quan trọng, bởi vì chúng tôi muốn thể hiện rằng một giao dịch nhất định chỉ có hiệu lực trước hoặc chỉ có hiệu lực sau khi đã đạt đến một thời điểm nhất định.</p><p>Chúng ta đã thấy một ví dụ về điều này trong bài giảng một - ví dụ đấu giá (bid), trong đó giá thầu chỉ được phép cho đến khi đạt đến thời hạn cuối cùng và <code>close</code> chỉ khi có thể gọi <em>Endpoint</em> sau khi thời hạn đã qua.</p><p>Điều đó dường như là một sự mâu thuẫn, bởi vì thời gian rõ ràng là đang trôi. Vì vậy, khi bạn cố gắng xác thực một giao dịch mà bạn đang tạo trong ví của mình, tất nhiên, thời gian bạn đang thực hiện có thể khác với thời gian giao dịch đến một nút để xác thực. Vì vậy, không rõ làm thế nào để kết hợp hai điều này lại với nhau để xác thực là xác định và để đảm bảo rằng nếu và chỉ khi, xác thực thành công trong ví, thì nó cũng sẽ thành công trong nút.</p><p>Cách Cardano giải quyết điều đó, là bằng cách thêm trường phạm vi vị trí <code>txInfoValidRange</code> vào một giao dịch, về cơ bản nói rằng &quot;Giao dịch này hợp lệ giữa vị trí này và vị trí kia &quot;.</p><p>Khi một giao dịch được gửi đến blockchain và được xác thực bởi một nút, sau đó trước khi chạy bất kỳ tập lệnh nào, một số kiểm tra chung sẽ được thực hiện, chẳng hạn như tất cả các đầu vào đều có mặt và số dư cộng lại, phí được bao gồm, v.v.</p><p>Một trong những kiểm tra xảy ra trước khi xác thực là kiểm tra xem phạm vi vị trí có hợp lệ hay không. Nút sẽ xem xét thời điểm hiện tại và kiểm tra xem nó có nằm trong phạm vi vị trí hợp lệ của giao dịch hay không. Nếu không, thì xác thực không thành công ngay lập tức mà không bao giờ chạy các tập lệnh trình xác thực.</p><p>Vì vậy, nếu kiểm tra trước thành công, thì điều này có nghĩa là thời gian hiện tại rơi vào phạm vi vị trí hợp lệ. Đến lượt nó, điều này có nghĩa là chúng ta lại hoàn toàn xác định được. Tập lệnh xác thực có thể đơn giản giả định rằng nó đang được chạy tại một vị trí hợp lệ.</p><p>Theo mặc định, một tập lệnh sẽ sử dụng phạm vi vị trí vô hạn, một tập lệnh bao gồm tất cả các vị trí bắt đầu từ khối gốc và chạy cho đến hết thời gian.</p><p>Có một sự phức tạp nhỏ với điều này, đó là Ouroboros, giao thức đồng thuận cung cấp năng lượng cho Cardano không sử dụng thời gian POSIX, nó sử dụng các khe cắm. Nhưng Plutus sử dụng thời gian thực, vì vậy chúng ta cần có khả năng chuyển đổi qua lại giữa thời gian thực và thời điểm. Điều này không có vấn đề gì miễn là thời gian rãnh được cố định. Ngay bây giờ là một giây, vì vậy ngay bây giờ nó là dễ dàng.</p><p>Tuy nhiên, điều này có thể thay đổi trong tương lai. Có thể có một đợt hard fork với một số thay đổi thông số sẽ thay đổi thời gian của vị trí. Chúng tôi không thể biết trước điều đó. Ví dụ, chúng tôi không biết độ dài vị trí sẽ là bao nhiêu trong 10 năm nữa.</p><p>Điều đó có nghĩa là các khoảng thời gian được xác định cho các giao dịch không được có giới hạn trên xác định là quá xa trong tương lai. Chỉ càng xa trong tương lai thì người ta mới có thể biết được độ dài rãnh sẽ là bao nhiêu. Điều này xảy ra tương tự như 36 giờ. Chúng tôi biết rằng nếu sắp có một đợt hard fork, chúng tôi sẽ biết về nó trước ít nhất 36 giờ.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="posixtimerange"></a>POSIXTimeRange<a class="hash-link" href="#posixtimerange" title="Direct link to heading">#</a></h3><p>Hãy xem <code>POSIXTimeRange</code> này , được định nghĩa trong <code>Plutus.V1.Ledger.Time</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">type POSIXTimeRange = Interval POSIXTime.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nó là một loại từ đồng nghĩa với <code>Interval POSIXTime</code> và chúng ta thấy rằng nó <code>Interval</code> được định nghĩa bởi  <code>LowerBound</code> và <code>UpperBound</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Interval</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      ivFrom :: LowerBound a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      inTo   :: UpperBound a      </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nếu chúng ta đi sâu vào, <code>LowerBound</code> chúng ta sẽ thấy hàm tạo</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data LowerBound a = LowerBound (Extended a) Closure</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p><code>Closure</code> là một từ đông nghĩa với <code>Bool</code> và chắc chắn rằng có đưa vào <code>Interval</code> hay không.</p><p><code>Extended</code> có thể là <code>NegInf</code> âm vô cùng, <code>PosInf</code> dương vô cùng, hoặc <code>Finite</code>.</p><p>Chúng tôi cũng tìm thấy một số hàm trợ giúp bao gồm cả hàm <code>member</code> kiểm tra xem một cái đã cho <code>a</code> có phải là một phần của một cái đã cho hay không <code>Interval</code>, miễn là kiểu của <code>a</code> là một kiểu con của <code>Ord</code>, đây là trường hợp cho <code>POSIXTime</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">member :: Ord a =&gt; a -&gt; Interval a -&gt; Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">member a i = i `contains` singleton a</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p><code>interval</code> là một hàm tạo thông minh cho <code>Interval</code> Kiểu này tạo <code>Interval</code> với giới hạn trên và dưới.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">interval :: a -&gt; a -&gt; Interval a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">interval s s&#x27; = Interval (lowerBound s) (upperBound s&#x27;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Sau đó chúng ta có <code>from</code> với <code>Interval</code> cái này bắt đầu từ <code>a</code>
và kéo dài đến vô cùng.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">from :: a -&gt; Interval a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">from s = Interval (lowerBound s) (UpperBound PosInf True)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Và chúng ta có <code>to</code>, nó là ngước lại với <code>from</code>. Nó cũng được dùng <code>Interval</code>
nó bắt đầu block genesis tới <code>a</code>, và bao gồm cả <code>a</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">to :: a -&gt; Interval a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">to s = Interval (LowerBound NegInf True) (upperBound s)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p><code>always</code> luôn mặc định <code>Interval</code> bao gồm tất cả từ âm vô cùng đến dương vô cùng.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">always :: Interval a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">always = Interval (LowerBound NegInf True) (UpperBound PosInf True)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>và có điều ngươc lại, <code>never</code>, Nó không chứa slots nào.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">never :: Interval a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">never = Interval (LowerBound PosInf True) (UpperBound NegInf True)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Ngoài ra còn trình trợ giúp <code>singleton</code>, nó bao gồm một slot</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">singleton :: a -&gt; Interval a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">singleton s = interval s s      </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Hàm <code>hull</code> cho khoảng nhỏ nhất chứa cả hai khoảng đã cho.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">hull :: Ord a =&gt; Interval a -&gt; Interval a -&gt; Interval a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">hull (Interval l1 h1) (Interval l2 h2) = Interval (min l1 l2) (max h1 h2)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chức năng <code>intersection</code> xác định khoảng thời gian lớn nhất được chứa trong cả khoảng thời gian nhất định. Đây là một <code>Interval</code> bắt đầu từ giới hạn dưới lớn nhất của hai khoảng và kéo dài cho đến giới hạn trên nhỏ nhất.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">intersection :: Ord a =&gt; Interval a -&gt; Interval a -&gt; Interval a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">intersection (Interval l1 h1) (Interval l2 h2) = Interval (max l1 l2) (min h1 h2)    </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Hàm <code>overlaps</code> kiểm tra chức năng cho dù hai khoảng thời gian chồng lên nhau, có nghĩa là, cho dù có một giá trị chồng lên nhau của cả hai khoảng thời gian.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">overlaps :: Ord a =&gt; Interval a -&gt; Interval a -&gt; Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">overlaps l r = isEmpty (l `intersection` r)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p><code>contains</code> tlấy hai khoảng và xác định xem khoảng thứ hai có hoàn toàn nằm trong khoảng thời gian đầu tiên hay không.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">contains :: Ord a =&gt; Interval a -&gt; Interval a -&gt; Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">contains (Interval l1 h1) (Interval l2 h2) = l1 &lt;= l2 &amp;&amp; h2 &lt;= h1</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Và chúng tôi có các chức năng <code>before</code> và <code>after</code> để xác định nếu một thời gian nhất định tương ứng, trước hoặc sau mọi thứ trong một thời gian nhất định <code>Interval</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">before :: Ord a =&gt; a -&gt; Interval a -&gt; Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">before h (Interval f _) = lowerBound h &lt; f</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">after :: Ord a =&gt; a -&gt; Interval a -&gt; Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">after h (Interval _ t) = upperBound h &gt; t</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Hãy vào trong REPL.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Week03.Homework1&gt; import Plutus.V1.Ledger.Interval</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Hãy xây dựng <code>Interval</code> từ 10 đến 20, bao gồm cả hai đầu.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; interval (10 :: Integer) 20</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Interval {ivFrom = LowerBound (Finite 10) True, ivTo = UpperBound (Finite 20) True}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng ta có thể kiểm tra xem một giá trị có phải là thành viên của một khoảng hay không:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 9 $ interval (10 :: Integer) 20</span></div><div class="token-line" style="color:#393A34"><span class="token plain">False</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 10 $ interval (10 :: Integer) 20</span></div><div class="token-line" style="color:#393A34"><span class="token plain">True</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 12 $ interval (10 :: Integer) 20</span></div><div class="token-line" style="color:#393A34"><span class="token plain">True</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 20 $ interval (10 :: Integer) 20</span></div><div class="token-line" style="color:#393A34"><span class="token plain">True</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 21 $ interval (10 :: Integer) 20</span></div><div class="token-line" style="color:#393A34"><span class="token plain">False</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng ta có thể sử dụng hàm <code>from</code>. Ở đây giới hạn dưới lại là một slot hữu hạn, nhưng giới hạn trên là dương vô cùng.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 21 $ from (30 :: Integer)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">False</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 30 $ from (30 :: Integer)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">True</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 300000 $ from (30 :: Integer)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">True</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Và hàm tạo <code>to</code>. Ở đây giới hạn dưới là âm vô cùng, trong khi giới hạn trên là số slot hữu hạn.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 300000 $ to (30 :: Integer)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">False</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 31 $ to (30 :: Integer)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">False</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 30 $ to (30 :: Integer)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">True</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; member 7 $ to (30 :: Integer)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">True</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bây giờ, chúng ta hãy thử hàm <code>intersection</code> với <code>Interval</code> từ 10 đến 20 và <code>Interval</code> từ 18 đến 30.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; intersection (interval (10 :: Integer) 20) $ interval 18 30</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Interval {ivFrom = LowerBound (Finite 18) True, ivTo = UpperBound (Finite 20) True}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Như mong đợi, chúng tôi nhận được những <code>Interval</code> chạy từ 18 đến 20, bao gồm cả giá trị hai đầu.</p><p>Chúng tôi có thể kiểm tra xem một cái <code>Interval</code> có chứa cái khác hay không.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; contains (to (100 :: Integer)) $ interval 30 80</span></div><div class="token-line" style="color:#393A34"><span class="token plain">True</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; contains (to (100 :: Integer)) $ interval 30 100</span></div><div class="token-line" style="color:#393A34"><span class="token plain">True</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; contains (to (100 :: Integer)) $ interval 30 101</span></div><div class="token-line" style="color:#393A34"><span class="token plain">False</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>We see that as soon as the second <code>Interval</code> extends to 101, it is no
longer fully contained within the <code>Interval</code> that runs to 100.</p><p>However, if we check with <code>overlaps</code>, then it will be true because there
are elements, such as 40, that are contained in both intervals.</p><p>Chúng tôi thấy rằng ngay sau khi giây thứ hai <code>Interval</code> kéo dài đến 101, nó không còn được chứa đầy đủ bên trong giá trị <code>Interval</code> chạy đến 100.</p><p>Tuy nhiên, nếu chúng ta kiểm tra với <code>overlaps</code>, thì nó sẽ đúng vì có các phần tử, chẳng hạn như 40, được chứa trong cả hai khoảng.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; overlaps (to (100 :: Integer)) $ interval 30 101</span></div><div class="token-line" style="color:#393A34"><span class="token plain">True</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Plutus.V1.Ledger.Interval Week03.Homework1&gt; overlaps (to (100 :: Integer)) $ interval 101 110</span></div><div class="token-line" style="color:#393A34"><span class="token plain">False</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ví-dụ---vesting"></a>Ví dụ - Vesting<a class="hash-link" href="#ví-dụ---vesting" title="Direct link to heading">#</a></h2><p>Hãy tưởng tượng bạn muốn tặng một món quà của Ada cho một đứa trẻ. Bạn muốn đứa trẻ sở hữu Ada, nhưng bạn chỉ muốn đứa trẻ có quyền truy cập vào nó khi tròn mười tám tuổi.</p><p>Sử dụng Plutus, nó rất dễ thực hiện. Là hợp đồng đầu tiên của chúng tôi sẽ xem xét đối số ngữ cảnh, chúng tôi sẽ thực hiện một hợp đồng thực hiện một kế hoạch vesting. Tiền sẽ được đưa vào một kịch bản và sau đó nó có thể được lấy bởi một người nào đó, nhưng chỉ khi đến một thời hạn nhất định.</p><p>Chúng tôi bắt đầu bằng cách sao chép hợp đồng <code>IsData</code> từ bài giảng 2 vào một mô-đun mới được gọi là <code>Vesting</code>.</p><p>Bước đầu tiên là suy nghĩ về các loại cho dữ liệu và công cụ đổi.</p><p>Đối với dữ liệu, điều hợp lý là có hai phần thông tin, người thụ hưởng và thời hạn. Vì vậy, hãy xác định loại này:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data VestingDatum = VestingDatum</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   { beneficiary :: PubKeyHash</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , deadline    :: POSIXTime</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   } deriving Show</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">PlutusTx.unstableMakeIsData &#x27;&#x27;VestingDatum</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Để biết ai đó có thể chi tiêu đầu ra tập lệnh này hay không, cần có hai thông tin, tức là chữ ký của người thụ hưởng và thời gian của giao dịch. Trong trường hợp này, cả hai phần thông tin đó đều được chứa trong chính giao dịch. Điều này có nghĩa là chúng tôi không cần bất kỳ thông tin nào trong trình redeemer, vì vậy chúng tôi chỉ có thể sử dụng  <code>()</code> cho trình redeemer.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: VestingDatum -&gt; () -&gt; ScriptContext -&gt; Bool</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng ta cần kiểm tra hai điều kiện.</p><ol><li>Chỉ người thụ hưởng chính xác mới có thể mở khóa UTxO tại địa chỉ này. Chúng tôi có thể xác nhận điều này bằng cách kiểm tra xem chữ ký của người thụ hưởng có được bao gồm trong giao dịch hay không.</li><li>Rằng giao dịch này chỉ được thực hiện sau khi đến thời hạn cuối cùng.</li></ol><p>Chúng tôi có thể chỉ viết điều này trong một lần, nhưng chúng tôi sẽ viết nó theo kiểu từ trên xuống và ủy quyền cho một số chức năng trợ giúp.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator dat () ctx =</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      mkValidator dat () ctx = traceIfFalse &quot;beneficiary&#x27;s signature missing&quot; signedByBeneficiary &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                               traceIfFalse &quot;deadline not reached&quot; deadlineReached</span></div><div class="token-line" style="color:#393A34"><span class="token plain">where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      info :: TxInfo</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      info = scriptContextTxInfo ctx</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Để kiểm tra xem giao dịch có được ký bởi người thụ hưởng hay không, chúng tôi có thể lấy khóa công khai của người thụ hưởng từ dữ liệu và chuyển nó, cùng với thông tin giao dịch vào <code>txSignedBy</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">signedByBeneficiary :: Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">signedByBeneficiary = txSignedBy info $ beneficiary dat</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Làm thế nào để chúng tôi kiểm tra xem thời hạn đã qua?</p><p><img src="/assets/images/pic__00046-91ac81d2e6110ca563ef34a48b448bb4.png"></p><p>Hãy xem xét một giao dịch có giá trị hợp lệ vượt qua thời hạn, được hiển thị dưới dạng phạm vi cao nhất trong biểu đồ trên.</p><p>Nhớ lại rằng trước khi chạy tập lệnh trình xác thực, các kiểm tra khác được thực hiện, bao gồm cả kiểm tra thời gian. Nút kiểm tra xem thời gian hiện tại có nằm trong phạm vi hợp lệ của giao dịch hay không và chỉ sau đó trình xác thực mới được chạy. Vì vậy, chúng tôi biết rằng, nếu chúng tôi đang ở trong trình xác thực, thời gian hiện tại nằm ở đâu đó trong khoảng thời gian hiệu lực.</p><p>Trong trường hợp phạm vi vượt qua thời hạn, mã trình xác thực không thể biết liệu thời điểm hiện tại là trước hay sau thời hạn. Trong trường hợp này, người xác nhận phải tuyên bố rằng giao dịch không hợp lệ.</p><p>Tuy nhiên, ví dụ thứ hai trong sơ đồ là tốt. Chúng tôi vẫn chưa biết chính xác thời gian hiện tại là bao nhiêu, nhưng chúng tôi biết rằng dù thời gian là bao nhiêu thì cũng sẽ đến sau thời hạn.</p><p>Vì vậy, những gì chúng tôi đang kiểm tra là toàn bộ khoảng thời gian hiệu lực nằm ở bên phải của thời hạn. Một cách để làm điều này là sử dụng  hàm <code>contains</code> để kiểm tra xem khoảng thời gian hiệu lực có được chứa đầy đủ trong khoảng thời gian bắt đầu từ thời hạn và kéo dài cho đến hết thời gian hay không. </p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">deadlineReached :: Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">deadlineReached = contains (from $ deadline dat) $ txInfoValidRange info</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Điều đó hoàn thành logic xác thực. Hãy quan tâm đến một số tấm boilerplate.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data Vesting</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Scripts.ValidatorTypes Vesting where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    type instance DatumType Vesting = VestingDatum</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    type instance RedeemerType Vesting = ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">typedValidator :: Scripts.TypedValidator Vesting</span></div><div class="token-line" style="color:#393A34"><span class="token plain">typedValidator = Scripts.mkTypedValidator @Vesting</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    $$(PlutusTx.compile [|| mkValidator ||])</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    $$(PlutusTx.compile [|| wrap ||])</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    wrap = Scripts.wrapValidator @VestingDatum @()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng tôi sẽ tập trung nhiều hơn vào phần ví của script sau, nhưng đây là những thay đổi.</p><p>Ngoài ra thêm vào tham số mới <code>LANGUAGE</code> và một số imports bổ xung, chung tôi có tạo kiểu <code>GiveParams</code>, và sửa endpoint <code>grab</code> để không yêu cầu tham số.</p><p>Các kiểu <code>VestingSchema</code> định nghĩa endpoints cái mà Chúng ta muốn để lộ cho người dùng. Như trong ví dụ cuối cùng của chúng tôi, <code>give</code> sẽ được sử dụng bởi người dùng đặt tiền vào hợp đồng, sau đó <code>grab</code> sẽ được sử dụng bởi người dùng muốn nhận tiền.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">type VestingSchema =</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   .\/ Endpoint &quot;give&quot; GiveParams</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   .\/ Endpoint &quot;grab&quot; ()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Vậy chúng ta cần những thông số nào <code>give</code>? Endpoint sẽ tạo một UTxO tại địa chỉ tập lệnh vesting với một số tiền và một mức dữ liệu. Nếu bạn nhớ lại, datum của chúng tôi chứa người thụ hưởng và thời hạn. Vì vậy, có ba phần thông tin mà chúng ta phải chuyển đến endpoint <code>give</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data GiveParams = GiveParams</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   { gpBeneficiary :: !PubKeyHash</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , gpDeadline    :: !POSIXTime</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   , gpAmount      :: !Integer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   } deriving (Generic, ToJSON, FromJSON, ToSchema)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p> Endpoint <code>grab</code>  không yêu cầu bất kỳ tham số nào vì người thụ hưởng sẽ chỉ tìm các UTxO ở địa chỉ tập lệnh và sau đó có thể kiểm tra xem họ có phải là người thụ hưởng hay không và thời hạn đã qua hay chưa. Nếu vậy, họ có thể tiêu thụ chúng.</p><p>Hãy nhanh chóng nhìn vào endpoint <code>give</code> .</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">give :: AsContractError e =&gt; GiveParams -&gt; Contract w s e ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">give gp = do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let dat = VestingDatum</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                { beneficiary = gpBeneficiary gp</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                , deadline    = gpDeadline gp</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        tx  = mustPayToTheScript dat $ Ada.lovelaceValueOf $ gpAmount gp</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    ledgerTx &lt;- submitTxConstraints typedValidator tx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    void $ awaitTxConfirmed $ txId ledgerTx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    logInfo @String $ printf &quot;made a gift of %d lovelace to %s with deadline %s&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        (gpAmount gp)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        (show $ gpBeneficiary gp)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        (show $ gpDeadline gp)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Đầu tiên, chúng tôi tính toán dữ liệu mà chúng tôi muốn sử dụng và chúng tôi có thể nhận được cả hai phần thông tin từ <code>GiveParams</code> đó được chuyển vào hàm.</p><p>Sau đó, đối với giao dịch, chúng tôi thêm một ràng buộc rằng phải có một đầu ra tại địa chỉ tập lệnh này với dữ liệu mà chúng tôi vừa xác định và một số lovelace nhất định, mà chúng tôi cũng nhận được từ <code>GiveParams</code>.</p><p>Phần còn lại của chức năng vẫn như trước, chỉ với một thông báo nhật ký khác.</p><p>Endpoint <code>grab</code>  có liên quan nhiều hơn một chút.</p><p>Có thể có nhiều UTxO tại địa chỉ tập lệnh này và một số trong số chúng có thể không phù hợp với chúng tôi, vì chúng tôi không phải là người thụ hưởng hoặc vì thời hạn chưa trôi qua. Nếu chúng tôi cố gắng gửi một giao dịch khi không có UTxO phù hợp, chúng tôi sẽ trả phí nhưng không nhận lại được gì.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">grab :: forall w s e. AsContractError e =&gt; Contract w s e ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">grab = do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    now   &lt;- currentTime</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    pkh   &lt;- pubKeyHash &lt;$&gt; ownPubKey</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    utxos &lt;- Map.filter (isSuitable pkh now) &lt;$&gt; utxoAt scrAddress</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    if Map.null utxos</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        then logInfo @String $ &quot;no gifts available&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        else do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            let orefs   = fst &lt;$&gt; Map.toList utxos</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                lookups = Constraints.unspentOutputs utxos  &lt;&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                          Constraints.otherScript validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                tx :: TxConstraints Void Void</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                tx      = mconcat [mustSpendScriptOutput oref $ Redeemer $ PlutusTx.toData () | oref &lt;- orefs] &lt;&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                          mustValidateIn (from now)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            ledgerTx &lt;- submitTxConstraintsWith @Void lookups tx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            void $ awaitTxConfirmed $ txId ledgerTx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            logInfo @String $ &quot;collected gifts&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    isSuitable :: PubKeyHash -&gt; POSIXTime -&gt; TxOutTx -&gt; Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    isSuitable pkh now o = case txOutDatumHash $ txOutTxOut o of</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Nothing -&gt; False</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        Just h  -&gt; case Map.lookup h $ txData $ txOutTxTx o of</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Nothing        -&gt; False</span></div><div class="token-line" style="color:#393A34"><span class="token plain">            Just (Datum e) -&gt; case PlutusTx.fromData e of</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                Nothing -&gt; False</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                Just d  -&gt; beneficiary d == pkh &amp;&amp; deadline d &lt;= now</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Đầu tiên, chúng tôi lấy thời gian hiện tại và tính toán băm khóa công khai của chúng tôi. Sau đó, chúng tôi tra cứu tất cả các UTxO tại địa chỉ này và lọc chúng bằng cách sử dụng hàm <code>isSuitable</code> trợ giúp, được định nghĩa trong mệnh đề <code>where</code>.</p><p>Trước tiên, nó kiểm tra băm datum và nếu tìm thấy nó, nó sẽ cố gắng tìm kiếm datum tương ứng. Nhớ lại rằng giao dịch sản xuất, trong trường hợp <code>give</code> này không phải cung cấp datum, nó chỉ cần cung cấp băm datum. Tuy nhiên, trong trường hợp của chúng ta, chúng ta cần có sẵn dữ liệu cho endpoint <code>grab</code> , vì vậy endpoint <code>give</code> cung cấp datum.</p><p>Nếu endpoint <code>grab</code> tìm thấy datum, nó phải giải thích nó thành kiểu<code>Vesting</code> .</p><p>Nếu tất cả những điều này thành công, chúng tôi có thể kiểm tra xem chúng tôi có phải là người thụ hưởng hay không và thời hạn đã qua hay chưa.</p><p>Tại thời điểm này, <code>utxos</code> chứa tất cả các UTxO mà chúng ta có thể sử dụng. Nếu chúng tôi không tìm thấy, thì chúng tôi chỉ cần ghi lại một thông báo cho hiệu ứng đó. Nếu có ít nhất một giao dịch, thì chúng tôi tạo một giao dịch sử dụng tất cả chúng làm đầu vào và thanh toán tiền vào ví của chúng tôi.</p><p>Như <code>lookups</code>, chúng tôi cung cấp danh sách các UTxO cũng như tập lệnh trình xác thực. Nhớ lại rằng, để sử dụng UTxO tại địa chỉ này, giao dịch chi tiêu phải cung cấp tập lệnh xác thực.</p><p>Sau đó, chúng tôi tạo một giao dịch sử dụng tất cả các UTxO phù hợp cùng với một ràng buộc mà nó phải xác thực trong đó <code>Interval</code> kéo dài từ slot hiện tại cho đến hết thời gian. Nếu chúng tôi không cung cấp khoảng thời gian ở đây, thì việc xác thực sẽ không thành công, vì khoảng thời gian mặc định là từ ban đầu cho đến khi kết thúc thời gian. Xác thực trên chuỗi sẽ từ chối điều này vì nó cần một khoảng thời gian được chứa đầy đủ trong khoảng thời gian kéo dài từ thời hạn cho đến khi kết thúc thời gian.</p><p>Chúng tôi có thể sử dụng  <code>Interval</code> <code>now</code>, nhưng nếu có bất kỳ sự cố nào, chẳng hạn như sự chậm trễ của mạng và giao dịch đến một nút muộn hơn một hoặc hai vị trí, thì quá trình xác thực sẽ không hoạt động nữa.</p><p>và giờ, chúng ta chỉ tập hợp các endpoints.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">endpoints :: Contract () VestingSchema Text ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">endpoints = (give&#x27; `select` grab&#x27;) &gt;&gt; endpoints</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    give&#x27; = endpoint @&quot;give&quot; &gt;&gt;= give</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    grab&#x27; = endpoint @&quot;grab&quot; &gt;&gt;  grab</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Sau đó, có một số tấm bảng được sử dụng trong playground.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">mkSchemaDefinitions &#x27;&#x27;VestingSchema</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkKnownCurrencies []</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="in-the-playground"></a>In the playground<a class="hash-link" href="#in-the-playground" title="Direct link to heading">#</a></h3><p>Đầu tiên, hãy thêm một ví thứ ba. Chúng tôi sẽ tạo một kịch bản trong đó Ví 1 tạo hai quà tặng cho Ví 2 với thời hạn khác nhau và cũng tạo một quà tặng cho Ví 3.</p><p><img src="/assets/images/pic__00043-90836e56ce8338b63ac410965d2cc39c.png"></p><p>Thông thường, có thể gửi cả hai givegiao dịch trong cùng một vị trí, nhưng cách mã của chúng tôi được triển khai, chúng tôi chờ xác nhận, có nghĩa là chúng tôi cần thêm hành động chờ. Đây có thể không phải là cách tốt nhất để làm điều đó, nhưng đó là cách làm trong thời điểm hiện tại.</p><p><img src="/assets/images/pic__00044-ae789cd0b18189a70d1c764d465b5002.png"></p><p>Ở đây chúng tôi gặp phải vấn đề đầu tiên của chúng tôi. Chúng tôi cần cung cấp địa chỉ người thụ hưởng, nhưng không có cách nào trong sân chơi để lấy mã băm khóa công khai của ví.</p><p>Nhưng chúng ta có thể lấy nó từ REPL.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Week03.Homework1&gt; :l src/Week03/Vesting.hs </span></div><div class="token-line" style="color:#393A34"><span class="token plain">Ok, one module loaded.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Week03.Vesting&gt; import Ledger</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Ledger Week03.Vesting&gt; import Wallet.Emulator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Ledger Wallet.Emulator Week03.Vesting&gt; pubKeyHash $ walletPubKey $ Wallet 2</span></div><div class="token-line" style="color:#393A34"><span class="token plain">39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Ledger Wallet.Emulator Week03.Vesting&gt; pubKeyHash $ walletPubKey $ Wallet 3</span></div><div class="token-line" style="color:#393A34"><span class="token plain">dac073e0123bdea59dd9b3bda9cf6037f63aca82627d7abcd5c4ac29dd74003e</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p><img src="/assets/images/pic__00047-e701ccc70650672796705049bc861960.png"></p><p>Vấn đề tiếp theo là thời hạn. Trong bài giảng trước, chúng ta đã biết cách chuyển đổi giữa các vị trí và thời gian POSIX. Điều này đã thay đổi. Trước đây, bạn chỉ cần một vị trí và xuất hiện thời gian POSIX. Bây giờ có một cuộc tranh cãi thứ hai.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Ledger Wallet.Emulator Week03.Vesting&gt; import Ledger.TimeSlot </span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Ledger Wallet.Emulator Ledger.TimeSlot Week03.Vesting&gt; :t slotToBeginPOSIXTime</span></div><div class="token-line" style="color:#393A34"><span class="token plain">slotToBeginPOSIXTime :: SlotConfig -&gt; Slot -&gt; POSIXTime</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Cũng có những phiên bản slotToBeginPOSIXTimecó thời gian bắt đầu và kết thúc. Điều này là do một thời điểm không chỉ là một thời điểm, mà là một khoảng thời gian.</p><p>Vậy đây là <code>SlotConfig</code>?</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Ledger Wallet.Emulator Ledger.TimeSlot Week03.Vesting&gt; :i SlotConfig </span></div><div class="token-line" style="color:#393A34"><span class="token plain">type SlotConfig :: *</span></div><div class="token-line" style="color:#393A34"><span class="token plain">data SlotConfig</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  = SlotConfig {scSlotLength :: Integer, scZeroSlotTime :: POSIXTime}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        -- Defined in ‘Ledger.TimeSlot’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Eq SlotConfig -- Defined in ‘Ledger.TimeSlot’</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Show SlotConfig -- Defined in ‘Ledger.TimeSlot’</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nó tính theo độ dài vị trí và thời gian mà vị trí số 0 bắt đầu.</p><p>Vì vậy, bây giờ chúng ta phải tìm ra những gì SlotConfigđể sử dụng cho sân chơi. May mắn thay, nó là mặc định. Để làm được điều đó, chúng ta cần sử dụng <code>Data.Default</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Ledger Wallet.Emulator Ledger.TimeSlot Week03.Vesting&gt; import Data.Default</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Ledger Wallet.Emulator Ledger.TimeSlot Data.Default Week03.Vesting&gt; def :: SlotConfig</span></div><div class="token-line" style="color:#393A34"><span class="token plain">SlotConfig {scSlotLength = 1000, scZeroSlotTime = POSIXTime {getPOSIXTime = 1596059091000}}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bây giờ chúng ta có thể sử dụng <code>slotToBeginPOSIXTime</code> với cấu hình mặc định để lấy thời gian POSIX cho vùng 10 và vùng 20.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Ledger Wallet.Emulator Ledger.TimeSlot Data.Default Week03.Vesting&gt; slotToBeginPOSIXTime def 10</span></div><div class="token-line" style="color:#393A34"><span class="token plain">POSIXTime {getPOSIXTime = 1596059101000}</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Prelude Ledger Wallet.Emulator Ledger.TimeSlot Data.Default Week03.Vesting&gt; slotToBeginPOSIXTime def 20</span></div><div class="token-line" style="color:#393A34"><span class="token plain">POSIXTime {getPOSIXTime = 1596059111000}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Và chúng ta có thể sử dụng chúng trong sân chơi. Chúng tôi sẽ sử dụng vị trí 10 làm thời hạn cho <code>give</code> ví đầu tiên và thứ ba và vị trí 20 cho <code>give</code> ví thứ hai. Chúng tôi cũng sẽ đưa ra 10 Ada trong mỗi trường hợp. </p><p><img src="/assets/images/pic__00048-d7da99592a35e7501ca80f88da6366d0.png"></p><p>Hãy tạo một kịch bản mà mọi thứ đều hoạt động. Ví 3 nhận ở vị trí 10 khi thời hạn cho Ví 3 đã qua và Ví 2 lấy ở vị trí 20, khi cả hai thời hạn của Ví 2 đã qua. Chúng tôi sẽ sử dụng <code>Wait Until..</code> tùy chọn cho việc này.</p><p><img src="/assets/images/pic__00049-d73f83f7294dd0187da15f4eaa3c7247.png"></p><p>Sau khi đánh giá, đầu tiên chúng ta thấy giao dịch Genesis.</p><p><img src="/assets/images/pic__00050-cd1459efe52e84b5c3fcebd8fb077b08.png"></p><p>Nếu chúng ta xem xét giao dịch tiếp theo, chúng ta thấy quà tặng từ Ví 1 đến Ví 2 với thời hạn là 10. Tại đây, mười Ada bị khóa địa chỉ tập lệnh.</p><p><img src="/assets/images/pic__00051-74d33494d0e068519bd23ae9b42ae1ca.png"></p><p>Giao dịch tiếp theo là quà tặng từ Ví 1 đến Ví 2 với thời hạn là 20. Một UTxO mới hiện đã được tạo tại địa chỉ tập lệnh với mười Ada.</p><p><img src="/assets/images/pic__00052-baa346bdcdad8c6a6cf40acf94e227d3.png"></p><p>Và món quà thứ ba, lần này là Ví 3, với thời hạn là 10. Ví 1 hiện có khoảng 70 Ada và một UTxO khác được tạo với 10 Ada bị khóa tại địa chỉ tập lệnh.</p><p><img src="/assets/images/pic__00053-95169853875b3a94d47aacb5be95d8f1.png"></p><p>Tại vị trí số 10, Ví tiền 3 lấy thành công. UTxO thứ ba là đầu vào, một số khoản phí được thanh toán và sau đó phần còn lại của cuộc tình được gửi đến Ví 3.</p><p><img src="/assets/images/pic__00054-914e9e6153e10e5200376f911ef80451.png"></p><p>Sau đó, tại vị trí 20, Wallet 2 lấy thành công cả hai UTxO mà họ là người thụ hưởng. Lần này phí cao hơn vì phải chạy hai trình xác thực.</p><p><img src="/assets/images/pic__00055-9d7a06572c0cabe917a527aa359cf8e8.png"></p><p>Số dư cuối cùng phản ánh những thay đổi.</p><p><img src="/assets/images/pic__00056-ffd977106823023ce72d426f5bf57051.png"></p><p>Bây giờ chúng ta hãy xem xét trường hợp xảy ra quá sớm. Chúng tôi sẽ tạo cho Wallet 2 lấy ở vị trí 15 thay vì vị trí 20.</p><p><img src="/assets/images/pic__00010-86ac7d37c76a594b6967b6f7648e5335.png"></p><p>Bây giờ chúng ta thấy rằng các giao dịch đầu tiên giống nhau, nhưng giao dịch cuối cùng tại vị trí 15 chỉ có một đầu vào, vì UTxO thứ hai chưa có sẵn.</p><p><img src="/assets/images/pic__00057-deaf409949adb584abc3ce5ca4253d5a.png"></p><p>Và chúng ta có thể thấy rằng có 10 Ada vẫn bị khóa tại địa chỉ tập lệnh.</p><p><img src="/assets/images/pic__00057-deaf409949adb584abc3ce5ca4253d5a.png"></p><p>Mã off-chain của chúng tôi được viết theo cách mà nó sẽ chỉ gửi một giao dịch nếu có UTxO phù hợp có thể được lấy. Điều này có nghĩa là chúng tôi không thực sự sử dụng trình xác thực vì chúng tôi chỉ gửi các giao dịch đến chuỗi khối sẽ vượt qua xác thực.</p><p>Nếu bạn muốn kiểm tra trình xác thực, bạn có thể sửa đổi mã ví để điểm cuối lấy cố gắng lấy mọi thứ và sau đó xác thực sẽ không thành công nếu bạn không phải là người thụ hưởng hoặc chưa đến thời hạn.</p><p>Bạn cần lưu ý rằng bất kỳ ai cũng có thể viết mã ngoài chuỗi. Vì vậy, mặc dù nó hoạt động ngay bây giờ miễn là bạn sử dụng grabđiểm cuối mà chúng tôi đã tự viết, ai đó có thể viết một đoạn mã off-chain khác không lọc các UTxO như chúng tôi đã làm. Trong trường hợp này, nếu trình xác nhận không đúng, điều gì đó có thể sai khủng khiếp.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ví-dụ-2---parameterized-contract"></a>Ví dụ 2 - Parameterized Contract<a class="hash-link" href="#ví-dụ-2---parameterized-contract" title="Direct link to heading">#</a></h2><p>Chúng ta sẽ bắt đầu ví dụ tiếp theo bằng cách sao chép mã từ ví dụ vesting vào một mô-đun mới có tên <code>Week03.Parameterized</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="on-chain"></a>On-Chain<a class="hash-link" href="#on-chain" title="Direct link to heading">#</a></h3><p>Lưu ý rằng trong ví dụ vesting, chúng tôi đã sử dụng kiểu <code>Vesting</code>  làm datum, nhưng nó chỉ được sửa chữa, nó không thay đổi. Ngoài ra, chúng tôi có thể đưa nó vào hợp đồng, có thể nói, để chúng tôi có một hợp đồng mà bản thân tập lệnh đã chứa thông tin về người thụ hưởng và thời hạn.</p><p>Tất cả các ví dụ về hợp đồng mà chúng tôi đã thấy cho đến nay đã được sửa chữa. Chúng tôi đã sử dụng <code>TypedValidator</code> làm hằng số thời gian biên dịch. Ý tưởng của tập lệnh được tham số hóa là bạn có thể có một tham số và tùy thuộc vào giá trị của tham số, bạn nhận được các giá trị khác nhau của <code>TypedValidator</code>.</p><p>SVì vậy, thay vì xác định một tập lệnh, với một địa chỉ tập lệnh duy nhất, với tất cả các UTxO ở cùng một địa chỉ, bạn có thể xác định một họ tập lệnh được tham số hóa bởi một tham số nhất định. Trong trường hợp của chúng tôi, điều này có nghĩa là các UTxO cho những người thụ hưởng khác nhau và / hoặc thời hạn sẽ là một địa chỉ tập lệnh khác, vì chúng sẽ có trình xác thực được tham số hóa cụ thể cho các tham số của họ thay vì cụ thể cho dữ liệu của UTxO.</p><p>Chúng tôi sẽ trình bày cách thực hiện điều này bằng cách sử dụng một tham số thay vì sử dụng số liệu cho người thụ hưởng và giá trị thời hạn.</p><p>Hãy bắt đầu bằng cách đổi tên <code>VestingDatum</code> thành một cái gì đó phù hợp hơn.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data VestingParam = VestingParam</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      { beneficiary :: PubKeyHash</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      , deadline    :: POSIXTime</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      } deriving Show</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng tôi cũng sẽ xóa <code>unstableMakeIsData</code> vì chúng tôi không cần nó nữa.</p><p>Lý do chúng ta không cần nó, là vì chúng ta sẽ sử dụng <code>()</code> cho datum trong hàm  <code>mkValidator</code>. Tất cả thông tin chúng tôi yêu cầu sẽ nằm trong một đối số mới <code>mkValidator</code>, thuộc loại <code>VestingParam</code> mà chúng tôi thêm vào ở đầu danh sách các đối số.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">{-# INLINABLE mkValidator #-}</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator :: VestingParam -&gt; () -&gt; () -&gt; ScriptContext -&gt; Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">mkValidator p () () ctx = traceIfFalse &quot;beneficiary&#x27;s signature missing&quot; signedByBeneficiary &amp;&amp;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                          traceIfFalse &quot;deadline not reached&quot; deadlineReached</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    info :: TxInfo</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    info = scriptContextTxInfo ctx</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    signedByBeneficiary :: Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    signedByBeneficiary = txSignedBy info $ beneficiary p</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    deadlineReached :: Bool</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    deadlineReached = contains (from $ deadline p) $ txInfoValidRange info</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Chúng tôi cũng thay đổi kiểu <code>Vesting</code> để phản ánh sự thay đổi đối với datum.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data Vesting</span></div><div class="token-line" style="color:#393A34"><span class="token plain">instance Scripts.ValidatorTypes Vesting where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    type instance DatumType Vesting = ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    type instance RedeemerType Vesting = ()     </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bây giờ, <code>TypedValidator</code> không còn là một giá trị không đổi. Thay vào đó, nó sẽ nhận một tham số.</p><p>Nhớ lại rằng hàm <code>mkTypedValidator</code>  yêu cầu là đối số đầu tiên của nó mã đã biên dịch của một hàm nhận ba đối số và trả về một <code>Bool</code>. Nhưng bây giờ, nó có bốn đối số, vì vậy chúng ta cần tính đến điều đó.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">typedValidator :: VestingParam -&gt; Scripts.TypedValidator Vesting</span></div><div class="token-line" style="color:#393A34"><span class="token plain">typedValidator p = Scripts.mkTypedValidator @Vesting      </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bây giờ, những gì chúng tôi muốn làm là một cái gì đó như thế này, chuyển tham số mới <code>p</code> vào <code>mkValidator</code> để mã được biên dịch trong dấu ngoặc Oxford sẽ có kiểu chính xác.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">-- this won&#x27;t work</span></div><div class="token-line" style="color:#393A34"><span class="token plain">$$(PlutusTx.compile [|| mkValidator p ||])</span></div><div class="token-line" style="color:#393A34"><span class="token plain">$$(PlutusTx.compile [|| wrap ||])</span></div><div class="token-line" style="color:#393A34"><span class="token plain">where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">wrap = Scripts.wrapValidator @() @()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Mã này sẽ không hoạt động, nhưng trước khi chúng tôi điều tra, hãy để mã như hiện tại và thực hiện thêm một số thay đổi đối với phần còn lại của mã.</p><p><code>validator</code> bây giờ sẽ nhận một <code>VestingParam</code> và sẽ trả về một hàm đã soạn. Hàm được trả về có tác dụng mà bất kỳ tham số nào được truyền đến <code>validator</code> bây giờ sẽ được chuyển đến hàm <code>typedValidator</code> một cách hiệu quả , giá trị trả về của chúng sẽ được chuyển đến <code>validatorScript</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">validator :: VestingParam -&gt; Validator</span></div><div class="token-line" style="color:#393A34"><span class="token plain">validator = Scripts.validatorScript . typedValidator</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Và tương tự đối với <code>valHash</code> và <code>scrAddress</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">valHash :: VestingParam -&gt; Ledger.ValidatorHash</span></div><div class="token-line" style="color:#393A34"><span class="token plain">valHash = Scripts.validatorHash . typedValidator</span></div><div class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#393A34"><span class="token plain">scrAddress :: VestingParam -&gt; Ledger.Address</span></div><div class="token-line" style="color:#393A34"><span class="token plain">scrAddress = scriptAddress . validator</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bây giờ, chúng ta hãy tìm hiểu những gì sai với hàm <code>typedValidator</code> .</p><p>Nếu chúng tôi cố gắng khởi chạy REPL, chúng tôi sẽ gặp lỗi biên dịch.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">GHC Core to PLC plugin: E043:Error: Reference to a name which is not a local, a builtin, or an external INLINABLE function: Variable p</span></div><div class="token-line" style="color:#393A34"><span class="token plain">No unfolding</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Context: Compiling expr: p</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Context: Compiling expr: Week03.Parameterized.mkValidator p</span></div><div class="token-line" style="color:#393A34"><span class="token plain">Context: Compiling expr at &quot;plutus-pioneer-program-week03-0.1.0.0-inplace:Week03.Parameterized:(67,10)-(67,48)&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Vấn đề là dòng này.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">-- this won&#x27;t work</span></div><div class="token-line" style="color:#393A34"><span class="token plain">$$(PlutusTx.compile [|| mkValidator p ||])</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nhớ lại rằng mọi thứ bên trong dấu ngoặc [] phải được biết rõ ràng tại thời điểm biên dịch. Thông thường, nó thậm chí sẽ cần tất cả mã được viết rõ ràng, nhưng bằng cách sử dụng thống số <code>INLINABLE</code> trong hàm <code>mkValidator</code>, chúng ta có thể tham chiếu hàm để thay thế. Tuy nhiên, nó vẫn phải được biết tại thời điểm biên dịch, vì đó là cách hoạt động của Template Haskell - nó được thực thi trước trình biên dịch chính.</p><p> <code>p</code> không biết đến lúc biên dịch, bởi vì chúng tôi có ý định cung cấp nó khi chạy. May mắn thay, có một cách để giải quyết vấn đề này.</p><p>Về phía Haskell, chúng tôi có hàm <code>mkValidator</code> của mình và chúng tôi có <code>p</code> kiểu <code>VestingParam</code>. Chúng tôi có thể biên dịch <code>mkValidator</code> sang Plutus core, nhưng chúng tôi không thể biên dịch <code>p</code> sang Plutus core vì chúng tôi không biết nó là gì. Nhưng, nếu chúng ta có thể sử dụng phiên bản đã biên dịch <code>p</code>, chúng ta có thể áp dụng phiên bản đã biên dịch này cho phiên bản đã biên dịch mkValidatorvà điều này sẽ mang lại cho chúng ta những gì chúng ta muốn.</p><p>Điều này dường như không giải quyết được gì, bởi vì chúng tôi vẫn cần một phiên bản đã biên dịch <code>p</code> và chúng tôi có cùng một vấn đề <code>p</code> chưa được biết tại thời điểm biên dịch.</p><p>Tuy nhiên, <code>p</code> pkhông phải là một số mã Haskell tùy ý, mà là dữ liệu, vì vậy nó không chứa bất kỳ loại chức năng nào. Nếu chúng ta thực hiện kiểu của <code>p</code> thể hiện của lớp kiểu được gọi <code>Lift</code>. Chúng ta có thể sử dụng <code>liftCode</code> để biên dịch <code>p</code> trong thời gian biên dịch sang Plutus Core và sau đó, bằng cách sử dụng <code>applyCode</code> chúng ta có thể áp dụng Plutus Core <code>p</code>  cho Plutus Core <code>mkValidator</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="lớp-lift"></a>Lớp Lift<a class="hash-link" href="#lớp-lift" title="Direct link to heading">#</a></h4><p>Chúng ta hãy nhìn sơ qua về lớp <code>Lift</code>  Nó được định nghĩa trong gói plutus-tx.</p><p><code>plutus-tx</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">module PlutusTx.Lift.Class</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nó chỉ có một chức năng <code>Lift</code>. Tuy nhiên, chúng tôi sẽ không sử dụng chức năng này trực tiếp</p><p>Tầm quan trọng của lớp là nó cho phép chúng ta, trong thời gian chạy,  các giá trị lift của Haskell thành các giá trị tập lệnh Plutus tương ứng. Và đây chính xác là những gì chúng ta cần để chuyển tham số của mình <code>p</code> thành mã.</p><p>Chúng ta sẽ sử dụng một hàm khác, được định nghĩa trong cùng một gói nhưng trong một mô-đun khác.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">module PlutusTx.Lift</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Hàm chúng ta sẽ sử dụng được gọi  <code>liftCode</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">-- | Get a Plutus Core program corresponding to the given value as a &#x27;CompiledCodeIn&#x27;, throwing any errors that occur as exceptions and ignoring fresh names.</span></div><div class="token-line" style="color:#393A34"><span class="token plain">liftCode</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   :: (Lift.Lift uni a, Throwable uni fun, PLC.ToBuiltinMeaning uni fun)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">   =&gt; a -&gt; CompiledCodeIn uni fun a</span></div><div class="token-line" style="color:#393A34"><span class="token plain">liftCode x = unsafely $ safeLiftCode x</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Nó nhận một giá trị Haskell của kiểu <code>a</code>, với điều kiện <code>a</code> là một thể hiện của lớp <code>Lift</code> và biến nó thành một đoạn mã tập lệnh Plutus tương ứng với cùng kiểu.</p><p>Bây giờ chúng tôi có thể sửa chữa trình xác nhận của mình.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">typedValidator :: VestingParam -&gt; Scripts.TypedValidator Vesting</span></div><div class="token-line" style="color:#393A34"><span class="token plain">typedValidator p = Scripts.mkTypedValidator @Vesting</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    ($$(PlutusTx.compile [|| mkValidator ||]) `PlutusTx.applyCode` PlutusTx.liftCode p)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    $$(PlutusTx.compile [|| wrap ||])</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    wrap = Scripts.wrapValidator @() @()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Mã này ổn, nhưng nó sẽ không được biên dịch, bởi vì <code>VestingParam</code> không phải là một phiên bản của <code>Lift</code>. Để khắc phục điều này, chúng ta có thể sử dụng <code>makeLift</code></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">PlutusTx.makeLift &#x27;&#x27;VestingParam</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Và, chúng ta cần bật tiện ích mở rộng GHC.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">{-# LANGUAGE MultiParamTypeClasses #-}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Bây giờ nó sẽ biên dịch.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="off-chain"></a>Off-Chain<a class="hash-link" href="#off-chain" title="Direct link to heading">#</a></h3><p>Mã ngoài chuỗi không thay đổi nhiều.</p><p>Các <code>GiveParams</code> vẫn giống nhau.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">data GiveParams = GiveParams</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      { gpBeneficiary :: !PubKeyHash</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      , gpDeadline    :: !POSIXTime</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      , gpAmount      :: !Integer</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      } deriving (Generic, ToJSON, FromJSON, ToSchema)      </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p><code>VestingSchema</code> đã thay đổi một chút vì endpoint <code>grab</code>  giờ đây dựa vào việc biết người thụ hưởng và thời hạn để biết xác định địa chỉ tập lệnh. Chúng tôi biết người thụ hưởng vì nó sẽ là mã băm khóa công khai của ví gọi <code>grab</code>, nhưng chúng tôi không biết thời hạn, vì vậy chúng tôi phải chuyển nó cho <code>grab</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">type VestingSchema =</span></div><div class="token-line" style="color:#393A34"><span class="token plain">          Endpoint &quot;give&quot; GiveParams</span></div><div class="token-line" style="color:#393A34"><span class="token plain">      .\/ Endpoint &quot;grab&quot; POSIXTime</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>endpoint<code>give</code> tương tự như ví dụ vesting, nhưng có một số khác biệt.</p><p>Thay vì tính toán dữ liệu, chúng tôi sẽ xây dựng một cái gì đó kiểu
<code>VestingParam</code>.Chúng tôi cũng thay đổi tham chiếu đến datum trong
<code>mustPayToTheScript</code> để trở thành <code>()</code>, và chúng tôi cung cấp các loại <code>p</code> để <code>typedValidator</code> như nó không còn là một hằng số.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">give :: AsContractError e =&gt; GiveParams -&gt; Contract w s e ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">give gp = do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    let p  = VestingParam</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                { beneficiary = gpBeneficiary gp</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                , deadline    = gpDeadline gp</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        tx = mustPayToTheScript () $ Ada.lovelaceValueOf $ gpAmount gp</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    ledgerTx &lt;- submitTxConstraints (typedValidator p) tx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    void $ awaitTxConfirmed $ txId ledgerTx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    logInfo @String $ printf &quot;made a gift of %d lovelace to %s with deadline %s&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        (gpAmount gp)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        (show $ gpBeneficiary gp)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        (show $ gpDeadline gp)      </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Endpoint <code>grab</code>  cũng có một số thay đổi.</p><p>Nhớ lại rằng trước đó chúng ta có tất cả các UTxO ở tại một địa chỉ tập lệnh này và chúng có thể dành cho những người thụ hưởng tùy ý và cho những thời hạn tùy ý. Vì lý do này, chúng tôi phải lọc những UTxO dành cho chúng tôi và những nơi đã đến thời hạn.</p><p>Bây giờ chúng tôi có tham số bổ sung, mà chúng tôi sẽ gọi <code>d</code>, đại diện cho thời hạn. Vì vậy, chúng tôi có thể ngay lập tức xem nếu thời hạn đã đến hay chưa.</p><p>Nếu nó vẫn chưa đạt được, chúng tôi viết một thông báo nhật ký và dừng lại, nếu không chúng tôi tiếp tục và xây dựng <code>VestingParam</code>.</p><p>Sau đó, chúng tôi tìm kiếm các UTxO có tại địa chỉ này. Địa chỉ không phải là một hằng số nữa, nó nhận một tham số. Vì vậy, bây giờ, chúng tôi sẽ chỉ nhận được UTxO dành cho chúng tôi và đã đến thời hạn. Chúng ta không cần lọc bất cứ thứ gì.</p><p>Nếu không có thông báo nào, chúng tôi ghi lại một thông báo cho hiệu ứng đó và dừng lại, nếu không, chúng tôi làm nhiều hơn hoặc ít hơn những gì chúng tôi đã làm trước đó.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">grab d = do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">now   &lt;- currentTime</span></div><div class="token-line" style="color:#393A34"><span class="token plain">pkh   &lt;- pubKeyHash &lt;$&gt; ownPubKey</span></div><div class="token-line" style="color:#393A34"><span class="token plain">if now &lt; d</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    then logInfo @String $ &quot;too early&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    else do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">        let p = VestingParam</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    { beneficiary = pkh</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    , deadline    = d</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    }</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    utxos &lt;- utxoAt $ scrAddress p</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                    if Map.null utxos</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        then logInfo @String $ &quot;no gifts available&quot;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                        else do</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            let orefs   = fst &lt;$&gt; Map.toList utxos</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                lookups = Constraints.unspentOutputs utxos      &lt;&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                          Constraints.otherScript (validator p)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                tx :: TxConstraints Void Void</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                tx      = mconcat [mustSpendScriptOutput oref $ Redeemer $ PlutusTx.toData () | oref &lt;- orefs] &lt;&gt;</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                                          mustValidateIn (from now)</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            ledgerTx &lt;- submitTxConstraintsWith @Void lookups tx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            void $ awaitTxConfirmed $ txId ledgerTx</span></div><div class="token-line" style="color:#393A34"><span class="token plain">                            logInfo @String $ &quot;collected gifts&quot;                          </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><p>Các hàm <code>endpoints</code> là hơi khác nhau do các tham số mới cho<code>grab</code>.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI {.haskell}"><div tabindex="0" class="prism-code language-{.haskell} codeBlock_rtdJ thin-scrollbar"><div class="codeBlockLines_1zSZ" style="color:#393A34;background-color:#f6f8fa"><div class="token-line" style="color:#393A34"><span class="token plain">endpoints :: Contract () VestingSchema Text ()</span></div><div class="token-line" style="color:#393A34"><span class="token plain">endpoints = (give&#x27; `select` grab&#x27;) &gt;&gt; endpoints</span></div><div class="token-line" style="color:#393A34"><span class="token plain">  where</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    give&#x27; = endpoint @&quot;give&quot; &gt;&gt;= give</span></div><div class="token-line" style="color:#393A34"><span class="token plain">    grab&#x27; = endpoint @&quot;grab&quot; &gt;&gt;= grab</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="quay-lại-playground"></a>Quay lại playground<a class="hash-link" href="#quay-lại-playground" title="Direct link to heading">#</a></h3><p>Bây giờ chúng tôi sẽ sao chép và dán hợp đồng mới này vào sân chơi và thiết lập một kịch bản mới.</p><p>Các <code>give</code> giao dịch đều giống nhau.</p><p><img src="/assets/images/pic__00059-7f45bb1aa7d141818049b51dd65f2e37.png"></p><p><code>Grab</code> hơi khác nhau. Trong lần triển khai trước đó của chúng tôi, một ví có thể lấy UTxO với các thời hạn khác nhau miễn là thời hạn đã qua. Bây giờ thời hạn là một phần của tham số script, vì vậy chúng ta cần chỉ định nó để lấy địa chỉ script. Điều này có nghĩa là Ví 2 không thể lấy quà cho các vị trí 10 và 20 cùng một lúc, ít nhất là không theo cách mà chúng tôi đã triển khai.</p><p>Trước tiên, chúng ta có thể đợi cho đến khe 10 và sau đó Ví 2 sẽ có thể nhận được món quà đầu tiên và Ví 3 sẽ có thể nhận được món quà duy nhất của nó.</p><p>Chúng tôi sẽ thêm một <code>grab</code> cho ví 2 và ví 3. Ở đây, chúng tôi không cần phải phân biệt giữa mỗi giao dịch vì nó là hai ví khác nhau.</p><p>Sau đó, chúng tôi đợi cho đến khe 20 và thực hiện lần thứ hai của <code>grab</code>ví 2  và sau đó đợi 1 khối, như bình thường.</p><p><img src="/assets/images/pic__00060-1d269ec56accfe952503077c80c645d2.png"></p><p>Vì vậy, hãy xem nếu nó hoạt động bằng cách nhấp vào <code>Evaluate</code>.</p><p><img src="/assets/images/pic__00061-34ad2459354578430639958932e6ab4e.png"></p><p>Ghi lại địa chỉ tập lệnh cho giao dịch đó tại vị trí 1.</p><p><img src="/assets/images/pic__00062-e875c97dd2255764dd0f1526e5f9922a.png"></p><p>Và so sánh địa chỉ này với địa chỉ tập lệnh cho đầu ra giao dịch tại vị trí 2.</p><p><img src="/assets/images/pic__00063-3044e6b470677ac95cdbeeee08d43c7d.png"></p><p>Lưu ý rằng địa chỉ tập lệnh cho các UTxO là khác nhau. Trong phiên bản đầu tiên của hợp đồng vesting, địa chỉ tập lệnh là một hằng số. Điều này có nghĩa là tất cả quà tặng của chúng tôi kết thúc ở cùng một địa chỉ tập lệnh và chỉ có dữ liệu trong mỗi UTxO là khác nhau.</p><p>Bây giờ, dữ liệu là chính xác <code>()</code> và người thụ hưởng và thời hạn được bao gồm như một phần của chính tập lệnh, vì vậy các địa chỉ bây giờ khác nhau tùy thuộc vào người thụ hưởng và các tham số thời hạn.</p><p>Đối với món quà cho Ví 3, chúng tôi thấy có một địa chỉ khác.</p><p><img src="/assets/images/pic__00064-a48c950dd5dece774d65874dc96f8994.png"></p><p>Chúng tôi thấy hai lần lấy ở vị trí 10, một của Ví 2 và một của Ví 3. Thứ tự mà chúng được xử lý không mang tính xác định.</p><p>Sau đó, cuối cùng ở khe 20, Wallet 2 lấy phần quà còn lại của nó.</p><p>Và số dư cuối cùng phản ánh các giao dịch đã xảy ra.</p><p><img src="/assets/images/pic__00065-00802007ba5f1b30c6122d3f2985f8fa.png"></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/cardano2vn/cardanovn-portal/edit/main/docs/dr-lars-lession/week3.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/dr-lars-lession/week2"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Week 02 - Validation</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/dr-lars-lession/week4"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Week 04 - Monads »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#trước-khi-chúng-ta-bắt-đầu" class="table-of-contents__link">Trước khi chúng ta bắt đầu</a></li><li><a href="#tóm-tắt-lại" class="table-of-contents__link">Tóm tắt lại</a></li><li><a href="#scriptcontext" class="table-of-contents__link">ScriptContext</a><ul><li><a href="#txinfovalidrange" class="table-of-contents__link">txInfoValidRange</a></li><li><a href="#posixtimerange" class="table-of-contents__link">POSIXTimeRange</a></li></ul></li><li><a href="#ví-dụ---vesting" class="table-of-contents__link">Ví dụ - Vesting</a><ul><li><a href="#in-the-playground" class="table-of-contents__link">In the playground</a></li></ul></li><li><a href="#ví-dụ-2---parameterized-contract" class="table-of-contents__link">Ví dụ 2 - Parameterized Contract</a><ul><li><a href="#on-chain" class="table-of-contents__link">On-Chain</a></li><li><a href="#off-chain" class="table-of-contents__link">Off-Chain</a></li><li><a href="#quay-lại-playground" class="table-of-contents__link">Quay lại playground</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Tài liệu</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/getting-started/overview">Bắt đầu</a></li></ul></div><div class="col footer__col"><div class="footer__title">Cộng đồng</div><ul class="footer__items"><li class="footer__item"><a href="https://t.me/cardano2vn" target="_blank" rel="noopener noreferrer" class="footer__link-item">Telegram</a></li><li class="footer__item"><a href="https://www.youtube.com/channel/UCJTdAQPGJntJet5v-nk9ebA" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li><li class="footer__item"><a href="https://github.com/cardano2vn" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/about-us">About Us</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">The content of this site is referenced and copied from the <a href="https://developers.cardano.org/" target="_blank" rel="noopener noreferrer">Cardano Developer</a>, 2021</div></div></div></footer></div>
<script src="/assets/js/runtime~main.af40557b.js"></script>
<script src="/assets/js/main.97b62b7d.js"></script>
</body>
</html>
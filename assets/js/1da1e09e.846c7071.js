"use strict";(self.webpackChunkbringscdocs=self.webpackChunkbringscdocs||[]).push([[2500],{3905:function(n,e,t){t.d(e,{Zo:function(){return h},kt:function(){return d}});var a=t(7294);function l(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function r(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){l(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,a,l=function(n,e){if(null==n)return{};var t,a,l={},i=Object.keys(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||(l[t]=n[t]);return l}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(l[t]=n[t])}return l}var c=a.createContext({}),p=function(n){var e=a.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):r(r({},e),n)),t},h=function(n){var e=p(n.components);return a.createElement(c.Provider,{value:e},n.children)},s={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(n,e){var t=n.components,l=n.mdxType,i=n.originalType,c=n.parentName,h=o(n,["components","mdxType","originalType","parentName"]),u=p(t),d=l,m=u["".concat(c,".").concat(d)]||u[d]||s[d]||i;return t?a.createElement(m,r(r({ref:e},h),{},{components:t})):a.createElement(m,r({ref:e},h))}));function d(n,e){var t=arguments,l=e&&e.mdxType;if("string"==typeof n||l){var i=t.length,r=new Array(i);r[0]=u;var o={};for(var c in e)hasOwnProperty.call(e,c)&&(o[c]=e[c]);o.originalType=n,o.mdxType="string"==typeof n?n:l,r[1]=o;for(var p=2;p<i;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5628:function(n,e,t){t.r(e),t.d(e,{frontMatter:function(){return o},metadata:function(){return c},toc:function(){return p},default:function(){return s}});var a=t(7462),l=t(3366),i=(t(7294),t(3905)),r=["components"],o={},c={unversionedId:"dr-lars-lession/week4",id:"dr-lars-lession/week4",isDocsHomePage:!1,title:"Week 04 - Monads",description:"\u0110\xe2y l\xe0 phi\xean b\u1ea3n vi\u1ebft c\u1ee7a B\xe0i [gi\u1ea3ng s\u1ed1",source:"@site/docs/dr-lars-lession/week4.md",sourceDirName:"dr-lars-lession",slug:"/dr-lars-lession/week4",permalink:"/docs/dr-lars-lession/week4",editUrl:"https://github.com/cardano2vn/cardanovn-portal/edit/main/docs/dr-lars-lession/week4.md",version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"Week 03 - Script Context",permalink:"/docs/dr-lars-lession/week3"}},p=[{value:"T\u1ed5ng quat",id:"t\u1ed5ng-quat",children:[]},{value:"Monads",id:"monads",children:[{value:"Hello World",id:"hello-world",children:[]},{value:"getLine",id:"getline",children:[]},{value:"Maybe",id:"maybe",children:[]},{value:"M\u1ed9t trong hai (Either)",id:"m\u1ed9t-trong-hai-either",children:[]},{value:"Writer",id:"writer",children:[]},{value:"What is a Monad?",id:"what-is-a-monad",children:[]},{value:"Why Is This useful?",id:"why-is-this-useful",children:[]},{value:"&#39;do&#39; notation",id:"do-notation",children:[]}]},{value:"Plutus Monads",id:"plutus-monads",children:[{value:"The EmulatorTrace Monad",id:"the-emulatortrace-monad",children:[]},{value:"The Contract Monad",id:"the-contract-monad",children:[]}]}],h={toc:p};function s(n){var e=n.components,t=(0,l.Z)(n,r);return(0,i.kt)("wrapper",(0,a.Z)({},h,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"\u0110\xe2y l\xe0 phi\xean b\u1ea3n vi\u1ebft c\u1ee7a B\xe0i ",(0,i.kt)("a",{parentName:"p",href:"https://youtu.be/HLJOcKlEucI"},"gi\u1ea3ng s\u1ed1\n4"),"."),(0,i.kt)("p",null,"Trong b\xe0i gi\u1ea3ng n\xe0y, ch\xfang ta t\xecm hi\u1ec3u v\u1ec1 \u0110\u01a1n nguy\xean (monads). \u0110\u1eb7c bi\u1ec7t l\xe0 c\xe1c\nmonads EmulatorTrace v\xe0 Contract..\n:::"),(0,i.kt)("h2",{id:"t\u1ed5ng-quat"},"T\u1ed5ng quat"),(0,i.kt)("p",null,"Ch\xfang t\xf4i \u0111\xe3 d\xe0nh hai b\xe0i gi\u1ea3ng cu\u1ed1i c\xf9ng \u0111\u1ec3 n\xf3i v\u1ec1 ph\u1ea7n on-chain c\u1ee7a\nPlutus - logic x\xe1c th\u1ef1c \u0111\u01b0\u1ee3c bi\xean d\u1ecbch th\xe0nh t\u1eadp l\u1ec7nh Plutus v\xe0 th\u1ef1c s\u1ef1\ns\u1ed1ng tr\xean blockchain v\xe0 \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n b\u1edfi c\xe1c n\xfat x\xe1c th\u1ef1c giao d\u1ecbch."),(0,i.kt)("p",null,"C\xf2n r\u1ea5t nhi\u1ec1u \u0111i\u1ec1u \u0111\u1ec3 n\xf3i v\u1ec1 b\u1ed9 ph\u1eadn on-chain \u0111\xf3."),(0,i.kt)("p",null,"Ch\xfang t\xf4i ch\u01b0a xem x\xe9t c\xe1c v\xed d\u1ee5 ph\u1ee9c t\u1ea1p h\u01a1n v\u1ec1 x\xe1c th\u1ef1c s\u1eed d\u1ee5ng ng\u1eef\nc\u1ea3nh ph\u1ee9c t\u1ea1p h\u01a1n v\xe0 ch\xfang t\xf4i ch\u01b0a th\u1ea5y c\xe1ch m\xe3 th\xf4ng b\xe1o g\u1ed1c ho\u1ea1t \u0111\u1ed9ng\nnh\u01b0 th\u1ebf n\xe0o (t\u1eadp l\u1ec7nh Plutus c\u0169ng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 x\xe1c th\u1ef1c vi\u1ec7c \u0111\xfac v\xe0\n\u0111\u1ed1t m\xe3 th\xf4ng b\xe1o g\u1ed1c)."),(0,i.kt)("p",null,"Ch\xfang ta ch\u1eafc ch\u1eafn s\u1ebd ph\u1ea3i n\xf3i v\u1ec1 nh\u1eefng ch\u1ee7 \u0111\u1ec1 \u0111\xf3, v\xe0 quay l\u1ea1i v\u1ea5n \u0111\u1ec1\n\u0111\xf3."),(0,i.kt)("p",null,"Tuy nhi\xean, tr\u01b0\u1edbc khi \u0111i v\xe0o qu\xe1 nhi\u1ec1u ch\u1ee7 \u0111\u1ec1 ph\u1ee9c t\u1ea1p v\u1ec1 x\xe1c th\u1ef1c tr\xean\nchu\u1ed7i, ch\xfang ta kh\xf4ng \u0111\u01b0\u1ee3c b\u1ecf qua ph\u1ea7n ngo\xe0i chu\u1ed7i, v\xec n\xf3 c\u0169ng quan\ntr\u1ecdng kh\xf4ng k\xe9m."),(0,i.kt)("p",null,"Ph\u1ea7n on-chain \u0111\u1ea3m nh\u1eadn vi\u1ec7c x\xe1c th\u1ef1c nh\u01b0ng \u0111\u1ec3 c\xf3 th\u1ee9 g\xec \u0111\xf3 \u0111\u01b0\u1ee3c x\xe1c\nth\u1ef1c, ch\xfang ta ph\u1ea3i x\xe2y d\u1ef1ng m\u1ed9t giao d\u1ecbch v\xe0 g\u1eedi n\xf3 l\xean blockchain. V\xe0,\n\u0111\xf3 l\xe0 nh\u1eefng g\xec ph\u1ea7n off-chain th\u1ef1c hi\u1ec7n."),(0,i.kt)("p",null,"V\xec v\u1eady, ch\xfang ta s\u1ebd b\u1eaft \u0111\u1ea7u n\xf3i v\u1ec1 c\xe1ch vi\u1ebft m\xe3 Plutus ngo\xe0i chu\u1ed7i."),(0,i.kt)("p",null,"Th\u1eadt kh\xf4ng may, c\xf3 m\u1ed9t v\u1ea5n \u0111\u1ec1 nh\u1ecf li\xean quan \u0111\u1ebfn c\xe1c t\xednh n\u0103ng Haskell\nc\u1ea7n thi\u1ebft."),(0,i.kt)("p",null,"Ph\u1ea7n on-chain m\xe0 ch\xfang ta \u0111\xe3 th\u1ea5y cho \u0111\u1ebfn nay h\u01a1i xa l\u1ea1 v\xe0 c\u1ea7n l\xe0m quen\nm\u1ed9t ch\xfat, do th\u1ef1c t\u1ebf l\xe0 ch\xfang ta c\xf3 th\xeam s\u1ef1 ph\u1ee9c t\u1ea1p c\u1ee7a qu\xe1 tr\xecnh bi\xean\nd\u1ecbch sang t\u1eadp l\u1ec7nh Plutus. Nh\u01b0ng, ch\xfang ta kh\xf4ng th\u1ef1c s\u1ef1 ph\u1ea3i lo l\u1eafng v\u1ec1\n\u0111i\u1ec1u \u0111\xf3 n\u1ebfu ch\xfang ta s\u1eed d\u1ee5ng ph\xe9p thu\u1eadt Template Haskell. Trong tr\u01b0\u1eddng\nh\u1ee3p \u0111\xf3, h\xe0m x\xe1c nh\u1eadn ch\u1ec9 l\xe0 m\u1ed9t h\xe0m \u0111\u01a1n gi\u1ea3n."),(0,i.kt)("p",null,"V\xe0 n\xf3 th\u1ef1c s\u1ef1 l\xe0 m\u1ed9t h\xe0m Haskell r\u1ea5t \u0111\u01a1n gi\u1ea3n theo quan \u0111i\u1ec3m k\u1ef9 thu\u1eadt.\nCh\xfang t\xf4i kh\xf4ng s\u1eed d\u1ee5ng b\u1ea5t k\u1ef3 t\xednh n\u0103ng Haskell \u01b0a th\xedch n\xe0o \u0111\u1ec3 vi\u1ebft\nh\xe0m n\xe0y."),(0,i.kt)("p",null,"M\u1ed9t trong nh\u1eefng l\xfd do cho \u0111i\u1ec1u \u0111\xf3 l\xe0 c\xe1ch th\u1ee9c ho\u1ea1t \u0111\u1ed9ng c\u1ee7a qu\xe1 tr\xecnh\nbi\xean d\u1ecbch Plutus. Ch\xfang t\xf4i \u0111\xe3 th\u1ea5y l\xe0m th\u1ebf n\xe0o \u0111\u1ec3 vi\u1ec7c bi\xean d\u1ecbch sang\nPlutus th\xe0nh c\xf4ng, t\u1ea5t c\u1ea3 m\xe3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng b\u1edfi h\xe0m x\xe1c nh\u1eadn ph\u1ea3i c\xf3 s\u1eb5n\ntrong Oxford Brackets. \u0110i\u1ec1u n\xe0y c\xf3 ngh\u0129a l\xe0 t\u1ea5t c\u1ea3 c\xe1c ch\u1ee9c n\u0103ng \u0111\u01b0\u1ee3c s\u1eed\nd\u1ee5ng b\u1edfi ch\u1ee9c n\u0103ng ",(0,i.kt)("inlineCode",{parentName:"p"},"mkValidator")," ph\u1ea3i s\u1eed d\u1ee5ng pragma INLINABLE."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"{-# INLINABLE mkValidator #-}\nmkValidator :: Data -> Data -> Data -> ()\nmkValidator _ _ _ = ()\n\n$$(PlutusTx.compile [|| mkValidator ||])\n")),(0,i.kt)("p",null,"V\xe0 h\xe3y nh\u1edb l\u1ea1i r\u1eb1ng v\xec c\xe1c h\xe0m Haskell ti\xeau chu\u1ea9n kh\xf4ng c\xf3 pragma C\xd3 TH\u1ec2\nL\u1ec6NH n\xe0y, n\xean c\xf3 m\u1ed9t m\xf4-\u0111un Plutus Prelude m\u1edbi t\u01b0\u01a1ng t\u1ef1 nh\u01b0 Haskell\nPrelude ti\xeau chu\u1ea9n, nh\u01b0ng v\u1edbi c\xe1c ch\u1ee9c n\u0103ng \u0111\u01b0\u1ee3c x\xe1c \u0111\u1ecbnh v\u1edbi pragma\nINLINABLE."),(0,i.kt)("p",null,"Nh\u01b0ng, t\u1ea5t nhi\xean, c\xf3 h\xe0ng tr\u0103m th\u01b0 vi\u1ec7n Haskell ngo\xe0i kia v\xe0 h\u1ea7u h\u1ebft\nch\xfang kh\xf4ng \u0111\u01b0\u1ee3c vi\u1ebft v\u1edbi Plutus, v\xec v\u1eady ch\xfang t\xf4i kh\xf4ng th\u1ec3 s\u1eed d\u1ee5ng\nch\xfang trong qu\xe1 tr\xecnh x\xe1c th\u1ef1c. V\xe0, \u0111i\u1ec1u \u0111\xf3 c\xf3 t\xe1c d\u1ee5ng l\xe0 x\xe1c th\u1ef1c b\xean\ntrong Haskell s\u1ebd t\u01b0\u01a1ng \u0111\u1ed1i \u0111\u01a1n gi\u1ea3n v\xe0 s\u1ebd kh\xf4ng c\xf3 nhi\u1ec1u ph\u1ee5 thu\u1ed9c."),(0,i.kt)("h2",{id:"monads"},"Monads"),(0,i.kt)("p",null,"Trong ph\u1ea7n off-chain c\u1ee7a Plutus, t\xecnh h\xecnh \u0111\xe3 \u0111\u1ea3o ng\u01b0\u1ee3c. Ch\xfang ta kh\xf4ng\nph\u1ea3i lo l\u1eafng v\u1ec1 vi\u1ec7c bi\xean d\u1ecbch sang t\u1eadp l\u1ec7nh Plutus - n\xf3 ch\u1ec9 l\xe0 Haskell\n\u0111\u01a1n gi\u1ea3n. Tuy nhi\xean, m\u1eb7t tr\xe1i c\u1ee7a n\xf3 l\xe0, c\xe1ch n\xf3 \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n, n\xf3 s\u1eed\nd\u1ee5ng c\xe1c t\xednh n\u0103ng Haskell ph\u1ee9c t\u1ea1p h\u01a1n nhi\u1ec1u - v\xed d\u1ee5 nh\u01b0 c\xe1i g\u1ecdi l\xe0 h\u1ec7\nth\u1ed1ng hi\u1ec7u \u1ee9ng, ph\xe1t tr\u1ef1c tuy\u1ebfn v\xe0 \u0111\u1eb7c bi\u1ec7t l\xe0 monads."),(0,i.kt)("p",null,"T\u1ea5t c\u1ea3 m\xe3 off-chain (m\xe3 v\xed), \u0111\u01b0\u1ee3c vi\u1ebft b\u1eb1ng m\u1ed9t \u0111\u01a1n nguy\xean \u0111\u1eb7c bi\u1ec7t -\n\u0110\u01a1n nguy\xean h\u1ee3p \u0111\u1ed3ng."),(0,i.kt)("p",null,"C\xe1c tu vi\u1ec7n n\u1ed5i ti\u1ebfng trong th\u1ebf gi\u1edbi Haskell. \u0110\xe2y th\u01b0\u1eddng l\xe0 tr\u1edf ng\u1ea1i \u0111\u1ea7u\nti\xean khi b\u1eaft \u0111\u1ea7u l\u1eadp tr\xecnh vi\xean Haskell."),(0,i.kt)("p",null,"C\xf3 r\u1ea5t nhi\u1ec1u h\u01b0\u1edbng d\u1eabn c\u1ed1 g\u1eafng gi\u1ea3i th\xedch c\xe1c Monads. Monads \u0111\u01b0\u1ee3c so\ns\xe1nh v\u1edbi burritos, v\xe0 t\u1ea5t c\u1ea3 c\xe1c lo\u1ea1i \u1ea9n d\u1ee5 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 c\u1ed1 g\u1eafng gi\u1ea3i\nth\xedch kh\xe1i ni\u1ec7m. Nh\u01b0ng \u1edf \u0111\xe2y, \xedt nh\u1ea5t ch\xfang ta h\xe3y c\u1ed1 g\u1eafng cung c\u1ea5p m\u1ed9t\nkh\xf3a h\u1ecdc c\u01a1 b\u1ea3n v\u1ec1 monads cho nh\u1eefng ng\u01b0\u1eddi m\u1edbi s\u1eed d\u1ee5ng Haskell."),(0,i.kt)("p",null,"Tr\u01b0\u1edbc khi \u0111\u1ebfn v\u1edbi c\xe1c \u0111\u01a1n nguy\xean chung, ch\xfang ta s\u1ebd b\u1eaft \u0111\u1ea7u v\u1edbi IO , \u0111\xf3\nl\xe0 c\xe1ch x\u1eed l\xfd c\xe1c t\xe1c d\u1ee5ng ph\u1ee5 c\u1ee7a IO trong Haskell. Tuy nhi\xean, tr\u01b0\u1edbc\nkhi \u0111\u1ebfn v\u1edbi Haskell, ch\xfang ta h\xe3y xem x\xe9t m\u1ed9t ng\xf4n ng\u1eef ch\xednh th\u1ed1ng nh\u01b0\nJava."),(0,i.kt)("p",null,"H\xe3y xem x\xe9t ph\u01b0\u01a1ng ph\xe1p Java sau \u0111\xe2y."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.java}"},"public static int foo() {\n   ...\n}\n")),(0,i.kt)("p",null,"H\xe0m n\xe0y kh\xf4ng c\xf3 \u0111\u1ed1i s\u1ed1 v\xe0 n\xf3 tr\u1ea3 v\u1ec1 ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". H\xe3y t\u01b0\u1edfng t\u01b0\u1ee3ng n\xf3 \u0111\u01b0\u1ee3c g\u1ecdi\nhai l\u1ea7n trong m\xe3."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.java}"},"...\nfinal int a = foo();\n...\nfinal int b = foo();\n")),(0,i.kt)("p",null,"B\xe2y gi\u1edd, ch\xfang ta l\u01b0u \xfd r\u1eb1ng, ch\u1eebng n\xe0o ch\xfang ta kh\xf4ng bi\u1ebft \u0111i\u1ec1u g\xec \u0111ang\nx\u1ea3y ra b\xean trong h\xe0m foo(), th\xec gi\xe1 tr\u1ecb tr\u1ea3 v\u1ec1 c\u1ee7a bi\u1ec3u th\u1ee9c sau l\xe0\nkh\xf4ng x\xe1c \u0111\u1ecbnh."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.java}"},"a == b; // true or false? at compile time, we don't know\n")),(0,i.kt)("p",null,"Ch\xfang t\xf4i kh\xf4ng bi\u1ebft c\xf3 ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," gi\u1ed1ng nh\u01b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," v\u1eady kh\xf4ng v\xec trong Java, ho\xe0n\nto\xe0n c\xf3 th\u1ec3 x\u1ea3y ra m\u1ed9t s\u1ed1 IO b\xean trong ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),". V\xed d\u1ee5: c\xf3 m\xe3 l\xe0 m\xe3 y\xeau c\u1ea7u\nng\u01b0\u1eddi d\xf9ng nh\u1eadp \u0111\u1ea7u v\xe0o tr\xean b\u1ea3ng \u0111i\u1ec1u khi\u1ec3n v\xe0 s\u1eed d\u1ee5ng m\xe3 n\xe0y \u0111\u1ec3 t\xednh\nto\xe1n gi\xe1 tr\u1ecb tr\u1ea3 v\u1ec1."),(0,i.kt)("p",null,"\u0110i\u1ec1u n\xe0y c\xf3 ngh\u0129a l\xe0, \u0111\u1ec3 l\u1eadp lu\u1eadn v\u1ec1 m\xe3, ch\xfang ta c\u1ea7n ph\u1ea3i nh\xecn v\xe0o b\xean\ntrong ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),", \u0111i\u1ec1u n\xe0y l\xe0m cho vi\u1ec7c th\u1eed nghi\u1ec7m tr\u1edf n\xean kh\xf3 kh\u0103n h\u01a1n. V\xe0\nn\xf3 c\xf3 ngh\u0129a l\xe0, ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," v\xed d\u1ee5 , \u0111\xf3 l\xe0 l\u1ec7nh g\u1ecdi tr\u1ea3 v\u1ec1 \u0111\u1ea7u ti\xean ",(0,i.kt)("inlineCode",{parentName:"p"},"13"),"- ch\xfang\nta kh\xf4ng th\u1ec3 thay th\u1ebf t\u1ea5t c\u1ea3 c\xe1c l\u1ec7nh g\u1ecdi kh\xe1c \u0111\u1ebfn ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," b\u1eb1ng gi\xe1 tr\u1ecb\ntr\u1ea3 v\u1ec1 \u0111\xe3 bi\u1ebft c\u1ee7a ",(0,i.kt)("inlineCode",{parentName:"p"},"13"),"."),(0,i.kt)("p",null,"\u1ede Haskell, t\xecnh h\xecnh r\u1ea5t kh\xe1c v\xec Haskell l\xe0 m\u1ed9t ng\xf4n ng\u1eef ch\u1ee9c n\u0103ng thu\u1ea7n\nt\xfay. Ch\u1eef k\xfd t\u01b0\u01a1ng \u0111\u01b0\u01a1ng trong Haskell s\u1ebd gi\u1ed1ng nh\u01b0 sau:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo :: Int\nfoo = ...\n")),(0,i.kt)("p",null,"B\xe2y gi\u1edd, n\u1ebfu ch\xfang ta g\u1eb7p tr\u01b0\u1eddng h\u1ee3p ch\xfang ta g\u1ecdi ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," hai l\u1ea7n, m\u1eb7c d\xf9\nch\xfang ta kh\xf4ng bi\u1ebft gi\xe1 tr\u1ecb c\u1ee7a ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," l\xe0 g\xec, ch\xfang ta bi\u1ebft ch\u1eafc r\u1eb1ng hai\ngi\xe1 tr\u1ecb tr\u1ea3 v\u1ec1 s\u1ebd gi\u1ed1ng nhau."),(0,i.kt)("p",null,"\u0110\xe2y l\xe0 m\u1ed9t t\xednh n\u0103ng r\u1ea5t quan tr\u1ecdng \u0111\u01b0\u1ee3c g\u1ecdi l\xe0 t\xednh minh b\u1ea1ch tham\nchi\u1ebfu . Tr\xean th\u1ef1c t\u1ebf, c\xf3 m\u1ed9t s\u1ed1 c\u1eeda tho\xe1t hi\u1ec3m \u0111\u1ec3 gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 n\xe0y,\nnh\u01b0ng ch\xfang ta c\xf3 th\u1ec3 b\u1ecf qua \u0111i\u1ec1u n\xe0y."),(0,i.kt)("p",null,"\u0110i\u1ec1u n\xe0y l\xe0m cho c\xe1c t\xe1c v\u1ee5 nh\u01b0 t\xe1i c\u1ea5u tr\xfac v\xe0 ki\u1ec3m tra d\u1ec5 d\xe0ng h\u01a1n\nnhi\u1ec1u."),(0,i.kt)("p",null,"\u0110i\u1ec1u n\xe0y l\xe0 r\u1ea5t t\u1ed1t, nh\u01b0ng b\u1ea1n c\u1ea7n c\xf3 t\xe1c d\u1ee5ng ph\u1ee5 \u0111\u1ec3 c\xf3 \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn\nth\u1ebf gi\u1edbi. N\u1ebfu kh\xf4ng, t\u1ea5t c\u1ea3 nh\u1eefng g\xec ch\u01b0\u01a1ng tr\xecnh c\u1ee7a b\u1ea1n l\xe0m l\xe0 l\xe0m\nn\xf3ng b\u1ed9 x\u1eed l\xfd."),(0,i.kt)("p",null,"B\u1ea1n c\u1ea7n \u0111\u1ea7u v\xe0o v\xe0 \u0111\u1ea7u ra. B\u1ea1n ph\u1ea3i c\xf3 kh\u1ea3 n\u0103ng ghi k\u1ebft qu\u1ea3 \u0111\u1ea7u ra ra\nm\xe0n h\xecnh, ho\u1eb7c \u0111\u1ecdc \u0111\u1ea7u v\xe0o t\u1eeb b\xe0n ph\xedm, k\u1ebft n\u1ed1i m\u1ea1ng ho\u1eb7c t\u1ec7p, ch\u1eb3ng\nh\u1ea1n."),(0,i.kt)("p",null,"C\xf3 m\u1ed9t ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=iSmkqocn0oQ"},"video n\u1ed5i ti\u1ebfng c\u1ee7a Simon Peyton-Jones l\xe0 Haskell Is\nUseless")," gi\u1ea3i th\xedch r\u1eb1ng\nng\xf4n ng\u1eef thu\u1ea7n t\xfay, kh\xf4ng c\xf3 t\xe1c d\u1ee5ng ph\u1ee5 th\xec r\u1ea5t \u0111\u1eb9p v\u1ec1 m\u1eb7t to\xe1n h\u1ecdc,\nnh\u01b0ng cu\u1ed1i c\xf9ng th\xec b\u1ea1n c\u0169ng c\u1ea7n c\xf3 t\xe1c d\u1ee5ng ph\u1ee5 \u0111\u1ec3 bi\u1ebfn b\u1ea5t c\u1ee9 \u0111i\u1ec1u g\xec\nx\u1ea3y ra."),(0,i.kt)("p",null,"V\xe0 Haskell c\xf3 m\u1ed9t c\xe1ch \u0111\u1ec3 x\u1eed l\xfd c\xe1c t\xe1c d\u1ee5ng ph\u1ee5 v\xe0 \u0111\xf3 l\xe0 \u0110\u01a1n nguy\xean IO.\nTuy nhi\xean, \u0111\u1eebng lo l\u1eafng v\u1ec1 ph\u1ea7n \u0111\u01a1n nguy\xean."),(0,i.kt)("p",null,"\u0110\xe2y l\xe0 c\xe1ch ch\xfang t\xf4i l\xe0m \u0111i\u1ec1u \u0111\xf3 trong Haskell."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo :: IO Int\nfoo = ...\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"IO")," l\xe0 m\u1ed9t ph\u01b0\u01a1ng th\u1ee9c kh\u1edfi t\u1ea1o ki\u1ec3u nh\u1eadn m\u1ed9t \u0111\u1ed1i s\u1ed1, gi\u1ed1ng nh\u01b0 m\u1ed9t s\u1ed1\nv\xed d\u1ee5 kh\xe1c v\u1ec1 c\xe1c h\xe0m t\u1ea1o ki\u1ec3u nh\u01b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," . Tuy nhi\xean, kh\xf4ng\ngi\u1ed1ng nh\u01b0 nh\u1eefng v\xed d\u1ee5 \u0111\xf3, ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," \u0111\u1eb7c bi\u1ec7t, theo ngh\u0129a l\xe0 b\u1ea1n kh\xf4ng th\u1ec3\ntri\u1ec3n khai n\xf3 b\u1eb1ng ch\xednh ng\xf4n ng\u1eef. N\xf3 l\xe0 m\u1ed9t nguy\xean th\u1ee7y \u0111\u01b0\u1ee3c t\xedch h\u1ee3p\ns\u1eb5n."),(0,i.kt)("p",null,"Gi\xe1 tr\u1ecb tr\u1ea3 v\u1ec1 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO Int")," cho ch\xfang ta bi\u1ebft r\u1eb1ng \u0111\xe2y l\xe0 m\u1ed9t c\xf4ng th\u1ee9c \u0111\u1ec3\nt\xednh Int v\xe0 c\xf4ng th\u1ee9c n\xe0y c\xf3 th\u1ec3 g\xe2y ra c\xe1c ph\u1ea3n \u1ee9ng ph\u1ee5. M\u1ed9t danh s\xe1ch\nc\xe1c h\u01b0\u1edbng d\u1eabn cho m\xe1y t\xednh bi\u1ebft ph\u1ea3i l\xe0m g\xec \u0111\u1ec3 k\u1ebft th\xfac v\u1edbi m\u1ed9t ",(0,i.kt)("inlineCode",{parentName:"p"},"Int")," ."),(0,i.kt)("p",null,"\u0110i\u1ec1u quan tr\u1ecdng c\u1ea7n l\u01b0u \xfd l\xe0 t\xednh minh b\u1ea1ch c\u1ee7a tham chi\u1ebfu kh\xf4ng b\u1ecb ph\xe1\nv\u1ee1 \u1edf \u0111\xe2y. K\u1ebft qu\u1ea3 \u0111\xe1nh gi\xe1 foo l\xe0 ch\xednh c\xf4ng th\u1ee9c, kh\xf4ng ph\u1ea3i gi\xe1 tr\u1ecb\n",(0,i.kt)("inlineCode",{parentName:"p"},"Int")," . V\xe0 v\xec c\xf4ng th\u1ee9c lu\xf4n gi\u1ed1ng nhau, n\xean t\xednh minh b\u1ea1ch c\u1ee7a tham\nchi\u1ebfu \u0111\u01b0\u1ee3c duy tr\xec."),(0,i.kt)("p",null,"C\xe1ch duy nh\u1ea5t \u0111\u1ec3 th\u1ef1c s\u1ef1 th\u1ef1c hi\u1ec7n m\u1ed9t c\xf4ng th\u1ee9c nh\u01b0 v\u1eady trong ch\u01b0\u01a1ng\ntr\xecnh Haskell l\xe0 t\u1eeb \u0111i\u1ec3m nh\u1eadp ch\xednh c\u1ee7a ch\u01b0\u01a1ng tr\xecnh - h\xe0m ch\xednh . B\u1ea1n\nc\u0169ng c\xf3 th\u1ec3 th\u1ef1c hi\u1ec7n c\xe1c h\xe0nh \u0111\u1ed9ng IO trong REPL."),(0,i.kt)("h3",{id:"hello-world"},"Hello World"),(0,i.kt)("p",null,"Hello World in Haskell tr\xf4ng nh\u01b0 th\u1ebf n\xe0y:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'main :: IO ()\nmain = putStrLn "Hello, world!"\n')),(0,i.kt)("p",null,"\u1ede \u0111\xe2y, ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," l\xe0 m\u1ed9t c\xf4ng th\u1ee9c th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 t\xe1c d\u1ee5ng ph\u1ee5 v\xe0 tr\u1ea3 v\u1ec1\n\u0110\u01a1n v\u1ecb - kh\xf4ng c\xf3 g\xec \u0111\xe1ng quan t\xe2m."),(0,i.kt)("p",null,"H\xe3y xem ",(0,i.kt)("inlineCode",{parentName:"p"},"putStrLn")," trong REPL. Ch\xfang t\xf4i th\u1ea5y r\u1eb1ng \u0111\xf3 l\xe0 m\u1ed9t h\xe0nh \u0111\u1ed9ng\nIO s\u1eed d\u1ee5ng ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," v\xe0 kh\xf4ng tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 th\xfa v\u1ecb n\xe0o."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> :t putStrLn\nputStrLn :: String -> IO ()\n\nPrelude Week04.Contract> :t putStrLn "Hello, world!"\nputStrLn "Hello, world!" :: IO ()\n')),(0,i.kt)("p",null,"Ch\xfang t\xf4i c\u0169ng c\xf3 th\u1ec3 ch\u1ea1y \u0111i\u1ec1u n\xe0y. M\u1edf \u1ee9ng d\u1ee5ng / t\u1ec7p Main.sh v\xe0 ch\u1ec9nh\ns\u1eeda ch\u1ee9c n\u0103ng ch\xednh \u0111\u1ec3 n\xf3 \u0111\u1ecdc:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'main :: IO ()\nmain = putStrLn "Hello, world!"\n')),(0,i.kt)("p",null,"Sau \u0111\xf3 ch\u1ea1y"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.bash}"},"cabal run hello\n")),(0,i.kt)("p",null,"Ch\xfang ta s\u1ebd xem x\xe9t nhanh t\u1ec7p cabal ngay b\xe2y gi\u1edd."),(0,i.kt)("p",null,"Trong c\xe1c b\xe0i gi\u1ea3ng tr\u01b0\u1edbc, ch\xfang ta ch\u1ec9 c\u1ea7n ph\u1ea7n th\u01b0 vi\u1ec7n ",(0,i.kt)("inlineCode",{parentName:"p"},"library"),"\ntrong t\u1ec7p ",(0,i.kt)("inlineCode",{parentName:"p"},"plutus-pioneer-program-week04.cabal")," v\xec ch\xfang ta ch\u1ec9 x\u1eed l\xfd\nc\xe1c h\xe0m th\u01b0 vi\u1ec7n. B\xe2y gi\u1edd, ch\xfang ta c\u1ea7n th\xeam m\u1ed9t kh\u1ed5 th\u01a1 c\xf3 th\u1ec3 th\u1ef1c thi\n\u0111\u01b0\u1ee3c ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.cabal}"},"executable hello\nhs-source-dirs:      app\nmain-is:             hello.hs\nbuild-depends:       base ^>=4.14.1.0\ndefault-language:    Haskell2010\nghc-options:         -Wall -O2\n")),(0,i.kt)("p",null,"\u0110i\u1ec1u n\xe0y ch\u1ec9 \u0111\u1ecbnh th\u01b0 m\u1ee5c ngu\u1ed3n v\xe0 t\u1ec7p n\xe0o gi\u1eef ch\u1ee9c n\u0103ng ch\xednh. Th\xf4ng\nth\u01b0\u1eddng t\xean t\u1ec7p ph\u1ea3i kh\u1edbp v\u1edbi t\xean m\xf4-\u0111un, nh\u01b0ng ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," l\xe0 m\u1ed9t ngo\u1ea1i l\u1ec7."),(0,i.kt)("p",null,"Thay v\xec ch\u1ec9 y\xeau c\u1ea7u lo\u1ea1i ",(0,i.kt)("inlineCode",{parentName:"p"},"putStrLn")," , ch\xfang ta c\xf3 th\u1ec3 ch\u1ea1y n\xf3 trong\nREPL. Nh\u01b0 \u0111\xe3 \u0111\u1ec1 c\u1eadp, REPL cho ph\xe9p ch\xfang ta th\u1ef1c hi\u1ec7n c\xe1c h\xe0nh \u0111\u1ed9ng IO."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> putStrLn "Hello, world!"\nHello, world!\n')),(0,i.kt)("h3",{id:"getline"},"getLine"),(0,i.kt)("p",null,"H\xe3y xem ",(0,i.kt)("inlineCode",{parentName:"p"},"getLine")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :t getLine\ngetLine :: IO String\n")),(0,i.kt)("p",null,"\u0110i\u1ec1u n\xe0y cho th\u1ea5y r\u1eb1ng \u0111\xf3 l\xe0 m\u1ed9t c\xf4ng th\u1ee9c, c\xf3 th\u1ec3 t\u1ea1o ra c\xe1c hi\u1ec7u \u1ee9ng\nph\u1ee5, khi \u0111\u01b0\u1ee3c th\u1ef1c thi s\u1ebd t\u1ea1o ra m\u1ed9t Chu\u1ed7i . Trong tr\u01b0\u1eddng h\u1ee3p getLine ,\nt\xe1c d\u1ee5ng ph\u1ee5 \u0111\u01b0\u1ee3c \u0111\u1ec1 c\u1eadp l\xe0 n\xf3 s\u1ebd \u0111\u1ee3i ng\u01b0\u1eddi d\xf9ng nh\u1eadp t\u1eeb b\xe0n ph\xedm."),(0,i.kt)("p",null,"N\u1ebfu ch\xfang ta th\u1ef1c thi getLine trong REPL."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> getLine\n")),(0,i.kt)("p",null,"N\xf3 ch\u1edd nh\u1eadp b\xe0n ph\xedm. Sau \u0111\xf3, n\u1ebfu ch\xfang ta nh\u1eadp m\u1ed9t c\xe1i g\xec \u0111\xf3, n\xf3 s\u1ebd tr\u1ea3\nv\u1ec1 k\u1ebft qu\u1ea3."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Haskell\n"Haskell"\n')),(0,i.kt)("p",null,"C\xf3 m\u1ed9t lo\u1ea1t c\xe1c h\xe0nh \u0111\u1ed9ng IO \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong Haskell \u0111\u1ec3 th\u1ef1c hi\u1ec7n\nt\u1ea5t c\u1ea3 c\xe1c lo\u1ea1i nh\u01b0 \u0111\u1ecdc t\u1ec7p, ghi t\u1ec7p, \u0111\u1ecdc t\u1eeb v\xe0 ghi v\xe0o \u1ed5 c\u1eafm."),(0,i.kt)("p",null,"Nh\u01b0ng cho d\xf9 b\u1ea1n c\xf3 bao nhi\xeau h\xe0nh \u0111\u1ed9ng \u0111\u01b0\u1ee3c x\xe1c \u0111\u1ecbnh tr\u01b0\u1edbc, \u0111i\u1ec1u \u0111\xf3 s\u1ebd\nkh\xf4ng bao gi\u1edd l\xe0 \u0111\u1ee7 \u0111\u1ec3 \u0111\u1ea1t \u0111\u01b0\u1ee3c \u0111i\u1ec1u g\xec \u0111\xf3 ph\u1ee9c t\u1ea1p, v\xec v\u1eady c\u1ea7n ph\u1ea3i c\xf3\nc\xe1ch \u0111\u1ec3 k\u1ebft h\u1ee3p c\xe1c h\xe0nh \u0111\u1ed9ng IO nguy\xean th\u1ee7y n\xe0y th\xe0nh nh\u1eefng c\xf4ng th\u1ee9c\nl\u1edbn h\u01a1n, ph\u1ee9c t\u1ea1p h\u01a1n."),(0,i.kt)("p",null,"M\u1ed9t \u0111i\u1ec1u ch\xfang ta c\xf3 th\u1ec3 l\xe0m l\xe0 s\u1eed d\u1ee5ng phi\xean b\u1ea3n ki\u1ec3u ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," c\u1ee7a IO.\nH\xe3y xem x\xe9t c\xe1c tr\u01b0\u1eddng h\u1ee3p lo\u1ea1i c\u1ee7a ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," trong REPL."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i IO\ntype IO :: ` -> `\nnewtype IO a\n= ghc-prim-0.6.1:GHC.Types.IO (ghc-prim-0.6.1:GHC.Prim.State#\n                                 ghc-prim-0.6.1:GHC.Prim.RealWorld\n                                 -> (# ghc-prim-0.6.1:GHC.Prim.State#\n                                       ghc-prim-0.6.1:GHC.Prim.RealWorld,\n                                       a #))\n   -- Defined in \u2018ghc-prim-0.6.1:GHC.Types\u2019\ninstance Applicative IO -- Defined in \u2018GHC.Base\u2019\ninstance Functor IO -- Defined in \u2018GHC.Base\u2019\ninstance Monad IO -- Defined in \u2018GHC.Base\u2019\ninstance Monoid a => Monoid (IO a) -- Defined in \u2018GHC.Base\u2019\ninstance Semigroup a => Semigroup (IO a) -- Defined in \u2018GHC.Base\u2019\ninstance MonadFail IO -- Defined in \u2018Control.Monad.Fail\u2019\n")),(0,i.kt)("p",null,"Ch\xfang ta th\u1ea5y c\xe1 th\u1ec3 ",(0,i.kt)("inlineCode",{parentName:"p"},"Monad")," \u0111\xe1ng s\u1ee3 , nh\u01b0ng ch\xfang ta c\u0169ng th\u1ea5y m\u1ed9t c\xe1\nth\u1ec3 ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," l\xe0 m\u1ed9t lo\u1ea1i l\u1edbp r\u1ea5t quan tr\u1ecdng trong Haskell.\nN\u1ebfu ch\xfang ta nh\xecn v\xe0o n\xf3 trong REPL:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Functor\ntype Functor :: (` -> `) -> Constraint\nclass Functor f where\nfmap :: (a -> b) -> f a -> f b\n(<$) :: a -> f b -> f a\n{-# MINIMAL fmap #-}\n   -- Defined in \u2018GHC.Base\u2019\ninstance Functor (Either a) -- Defined in \u2018Data.Either\u2019\ninstance Functor [] -- Defined in \u2018GHC.Base\u2019\ninstance Functor Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Functor IO -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((->) r) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,,,) a b c) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,,) a b) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,) a) -- Defined in \u2018GHC.Base\u2019\n")),(0,i.kt)("p",null,"Ph\u01b0\u01a1ng ph\xe1p quan tr\u1ecdng \u1edf \u0111\xe2y l\xe0 fmap . H\xe0m th\u1ee9 hai (\\<\\$) l\xe0 m\u1ed9t h\xe0m\nti\u1ec7n l\u1ee3i."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"fmap :: (a -> b) -> f a -> f b\n")),(0,i.kt)("p",null,"H\xe0m n\xe0y ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," , m\xe0 t\u1ea5t c\u1ea3 ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),"s c\xf3 cho ch\xfang ta bi\u1ebft r\u1eb1ng, n\u1ebfu\nch\xfang ta c\u1ea5p cho n\xf3 quy\u1ec1n truy c\u1eadp v\xe0o m\u1ed9t h\xe0m c\xf3 th\u1ec3 bi\u1ebfn ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," th\xe0ng ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),"\n, th\xec n\xf3 c\xf3 th\u1ec3 bi\u1ebfn fa th\xe0nh fb cho ch\xfang ta. \u1ede \u0111\xe2y, ch\xfang ta quan t\xe2m\n\u0111\u1ebfn tr\u01b0\u1eddng h\u1ee3p f l\xe0 IO ."),(0,i.kt)("p",null,"N\u1ebfu ch\xfang ta chuy\xean bi\u1ec7t h\xf3a h\xe0m cho ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," , ch\xfang ta s\u1ebd c\xf3 m\u1ed9t h\xe0m nh\u01b0:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"fmap' :: (a -> b) -> IO a -> IO b\n")),(0,i.kt)("p",null,"L\xe0m th\u1ebf n\xe0o \u0111\u1ec3 l\xe0m vi\u1ec7c \u0111\xf3. \xc0, ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," l\xe0 m\u1ed9t c\xf4ng th\u1ee9c c\xf3 t\xe1c d\u1ee5ng ph\u1ee5\nv\xe0 t\u1ea1o ra ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," . V\xec v\u1eady, l\xe0m th\u1ebf n\xe0o \u0111\u1ec3 ch\xfang ta c\xf3 \u0111\u01b0\u1ee3c m\u1ed9t ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," trong s\u1ed1\n\u0111\xf3? Ch\xfang t\xf4i th\u1ef1c hi\u1ec7n c\xf4ng th\u1ee9c, nh\u01b0ng, tr\u01b0\u1edbc khi tr\u1ea3 v\u1ec1 a , ch\xfang t\xf4i\n\xe1p d\u1ee5ng h\xe0m ",(0,i.kt)("inlineCode",{parentName:"p"},"(a -\\> b)")," cho ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," v\xe0 tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 l\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," ."),(0,i.kt)("p",null,"Trong REPL, ch\xfang ta h\xe3y xem x\xe9t h\xe0m ",(0,i.kt)("inlineCode",{parentName:"p"},"toUpper")," ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> import Data.Char\nPrelude Data.Char Week04.Contract> :t toUpper\ntoUpper :: Char -> Char\nPrelude Data.Char Week04.Contract> toUpper 'q'\n'Q'\n")),(0,i.kt)("p",null,"N\u1ebfu ch\xfang ta mu\u1ed1n \xe1p d\u1ee5ng \u0111\u01b0\u1ee3c cho m\u1ed9t chu\u1ed7i ch\u1ee9 kh\xf4ng ph\u1ea3i l\xe0 m\u1ed9t Char\nch\xfang ta c\xf3 th\u1ec3 s\u1eed d\u1ee5ng b\u1ea3n \u0111\u1ed3 ch\u1ee9c n\u0103ng. C\xe1c chu\u1ed7i ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"s trong\nHaskell ch\u1ec9 l\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Char"),"s ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Data.Char Week04.Contract> map toUpper "Haskell"\n"HASKELL"\n')),(0,i.kt)("p",null,"H\xe0m ",(0,i.kt)("inlineCode",{parentName:"p"},"map toUpper")," l\xe0 m\u1ed9t h\xe0m chuy\u1ec3n t\u1eeb ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Data.Char Week04.Contract> :t map toUpper\nmap toUpper :: [Char] -> [Char]\n")),(0,i.kt)("p",null,"V\xe0 ch\xfang ta c\xf3 th\u1ec3 s\u1eed d\u1ee5ng k\u1ebft h\u1ee3p v\u1edbi ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),". N\u1ebfu ch\xfang ta s\u1eed d\u1ee5ng ",(0,i.kt)("inlineCode",{parentName:"p"},"map\ntoUpper")," l\xe0m ch\u1ee9c n\u0103ng chuy\u1ec3n \u0111\u1ed5i ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," th\xe0nh ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," , ch\xfang ta c\xf3 th\u1ec3 th\u1ea5y\nlo\u1ea1i \u0111\u1ea7u ra c\u1ee7a fmap s\u1ebd nh\u01b0 th\u1ebf n\xe0o khi \xe1p d\u1ee5ng cho ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Data.Char Week04.Contract> :t fmap (map toUpper) getLine\nfmap (map toUpper) getLine :: IO [Char]\n")),(0,i.kt)("p",null,"H\xe3y xem n\xf3 trong h\xe0nh \u0111\u1ed9ng."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Data.Char Week04.Contract> fmap (map toUpper) getLine\nhaskell\n"HASKELL"\n')),(0,i.kt)("p",null,"Ch\xfang ta c\u0169ng c\xf3 th\u1ec3 s\u1eed d\u1ee5ng to\xe1n t\u1eed ",(0,i.kt)("inlineCode",{parentName:"p"},"\\>\\>")," . \u0110i\u1ec1u n\xe0y chu\u1ed7i hai h\xe0nh\n\u0111\u1ed9ng ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," l\u1ea1i v\u1edbi nhau, b\u1ecf qua k\u1ebft qu\u1ea3 c\u1ee7a h\xe0nh \u0111\u1ed9ng \u0111\u1ea7u ti\xean. Trong v\xed\nd\u1ee5 sau, c\u1ea3 hai h\xe0nh \u0111\u1ed9ng s\u1ebd \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n theo tr\xecnh t\u1ef1."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> putStrLn "Hello" >> putStrLn "World"\nHello\nWorld\n')),(0,i.kt)("p",null,"\u1ede \u0111\xe2y, kh\xf4ng c\xf3 k\u1ebft qu\u1ea3 t\u1eeb ",(0,i.kt)("inlineCode",{parentName:"p"},"putStrLn")," , nh\u01b0ng n\u1ebfu c\xf3, n\xf3 s\u1ebd b\u1ecb b\u1ecf qua. C\xe1c t\xe1c d\u1ee5ng kh\xf4ng mong mu\u1ed1n c\u1ee7a n\xf3 s\u1ebd \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n, k\u1ebft qu\u1ea3 c\u1ee7a n\xf3 b\u1ecb b\u1ecf qua, sau \u0111\xf3 c\xe1c t\xe1c d\u1ee5ng kh\xf4ng mong mu\u1ed1n th\u1ee9 hai c\u1ee7a ",(0,i.kt)("inlineCode",{parentName:"p"},"putStrLn")," s\u1ebd \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n tr\u01b0\u1edbc khi tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 c\u1ee7a l\u1ea7n g\u1ecdi th\u1ee9 hai."),(0,i.kt)("p",null,"Sau \u0111\xf3, c\xf3 m\u1ed9t to\xe1n t\u1eed quan tr\u1ecdng kh\xf4ng b\u1ecf qua k\u1ebft qu\u1ea3 c\u1ee7a h\xe0nh \u0111\u1ed9ng IO \u0111\u1ea7u ti\xean , v\xe0 \u0111\xf3 \u0111\u01b0\u1ee3c g\u1ecdi l\xe0 r\xe0ng bu\u1ed9c . N\xf3 \u0111\u01b0\u1ee3c vi\u1ebft d\u01b0\u1edbi d\u1ea1ng k\xfd hi\u1ec7u ",(0,i.kt)("inlineCode",{parentName:"p"},"\\>\\>=")," ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :t (>>=)\n(>>=) :: Monad m => m a -> (a -> m b) -> m b\n")),(0,i.kt)("p",null,"Ch\xfang t\xf4i th\u1ea5y r\xe0ng bu\u1ed9c ",(0,i.kt)("inlineCode",{parentName:"p"},"Monad")," , nh\u01b0ng ch\xfang t\xf4i c\xf3 th\u1ec3 b\u1ecf qua \u0111i\u1ec1u \u0111\xf3 ngay b\xe2y gi\u1edd v\xe0 ch\u1ec9 ngh\u0129 v\u1ec1 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," ."),(0,i.kt)("p",null,"\u0110i\u1ec1u n\xe0y n\xf3i l\xean r\u1eb1ng n\u1ebfu t\xf4i c\xf3 m\u1ed9t c\xf4ng th\u1ee9c th\u1ef1c hi\u1ec7n c\xe1c t\xe1c d\u1ee5ng ph\u1ee5 sau \u0111\xf3 cho t\xf4i k\u1ebft qu\u1ea3 ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," , v\xe0 cho r\u1eb1ng t\xf4i c\xf3 m\u1ed9t h\xe0m nh\u1eadn ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," v\xe0 tr\u1ea3 l\u1ea1i cho t\xf4i m\u1ed9t c\xf4ng th\u1ee9c tr\u1ea3 v\u1ec1 ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," , th\xec t\xf4i c\xf3 th\u1ec3 k\u1ebft h\u1ee3p c\xf4ng th\u1ee9c ",(0,i.kt)("inlineCode",{parentName:"p"},"m a"),". v\u1edbi c\xf4ng th\u1ee9c mb b\u1eb1ng c\xe1ch l\u1ea5y gi\xe1 tr\u1ecb a v\xe0 s\u1eed d\u1ee5ng n\xf3 trong c\xf4ng th\u1ee9c thu \u0111\u01b0\u1ee3c gi\xe1 tr\u1ecb ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," ."),(0,i.kt)("p",null,"M\u1ed9t v\xed d\u1ee5 s\u1ebd l\xe0m r\xf5 \u0111i\u1ec1u n\xe0y."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> getLine >>= putStrLn\nHaskell\nHaskell\n")),(0,i.kt)("p",null,"\u1ede \u0111\xe2y, h\xe0m ",(0,i.kt)("inlineCode",{parentName:"p"},"getLine"),"  c\xf3 ki\u1ec3u ",(0,i.kt)("inlineCode",{parentName:"p"},"IO String")," . Gi\xe1 tr\u1ecb tr\u1ea3 v\u1ec1 ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," \u0111\u01b0\u1ee3c chuy\u1ec3n cho h\xe0m ",(0,i.kt)("inlineCode",{parentName:"p"},"(a -\\> m b)")," , sau \u0111\xf3 t\u1ea1o ra m\u1ed9t c\xf4ng th\u1ee9c ",(0,i.kt)("inlineCode",{parentName:"p"},"putStrLn")," v\u1edbi gi\xe1 tr\u1ecb \u0111\u1ea7u v\xe0o l\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," v\xe0 \u0111\u1ea7u ra l\xe0 ki\u1ec3u ",(0,i.kt)("inlineCode",{parentName:"p"},"IO ()")," . Sau \u0111\xf3, ",(0,i.kt)("inlineCode",{parentName:"p"},"putStrLn")," th\u1ef1c hi\u1ec7n c\xe1c t\xe1c d\u1ee5ng ph\u1ee5 c\u1ee7a n\xf3 v\xe0 tr\u1ea3 v\u1ec1 ",(0,i.kt)("inlineCode",{parentName:"p"},"Unit")," ."),(0,i.kt)("p",null,"C\xf3 m\u1ed9t c\xe1ch kh\xe1c, r\u1ea5t quan tr\u1ecdng, \u0111\u1ec3 t\u1ea1o c\xe1c h\xe0nh \u0111\u1ed9ng ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," , v\xe0 \u0111\xf3 l\xe0 t\u1ea1o c\xe1c c\xf4ng th\u1ee9c n\u1ea5u \u0103n ngay l\u1eadp t\u1ee9c tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 m\xe0 kh\xf4ng th\u1ef1c hi\u1ec7n b\u1ea5t k\u1ef3 t\xe1c d\u1ee5ng ph\u1ee5 n\xe0o."),(0,i.kt)("p",null,"\u0110i\u1ec1u \u0111\xf3 \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n v\u1edbi m\u1ed9t ch\u1ee9c n\u0103ng \u0111\u01b0\u1ee3c g\u1ecdi l\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :t return\nreturn :: Monad m => a -> m a\n")),(0,i.kt)("p",null,"M\u1ed9t l\u1ea7n n\u1eefa, n\xf3 l\xe0 chung cho b\u1ea5t k\u1ef3 \u0110\u01a1n nguy\xean (Monad) n\xe0o, ch\xfang ta ch\u1ec9 c\u1ea7n ngh\u0129 v\u1ec1 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," ngay b\xe2y gi\u1edd."),(0,i.kt)("p",null,"N\xf3 nh\u1eadn m\u1ed9t gi\xe1 tr\u1ecb ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," v\xe0 tr\u1ea3 v\u1ec1 m\u1ed9t c\xf4ng th\u1ee9c t\u1ea1o ra gi\xe1 tr\u1ecb ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," . Trong tr\u01b0\u1eddng h\u1ee3p tr\u1ea3 l\u1ea1i , c\xf4ng th\u1ee9c th\u1ef1c s\u1ef1 kh\xf4ng t\u1ea1o ra b\u1ea5t k\u1ef3 t\xe1c d\u1ee5ng ph\u1ee5 n\xe0o."),(0,i.kt)("p",null,"V\xed d\u1ee5:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> return "Haskell" :: IO String\n"Haskell"\n')),(0,i.kt)("p",null,"Ch\xfang t\xf4i c\u1ea7n ch\u1ec9 \u0111\u1ecbnh ki\u1ec3u tr\u1ea3 v\u1ec1 \u0111\u1ec3 REPL bi\u1ebft ch\xfang t\xf4i \u0111ang s\u1eed d\u1ee5ng ",(0,i.kt)("inlineCode",{parentName:"p"},"Monad")," n\xe0o: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> :t return "Haskell" :: IO String\nreturn "Haskell" :: IO String :: IO String\n\nPrelude Week04.Contract> :t return "Haskell"\nreturn "Haskell" :: Monad m => m [Char]\n')),(0,i.kt)("p",null,"N\u1ebfu b\xe2y gi\u1edd ch\xfang ta quay l\u1ea1i ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," c\u1ee7a m\xecnh, b\xe2y gi\u1edd ch\xfang ta c\xf3 th\u1ec3 vi\u1ebft c\xe1c h\xe0nh \u0111\u1ed9ng ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),"  t\u01b0\u01a1ng \u0111\u1ed1i ph\u1ee9c t\u1ea1p . V\xed d\u1ee5, ch\xfang ta c\xf3 th\u1ec3 x\xe1c \u0111\u1ecbnh m\u1ed9t h\xe0nh \u0111\u1ed9ng ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),"  s\u1ebd y\xeau c\u1ea7u hai chu\u1ed7i v\xe0 in k\u1ebft qu\u1ea3 c\u1ee7a vi\u1ec7c n\u1ed1i hai chu\u1ed7i \u0111\xf3 v\u1edbi b\u1ea3ng \u0111i\u1ec1u khi\u1ec3n."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"main :: IO ()\nmain = bar\n\nbar :: IO ()\nbar = getLine >>= \\s ->\n      getLine >>= \\t ->\n      putStrLn (s ++ t)\n")),(0,i.kt)("p",null,"V\xe0 sau \u0111\xf3, khi ch\xfang t\xf4i ch\u1ea1y n\xf3, ch\u01b0\u01a1ng tr\xecnh s\u1ebd \u0111\u1ee3i hai \u0111\u1ea7u v\xe0o v\xe0 sau \u0111\xf3 xu\u1ea5t ra k\u1ebft qu\u1ea3 \u0111\u01b0\u1ee3c n\u1ed1i."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.bash}"},"cabal run hello\none\ntwo\nonetwo\n")),(0,i.kt)("p",null,"B\xe2y gi\u1edd \u0111i\u1ec1u n\xe0y l\xe0 \u0111\u1ee7 cho c\xe1c m\u1ee5c \u0111\xedch c\u1ee7a ch\xfang t\xf4i, m\u1eb7c d\xf9 ch\xfang t\xf4i s\u1ebd kh\xf4ng c\u1ea7n \u0110\u01a1n nguy\xean ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," cho \u0111\u1ebfn khi c\xf3 l\u1ebd sau n\xe0y trong kh\xf3a h\u1ecdc khi ch\xfang t\xf4i n\xf3i v\u1ec1 vi\u1ec7c th\u1ef1c s\u1ef1 tri\u1ec3n khai c\xe1c h\u1ee3p \u0111\u1ed3ng Plutus. Tuy nhi\xean, ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," Monad l\xe0 m\u1ed9t v\xed d\u1ee5 quan tr\u1ecdng v\xe0 l\xe0 m\u1ed9t v\xed d\u1ee5 t\u1ed1t \u0111\u1ec3 b\u1eaft \u0111\u1ea7u."),(0,i.kt)("p",null,"V\xec v\u1eady, hi\u1ec7n t\u1ea1i, ch\xfang ta h\xe3y ho\xe0n to\xe0n qu\xean ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," v\xe0 ch\u1ec9 vi\u1ebft Haskell thu\u1ea7n t\xfay, c\xf3 ch\u1ee9c n\u0103ng, s\u1eed d\u1ee5ng ki\u1ec3u ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," ."),(0,i.kt)("h3",{id:"maybe"},"Maybe"),(0,i.kt)("p",null,"Ki\u1ec3u ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),"  l\xe0 m\u1ed9t trong nh\u1eefng lo\u1ea1i h\u1eefu \xedch nh\u1ea5t trong Haskell."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Maybe\ntype Maybe :: ` -> `\ndata Maybe a = Nothing | Just a\n   -- Defined in \u2018GHC.Maybe\u2019\ninstance Applicative Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Eq a => Eq (Maybe a) -- Defined in \u2018GHC.Maybe\u2019\ninstance Functor Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Monad Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Semigroup a => Monoid (Maybe a) -- Defined in \u2018GHC.Base\u2019\ninstance Ord a => Ord (Maybe a) -- Defined in \u2018GHC.Maybe\u2019\ninstance Semigroup a => Semigroup (Maybe a)\n-- Defined in \u2018GHC.Base\u2019\ninstance Show a => Show (Maybe a) -- Defined in \u2018GHC.Show\u2019\ninstance Read a => Read (Maybe a) -- Defined in \u2018GHC.Read\u2019\ninstance Foldable Maybe -- Defined in \u2018Data.Foldable\u2019\ninstance Traversable Maybe -- Defined in \u2018Data.Traversable\u2019\ninstance MonadFail Maybe -- Defined in \u2018Control.Monad.Fail\u2019\n")),(0,i.kt)("p",null,"N\xf3 th\u01b0\u1eddng \u0111\u01b0\u1ee3c g\u1ecdi l\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional")," trong c\xe1c ng\xf4n ng\u1eef l\u1eadp tr\xecnh kh\xe1c."),(0,i.kt)("p",null,"N\xf3 c\xf3 hai h\xe0m t\u1ea1o - ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing")," , kh\xf4ng nh\u1eadn \u0111\u1ed1i s\u1ed1 v\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Just")," - c\xf3 m\u1ed9t \u0111\u1ed1i s\u1ed1."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data Maybe a = Nothing | Just a\n")),(0,i.kt)("p",null,"H\xe3y xem m\u1ed9t v\xed d\u1ee5."),(0,i.kt)("p",null,"Trong Haskell, n\u1ebfu b\u1ea1n mu\u1ed1n truy\u1ec1n ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," \u0111\u1ebfn m\u1ed9t gi\xe1 tr\u1ecb c\xf3 th\u1ec3 hi\u1ec7n ",(0,i.kt)("inlineCode",{parentName:"p"},"read")," , b\u1ea1n s\u1ebd th\u01b0\u1eddng l\xe0m \u0111i\u1ec1u n\xe0y v\u1edbi h\xe0m ",(0,i.kt)("inlineCode",{parentName:"p"},"read")," ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Week04.Maybe> read "42" :: Int\n42\n')),(0,i.kt)("p",null,"Tuy nhi\xean, ",(0,i.kt)("inlineCode",{parentName:"p"},"read")," h\u01a1i kh\xf3 ch\u1ecbu, b\u1edfi v\xec n\u1ebfu ch\xfang ta c\xf3 th\u1ee9 g\xec \u0111\xf3 kh\xf4ng th\u1ec3 ph\xe2n t\xedch c\xfa ph\xe1p th\xe0nh ",(0,i.kt)("inlineCode",{parentName:"p"},"Int")," , th\xec ch\xfang ta s\u1ebd g\u1eb7p l\u1ed7i."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Week04.Maybe> read "42+u" :: Int\n*** Exception: Prelude.read: no parse\n')),(0,i.kt)("p",null,"H\xe3y import ",(0,i.kt)("inlineCode",{parentName:"p"},"readMaybe")," \u0111\u1ec3 l\xe0m \u0111i\u1ec1u \u0111\xf3 theo c\xe1ch t\u1ed1t h\u01a1n."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Maybe> import Text.Read (readMaybe)\nPrelude Text.Read Week04.Contract>\n")),(0,i.kt)("p",null,"H\xe0m ",(0,i.kt)("inlineCode",{parentName:"p"},"readMaybe")," l\xe0m t\u01b0\u01a1ng t\u1ef1 nh\u01b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"read"),", nh\u01b0ng n\xf3 tr\u1ea3 v\u1ec1 m\u1ed9t ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," v\xe0 trong tr\u01b0\u1eddng h\u1ee3p n\xf3 kh\xf4ng th\u1ec3 ph\xe2n t\xedch c\xfa ph\xe1p, n\xf3 s\u1ebd tr\u1ea3 v\u1ec1 m\u1ed9t ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," \u0111\u01b0\u1ee3c t\u1ea1o b\u1eb1ng ph\u01b0\u01a1ng th\u1ee9c kh\u1edfi t\u1ea1o ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing")," ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Text.Read Week04.Contract> readMaybe "42" :: Maybe Int\nJust 42\n\nPrelude Text.Read Week04.Contract> readMaybe "42+u" :: Maybe Int\nNothing\n')),(0,i.kt)("p",null,"Gi\u1ea3 s\u1eed ch\xfang ta mu\u1ed1n t\u1ea1o m\u1ed9t h\xe0m m\u1edbi tr\u1ea3 v\u1ec1 a ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"foo :: String -> String -> String -> Maybe Int\n")),(0,i.kt)("p",null,"\xdd t\u01b0\u1edfng l\xe0 h\xe0m n\xean c\u1ed1 g\u1eafng ph\xe2n t\xedch c\xfa ph\xe1p c\u1ea3 ba ",(0,i.kt)("inlineCode",{parentName:"p"},"Strings")," l\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Ints"),". N\u1ebfu t\u1ea5t c\u1ea3 c\xe1c Strings c\xf3 th\u1ec3 \u0111\u01b0\u1ee3c ph\xe2n t\xedch c\xfa ph\xe1p th\xe0nh c\xf4ng th\xe0nh ",(0,i.kt)("inlineCode",{parentName:"p"},"Ints"),", th\xec ch\xfang ta mu\u1ed1n c\u1ed9ng ba ",(0,i.kt)("inlineCode",{parentName:"p"},"Ints")," \u0111\xf3 \u0111\u1ec3 c\xf3 \u0111\u01b0\u1ee3c m\u1ed9t t\u1ed5ng. N\u1ebfu m\u1ed9t trong c\xe1c ph\xe2n t\xedch c\xfa ph\xe1p kh\xf4ng th\xe0nh c\xf4ng, ch\xfang t\xf4i mu\u1ed1n quay l\u1ea1i ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing"),"."),(0,i.kt)("p",null,"M\u1ed9t c\xe1ch \u0111\u1ec3 l\xe0m \u0111i\u1ec1u \u0111\xf3 s\u1ebd l\xe0:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo :: String -> String -> String -> Maybe Int\nfoo x y z = case readMaybe x of\n   Nothing -> Nothing\n   Just k  -> case readMaybe y of\n      Nothing -> Nothing\n      Just l  -> case readMaybe z of\n            Nothing -> Nothing\n            Just m  -> Just (k + l + m)\n")),(0,i.kt)("p",null,"H\xe3y xem n\u1ebfu n\xf3 ho\u1ea1t \u0111\u1ed9ng. \u0110\u1ea7u ti\xean, tr\u01b0\u1eddng h\u1ee3p th\xe0nh c\xf4ng:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> :l Week04.Maybe \nPrelude Week04.Maybe> foo "1" "2" "3"\nJust 6\n')),(0,i.kt)("p",null,"Tuy nhi\xean, n\u1ebfu m\u1ed9t trong c\xe1c gi\xe1 tr\u1ecb kh\xf4ng th\u1ec3 \u0111\u01b0\u1ee3c ph\xe2n t\xedch c\xfa ph\xe1p, ch\xfang t\xf4i nh\u1eadn \u0111\u01b0\u1ee3c ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Maybe> foo "" "2" "3"\nNothing\n')),(0,i.kt)("p",null,"M\xe3 n\xe0y kh\xf4ng l\xfd t\u01b0\u1edfng v\xec ch\xfang ta l\u1eb7p l\u1ea1i c\xf9ng m\u1ed9t m\u1eabu ba l\u1ea7n. M\u1ed7i l\u1ea7n ch\xfang ta ph\u1ea3i xem x\xe9t hai tr\u01b0\u1eddng h\u1ee3p - k\u1ebft qu\u1ea3 c\u1ee7a ph\xe9p \u0111\u1ecdc l\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Just")," ho\u1eb7c ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing"),"."),(0,i.kt)("p",null,"Ask Haskellers, we hate repetition like this."),(0,i.kt)("p",null,"\u0110i\u1ec1u ch\xfang t\xf4i mu\u1ed1n l\xe0m r\u1ea5t \u0111\u01a1n gi\u1ea3n. Ch\xfang t\xf4i mu\u1ed1n v\u01b0\u1ee3t qua ba ",(0,i.kt)("inlineCode",{parentName:"p"},"Strings")," v\xe0 th\xeam k\u1ebft qu\u1ea3, nh\u01b0ng v\u1edbi t\u1ea5t c\u1ea3 nh\u1eefng tr\u01b0\u1eddng h\u1ee3p \u0111\xf3, n\xf3 r\u1ea5t \u1ed3n v\xe0 r\u1ea5t x\u1ea5u. Ch\xfang t\xf4i mu\u1ed1n lo\u1ea1i b\u1ecf m\xf4 h\xecnh n\xe0y."),(0,i.kt)("p",null,"M\u1ed9t c\xe1ch \u0111\u1ec3 l\xe0m \u0111i\u1ec1u \u0111\xf3 l\xe0 x\xe1c \u0111\u1ecbnh m\u1ed9t c\xe1i g\xec \u0111\xf3 nh\u01b0:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"bindMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b\nbindMaybe Nothing = Nothing\nbindMaybe (Just x) f = f x\n")),(0,i.kt)("p",null,"H\xe3y vi\u1ebft l\u1ea1i c\xf9ng m\u1ed9t ch\u1ee9c n\u0103ng b\u1eb1ng c\xe1ch s\u1eed d\u1ee5ng ",(0,i.kt)("inlineCode",{parentName:"p"},"bindMaybe"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo' :: String -> String -> String -> Maybe Int\nfoo' x y z = readMaybe x `bindMaybe` \\k ->\n            readMaybe y `bindMaybe` \\l ->\n            readMaybe z `bindMaybe` \\m ->\n            Just (k + l + m)\n")),(0,i.kt)("p",null,"V\xe0 sau \u0111\xf3, trong REPL, ch\xfang t\xf4i nh\u1eadn \u0111\u01b0\u1ee3c k\u1ebft qu\u1ea3 t\u01b0\u01a1ng t\u1ef1 ",(0,i.kt)("inlineCode",{parentName:"p"},"foo\\'"),"nh\u01b0 ch\xfang t\xf4i \u0111\xe3 nh\u1eadn \u0111\u01b0\u1ee3c ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Maybe> foo "1" "2" "3"\nJust 6\n\nPrelude Week04.Maybe> foo "" "2" "3"\nNothing\n')),(0,i.kt)("p",null,"\u0110i\u1ec1u n\xe0y th\u1ef1c hi\u1ec7n ch\xednh x\xe1c nh\u01b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),", nh\u01b0ng n\xf3 nh\u1ecf g\u1ecdn h\u01a1n nhi\u1ec1u, \xedt ti\u1ebfng \u1ed3n h\u01a1n v\xe0 logic kinh doanh r\xf5 r\xe0ng h\u01a1n nhi\u1ec1u."),(0,i.kt)("p",null,"N\xf3 c\xf3 th\u1ec3, ho\u1eb7c c\xf3 th\u1ec3 kh\xf4ng, gi\xfap xem ch\u1ee9c n\u0103ng m\xe0 n\xf3 kh\xf4ng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng v\u1edbi k\xfd hi\u1ec7u infix:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Text.Read Week04.Maybe> bindMaybe (readMaybe "42" :: Maybe Int) (\\x -> Just x)\nJust 42\n')),(0,i.kt)("p",null,"\u1ede \u0111\xe2y b\u1ea1n c\xf3 th\u1ec3 th\u1ea5y r\xf5 r\xe0ng h\xe0m l\u1ea5y ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," v\xe0 sau \u0111\xf3 l\xe0 h\xe0m l\u1ea5y ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," t\u1eeb ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," v\xe0 s\u1eed d\u1ee5ng n\xf3 l\xe0m \u0111\u1ea7u v\xe0o cho m\u1ed9t h\xe0m tr\u1ea3 v\u1ec1 m\u1ed9t m\u1edbi  ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),"."),(0,i.kt)("p",null,"\u0110i\u1ec1u n\xe0y t\u1ea1o ra kh\xf4ng c\xf3 g\xec h\u1eefu \xedch, cho \u0111\u1ebfn khi ch\xfang t\xf4i th\xeam ",(0,i.kt)("inlineCode",{parentName:"p"},"readMaybe")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Text.Read Week04.Maybe> bindMaybe (readMaybe "42" :: Maybe Int) (\\x -> bindMaybe (readMaybe "5" :: Maybe Int) (\\y -> Just (y + x)))\nJust 47\n')),(0,i.kt)("p",null,"Theo m\u1ed9t s\u1ed1 c\xe1ch ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing")," ith\xec h\u01a1i gi\u1ed1ng m\u1ed9t ngo\u1ea1i l\u1ec7 trong c\xe1c ng\xf4n ng\u1eef kh\xe1c. N\u1ebfu b\u1ea5t k\u1ef3 ph\xe9p t\xednh n\xe0o tr\u1ea3 v\u1ec1  ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing"),",  ph\u1ea7n c\xf2n l\u1ea1i c\u1ee7a ph\xe9p t\xednh trong kh\u1ed1i kh\xf4ng \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n v\xe0  ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing")," \u0111\u01b0\u1ee3c tr\u1ea3 v\u1ec1."),(0,i.kt)("h3",{id:"m\u1ed9t-trong-hai-either"},"M\u1ed9t trong hai (Either)"),(0,i.kt)("p",null,"M\u1ed9t ki\u1ec3u r\u1ea5t h\u1eefu \xedch kh\xe1c trong Haskell l\xe0 ki\u1ec3u ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Either\ntype Either :: ` -> ` -> `\ndata Either a b = Left a | Right b\n   -- Defined in \u2018Data.Either\u2019\ninstance Applicative (Either e) -- Defined in \u2018Data.Either\u2019\ninstance (Eq a, Eq b) => Eq (Either a b)\n-- Defined in \u2018Data.Either\u2019\ninstance Functor (Either a) -- Defined in \u2018Data.Either\u2019\ninstance Monad (Either e) -- Defined in \u2018Data.Either\u2019\ninstance (Ord a, Ord b) => Ord (Either a b)\n-- Defined in \u2018Data.Either\u2019\ninstance Semigroup (Either a b) -- Defined in \u2018Data.Either\u2019\ninstance (Show a, Show b) => Show (Either a b)\n-- Defined in \u2018Data.Either\u2019\ninstance (Read a, Read b) => Read (Either a b)\n-- Defined in \u2018Data.Either\u2019\ninstance Foldable (Either a) -- Defined in \u2018Data.Foldable\u2019\ninstance Traversable (Either a) -- Defined in \u2018Data.Traversable\u2019\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Either")," nh\u1eadn hai tham s\u1ed1 ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),".  Gi\u1ed1ng nh\u01b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," n\xf3 c\xf3 hai h\xe0m t\u1ea1o, nh\u01b0ng kh\xf4ng gi\u1ed1ng nh\u01b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," c\u1ea3 hai \u0111\u1ec1u nh\u1eadn m\u1ed9t gi\xe1 tr\u1ecb. N\xf3 c\xf3 th\u1ec3 ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," l\xe0 m\u1ed9t ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," ho\u1eb7c m\u1ed9t l\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),". Hai h\xe0m t\u1ea1o l\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Right"),"."),(0,i.kt)("p",null,"V\xed d\u1ee5:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> Left "Haskell" :: Either String Int\nLeft "Haskell"\n')),(0,i.kt)("p",null,"ho\u1eb7c"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> Right 7 :: Either String Int\nRight 7\n")),(0,i.kt)("p",null,"N\u1ebfu ch\xfang ta xem x\xe9t ph\xe9p lo\u1ea1i suy ngo\u1ea1i l\u1ec7 xa h\u01a1n m\u1ed9t ch\xfat, th\xec m\u1ed9t v\u1ea5n \u0111\u1ec1 ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," l\xe0 n\u1ebfu ch\xfang ta quay tr\u1edf l\u1ea1i ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing"),", kh\xf4ng c\xf3 th\xf4ng b\xe1o l\u1ed7i. Tuy nhi\xean, n\u1ebfu ch\xfang ta mu\u1ed1n m\u1ed9t th\u1ee9 g\xec \u0111\xf3 \u0111\u01b0a ra m\u1ed9t th\xf4ng \u0111i\u1ec7p, ch\xfang ta c\xf3 th\u1ec3 thay th\u1ebf ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),"b\u1eb1ng ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),"."),(0,i.kt)("p",null,"Trong tr\u01b0\u1eddng h\u1ee3p \u0111\xf3, ",(0,i.kt)("inlineCode",{parentName:"p"},"Right")," c\xf3 th\u1ec3 t\u01b0\u01a1ng \u1ee9ng v\u1edbi ",(0,i.kt)("inlineCode",{parentName:"p"},"Just"),"v\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Left")," c\xf3 th\u1ec3 t\u01b0\u01a1ng \u1ee9ng v\u1edbi m\u1ed9t l\u1ed7i, nh\u01b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing")," \u0111\xe3 l\xe0m. Tuy nhi\xean, t\xf9y thu\u1ed9c v\xe0o lo\u1ea1i m\xe0 ch\xfang t\xf4i ch\u1ecdn cho ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", ch\xfang t\xf4i c\xf3 th\u1ec3 \u0111\u01b0a ra c\xe1c th\xf4ng b\xe1o l\u1ed7i th\xedch h\u1ee3p."),(0,i.kt)("p",null,"H\xe3y \u0111\u1ecbnh ngh\u0129a m\u1ed9t c\xe1i g\xec \u0111\xf3 \u0111\u01b0\u1ee3c g\u1ecdi ",(0,i.kt)("inlineCode",{parentName:"p"},"readEither")," v\xe0 xem n\xf3 l\xe0m g\xec khi c\xf3 th\u1ec3 v\xe0 khi n\xe0o n\xf3 kh\xf4ng th\u1ec3 ph\xe2n t\xedch c\xfa ph\xe1p \u0111\u1ea7u v\xe0o c\u1ee7a n\xf3."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'readEither :: Read a => String -> Either String a\nreadEither s case readMaybe s of\n   Nothing -> Left $ "can\'t parse: " ++ s\n   Just a  -> Right a\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Either> readEither "42" :: Either String Int\nRight 42\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Either> readEither "42+u" :: Either String Int\nLeft "can\'t parse: 42+u"\n')),(0,i.kt)("p",null,"S\u1eed d\u1ee5ng \u0111i\u1ec1u n\xe0y, b\xe2y gi\u1edd ch\xfang ta c\xf3 th\u1ec3 vi\u1ebft l\u1ea1i ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," b\u1eb1ng ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),". \u0110\u1ea7u ti\xean, s\u1eed d\u1ee5ng ph\u01b0\u01a1ng ph\xe1p d\xe0i d\xf2ng:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo :: String -> String -> String -> Either String Int\nfoo x y z = case readEither x of\n   Left err -> Left err\n   Right k  -> case readEither y of\n      Left err -> Left err\n      Right l  -> case readEither z of\n            Left err -> Left err\n            Right m  -> Right (k + l + m)\n")),(0,i.kt)("p",null,"H\xe3y th\u1eed n\xf3. \u0110\u1ea7u ti\xean, \u0111\u01b0\u1eddng d\u1eabn t\u1ed1t:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Either> foo "1" "2" "3"\nRight 6\n')),(0,i.kt)("p",null,"sau \u0111\xf3 c\xf3 v\u1ea5n \u0111\u1ec1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Either> foo "ays" "2" "3"\nLeft "can\'t parse: ays"\n')),(0,i.kt)("p",null,"h\u01b0ng, ch\xfang t\xf4i c\xf3 c\xf9ng m\u1ed9t v\u1ea5n \u0111\u1ec1 m\xe0 ch\xfang t\xf4i \u0111\xe3 g\u1eb7p ph\u1ea3i ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),"; ch\xfang t\xf4i c\xf3 r\u1ea5t nhi\u1ec1u s\u1ef1 l\u1eb7p l\u1ea1i."),(0,i.kt)("p",null,"Gi\u1ea3i ph\xe1p c\u0169ng t\u01b0\u01a1ng t\u1ef1."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"bindEither :: Either String a -> (a -> Either String b) -> Either String b\nbindEither (Left err) _ = Left err\nbindEither (Right x)  f = f x\n\nfoo' :: String -> String -> String -> Either String Int\nfoo' x y z = readEither x `bindEither` \\k ->\n            readEither y `bindEither` \\l ->\n            readEither z `bindEither` \\m ->\n            Right (k + l + m)\n")),(0,i.kt)("p",null,"B\u1ea1n c\xf3 th\u1ec3 ch\u1ea1y l\u1ea1i \u0111i\u1ec1u n\xe0y trong REPL v\xe0 n\xf3 s\u1ebd ho\u1ea1t \u0111\u1ed9ng gi\u1ed1ng nh\u01b0 phi\xean b\u1ea3n d\xe0i d\xf2ng c\u1ee7a n\xf3."),(0,i.kt)("h3",{id:"writer"},"Writer"),(0,i.kt)("p",null,"Cho \u0111\u1ebfn nay ch\xfang t\xf4i \u0111\xe3 xem x\xe9t ba v\xed d\u1ee5: ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe a")," v\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Either String a"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," \u0111\u1ea1i di\u1ec7n cho c\xe1c k\u1ebf ho\u1ea1ch c\xf3 th\u1ec3 li\xean quan \u0111\u1ebfn c\xe1c t\xe1c d\u1ee5ng ph\u1ee5 v\xe0 khi \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n, t\u1ea1o ra m\u1ed9t ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe a")," v\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Either String a")," \u0111\u1ea1i di\u1ec7n cho c\xe1c ph\xe9p t\xednh c\xf3 th\u1ec3 t\u1ea1o ra  ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," nh\u01b0ng c\u0169ng c\xf3 th\u1ec3 th\u1ea5t b\u1ea1i. S\u1ef1 kh\xe1c bi\u1ec7t gi\u1eefa ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," v\xe0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," ch\u1ec9 ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," kh\xf4ng t\u1ea1o ra b\u1ea5t k\u1ef3 th\xf4ng b\xe1o l\u1ed7i n\xe0o, nh\u01b0ng  ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," th\xec c\xf3."),(0,i.kt)("p",null,"B\xe2y gi\u1edd ch\xfang ta h\xe3y xem x\xe9t m\u1ed9t v\xed d\u1ee5 ho\xe0n to\xe0n kh\xe1c ghi l\u1ea1i \xfd t\u01b0\u1edfng v\u1ec1 c\xe1c ph\xe9p t\xednh c\u0169ng c\xf3 th\u1ec3 t\u1ea1o ra \u0111\u1ea7u ra nh\u1eadt k\xfd."),(0,i.kt)("p",null,"Ch\xfang ta c\xf3 th\u1ec3 bi\u1ec3u di\u1ec5n \u0111i\u1ec1u \u0111\xf3 b\u1eb1ng m\u1ed9t ki\u1ec3u."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data Writer a = Writer a [String]\n   deriving Show\n")),(0,i.kt)("p",null,"V\xed d\u1ee5, h\xe3y vi\u1ebft m\u1ed9t h\xe0m tr\u1ea3 v\u1ec1  ",(0,i.kt)("inlineCode",{parentName:"p"},"Writer")," cho  ",(0,i.kt)("inlineCode",{parentName:"p"},"Int")," v\xe0 vi\u1ebft m\u1ed9t th\xf4ng b\xe1o nh\u1eadt k\xfd."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'number :: Int -> Writer Int\nnumber n = Writer n $ ["number: " ++ show n]\n')),(0,i.kt)("p",null,"Trong REPL:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Writer> number 42\nWriter 42 ["number: 42"]\n')),(0,i.kt)("p",null,"B\xe2y gi\u1edd, ch\xfang ta h\xe3y l\xe0m \u0111i\u1ec1u g\xec \u0111\xf3 t\u01b0\u01a1ng t\u1ef1 nh\u01b0 ch\xfang ta \u0111\xe3 l\xe0m v\u1edbi ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),"v\xe0  ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),"."),(0,i.kt)("p",null,"H\xe3y vi\u1ebft m\u1ed9t h\xe0m s\u1eed d\u1ee5ng ba ph\xe9p t\xednh ghi nh\u1eadt k\xfd m\xe0 m\u1ed7i ph\xe9p t\xednh t\u1ea1o ra m\u1ed9t ",(0,i.kt)("inlineCode",{parentName:"p"},"Int")," v\xe0 ch\xfang ta mu\u1ed1n tr\u1ea3 v\u1ec1 m\u1ed9t ph\xe9p t\xednh duy nh\u1ea5t t\u1ea1o ra t\u1ed5ng c\u1ee7a c\xe1c ph\xe9p t\xednh \u0111\xf3 ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo (Writer k xs) (Writer l ys) (Writer m zs) =\nWriter (K + l + m) $ xs ++ ys ++ zs\n")),(0,i.kt)("p",null,"Trong REPL:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Writer> foo (number 1) (number 2) (number 3)\nWriter 6 ["number: 1","number: 2","number: 3"]\n')),(0,i.kt)("p",null,"B\xe2y gi\u1edd, h\xe3y vi\u1ebft m\u1ed9t h\xe0m h\u1eefu \xedch kh\xe1c c\xf3 danh s\xe1ch th\xf4ng b\xe1o v\xe0 c\xe1c nh\xe0 s\u1ea3n xu\u1ea5t m\u1ed9t ",(0,i.kt)("inlineCode",{parentName:"p"},"Writer")," kh\xf4ng c\xf3 k\u1ebft qu\u1ea3 h\u1eefu \xedch."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"tell :: [String] -> Writer ()\ntell = Writer ()\n")),(0,i.kt)("p",null,"B\xe2y gi\u1edd, ch\xfang t\xf4i c\xf3 th\u1ec3 c\u1eadp nh\u1eadt ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," \u0111\u1ec3 th\xeam m\u1ed9t th\xf4ng b\xe1o nh\u1eadt k\xfd b\u1ed5 sung hi\u1ec3n th\u1ecb t\u1ed5ng c\xe1c s\u1ed1."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'foo :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo (Writer k xs) (Writer l ys) (Writer m zs) =\nlet\n   s = k + l + m\n   Writer _ us = tell ["sum: " ++ show s]\nin\n   Writer s $ xs ++ ys ++ zs ++ us\n')),(0,i.kt)("p",null,"In the REPL:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Writer> foo (number 1) (number 2) (number 3)\nWriter 6 ["number: 1","number: 2","number: 3","sum: 6"]\n')),(0,i.kt)("p",null,"As before, we can write a bind function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"bindWriter :: Writer a -> (a -> Writer b) -> Writer b\nbindWriter (Writer a xs) f =\nlet\n   Writer b ys = f a\nin\n   Writer b $ xs ++ ys\n")),(0,i.kt)("p",null,"Here, the ",(0,i.kt)("inlineCode",{parentName:"p"},"bindWriter")," function is returning the ",(0,i.kt)("inlineCode",{parentName:"p"},"Writer b")," and\nproducing log messages which are a concatenation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"xs")," that we\npattern matched on input, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"ys")," that we pattern matched when\ncalling ",(0,i.kt)("inlineCode",{parentName:"p"},"f a")," in order to produce the ",(0,i.kt)("inlineCode",{parentName:"p"},"Writer b"),"."),(0,i.kt)("p",null,"Now, we can rewrite ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"bindWriter")," and make it much nicer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo' :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo' x y z = x `bindWriter` \\k ->\n            y `bindWriter` \\l ->\n            z `bindWriter` \\m ->\n            let s = k + l + m\n            in tell [\"sum: \" ++ show s] `bindWriter` \\_ ->\n               Writer s []\n")),(0,i.kt)("p",null,"What we did with ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," before, we can now do with ",(0,i.kt)("inlineCode",{parentName:"p"},"foo\\'"),", and we get\nthe same result."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Writer> foo\' (number 1) (number 2) (number 3)\nWriter 6 ["number: 1","number: 2","number: 3","sum: 6"]\n')),(0,i.kt)("p",null,"Admittedly, it is longer than it was before, but it is much nicer. We no\nlonger need to do the pattern matching to extract the messages. We\ndon\\'t have to explicitly combine the log messages, where we could make\na mistake and forget one, or get the order wrong. Instead, we abstract\nall that away and can just concentrate on the business logic."),(0,i.kt)("p",null,"Although the pattern is the same as with ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),", note that\nthe special aspect of these computations is completely different. With\n",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," we dealt with the notion of failure, whereas here,\nwith the ",(0,i.kt)("inlineCode",{parentName:"p"},"Writer"),", there is no failure, but we instead have additional\noutput."),(0,i.kt)("h3",{id:"what-is-a-monad"},"What is a Monad?"),(0,i.kt)("p",null,"Now, we are in a position to explain what a Monad is."),(0,i.kt)("p",null,"Looking back at the four examples, what did they have in common? In all\nfour cases, We had a type constructor with one type parameter - ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Either String")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Writer")," all take a type parameter."),(0,i.kt)("p",null,"And, for all four of these examples, we had a bind function. For ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),",\nwe had the ",(0,i.kt)("inlineCode",{parentName:"p"},"\\>\\>=")," function and for the others we had the bind functions\nthat we wrote ourselves."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"bindWriter :: Writer a -> (a -> Writer b) -> Writer b\nbindEither :: Either String a -> (a -> Either String b) -> Either String b\nbindMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b\n")),(0,i.kt)("p",null,"How the bind works depends on the case. In the case of ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," it is\nbuilt-in magic, but you can think of it as just combining the two plans\ndescribing the actions to take during computation. For ",(0,i.kt)("inlineCode",{parentName:"p"},"bindMaybe")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"bindEither")," the logic is for the whole plan to fail if any part of it\nfails, and for ",(0,i.kt)("inlineCode",{parentName:"p"},"bindWriter"),", the logic was to combine the list of log\nmessages."),(0,i.kt)("p",null,"And that is the main idea of Monads. It\\'s a concept of computation with\nsome additional side effects, and the ability to bind two such\ncomputations together."),(0,i.kt)("p",null,"There is another aspect that we briefly mentioned in the case of ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),"\nbut not for the other examples - another thing that we can always do."),(0,i.kt)("p",null,"Whenever we have such a concept of computation with side effects, we\nalso also always have the ability to produce a computation of this kind\nthat ",(0,i.kt)("inlineCode",{parentName:"p"},"doesn\\'t")," have any side effects."),(0,i.kt)("p",null,"In the example of ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),", this was done with ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),". Given an ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", you\ncan create an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," which is the recipe that always simply returns the\n",(0,i.kt)("inlineCode",{parentName:"p"},"a")," with no side effects. Each of the other example has this ability as\nwell, as shown below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"return              :: a -> IO a\nJust                :: a -> Maybe a\nRight               :: a -> Either String a\n(\\a -> Writer a []) :: a -> Writer a\n")),(0,i.kt)("p",null,"And it is the combination of these two features that defines a Monad."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the ability to bind two computations together"),(0,i.kt)("li",{parentName:"ul"},"the possibility to construct a computation from a pure value without\nmaking use of any of the potential side effects")),(0,i.kt)("p",null,"If we look in the REPL:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Monad\ntype Monad :: (` -> `) -> Constraint\nclass Applicative m => Monad m where\n(>>=) :: m a -> (a -> m b) -> m b\n(>>) :: m a -> m b -> m b\nreturn :: a -> m a\n{-# MINIMAL (>>=) #-}\n   -- Defined in \u2018GHC.Base\u2019\ninstance Monad (Either e) -- Defined in \u2018Data.Either\u2019\ninstance Monad [] -- Defined in \u2018GHC.Base\u2019\ninstance Monad Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Monad IO -- Defined in \u2018GHC.Base\u2019\ninstance Monad ((->) r) -- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b, Monoid c) => Monad ((,,,) a b c)\n-- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b) => Monad ((,,) a b)\n-- Defined in \u2018GHC.Base\u2019\ninstance Monoid a => Monad ((,) a) -- Defined in \u2018GHC.Base\u2019\n")),(0,i.kt)("p",null,"We see the bind function"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"(>>=) :: m a -> (a -> m b) -> m b\n")),(0,i.kt)("p",null,"And the ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," function that takes a pure value and turns it into a\ncomputation that has potential for side effects, but does not use them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"return :: a -> m a\n")),(0,i.kt)("p",null,"The other function ",(0,i.kt)("inlineCode",{parentName:"p"},"\\>\\>")," can easily be defined in terms of ",(0,i.kt)("inlineCode",{parentName:"p"},"\\>\\>="),", but\nis provided for convenience."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"(>>) :: m a -> m b -> m b\n")),(0,i.kt)("p",null,"What this function does is to throw away the result of the first\ncomputation, so you could define it in terms of ",(0,i.kt)("inlineCode",{parentName:"p"},"\\>\\>=")," by just ignoring\nthe argument to the function parameter."),(0,i.kt)("p",null,"There\\'s another technical computation. We see that ",(0,i.kt)("inlineCode",{parentName:"p"},"Monad")," has the\nsuper class ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative"),", so every Monad is ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Applicative\ntype Applicative :: (` -> `) -> Constraint\nclass Functor f => Applicative f where\npure :: a -> f a\n(<`>) :: f (a -> b) -> f a -> f b\nGHC.Base.liftA2 :: (a -> b -> c) -> f a -> f b -> f c\n(`>) :: f a -> f b -> f b\n(<`) :: f a -> f b -> f a\n{-# MINIMAL pure, ((<`>) | liftA2) #-}\n   -- Defined in \u2018GHC.Base\u2019\ninstance Applicative (Either e) -- Defined in \u2018Data.Either\u2019\ninstance Applicative [] -- Defined in \u2018GHC.Base\u2019\ninstance Applicative Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Applicative IO -- Defined in \u2018GHC.Base\u2019\ninstance Applicative ((->) r) -- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b, Monoid c) =>\n         Applicative ((,,,) a b c)\n-- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b) => Applicative ((,,) a b)\n-- Defined in \u2018GHC.Base\u2019\ninstance Monoid a => Applicative ((,) a) -- Defined in \u2018GHC.Base\u2019\n")),(0,i.kt)("p",null,"We see it has a bunch of functions, but we only need the first two."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"pure :: a -> f a\n(<`>) :: f (a -> b) -> f a -> f b\n")),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"pure")," has the same type signature as ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),". Then there\nis \\<","`",">"," (pronounced \\'ap\\') which looks a bit more complicated. But,\nthe truth is that, once you have ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\\>\\>=")," in a Monad, we can\neasily define both ",(0,i.kt)("inlineCode",{parentName:"p"},"pure")," and \\<","`",">","."),(0,i.kt)("p",null,"We see that ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative")," also has a superclass ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Functor\ntype Functor :: (` -> `) -> Constraint\nclass Functor f where\nfmap :: (a -> b) -> f a -> f b\n(<$) :: a -> f b -> f a\n{-# MINIMAL fmap #-}\n   -- Defined in \u2018GHC.Base\u2019\ninstance Functor (Either a) -- Defined in \u2018Data.Either\u2019\ninstance Functor [] -- Defined in \u2018GHC.Base\u2019\ninstance Functor Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Functor IO -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((->) r) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,,,) a b c) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,,) a b) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,) a) -- Defined in \u2018GHC.Base\u2019\n")),(0,i.kt)("p",null,"As we mentioned in the context of ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," has the ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"\nfunction which, given a function from ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," will turn an ",(0,i.kt)("inlineCode",{parentName:"p"},"f a")," into\nan ",(0,i.kt)("inlineCode",{parentName:"p"},"f b"),"."),(0,i.kt)("p",null,"The prototypical example for ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," is lists where ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," is just ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".\nGiven a function from ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),", you can create a list of type ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," from\na list of type ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," by applying the ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," function to each of the\nelements of the list."),(0,i.kt)("p",null,"Again, once you have ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\\>\\>="),", it is easy to define ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"."),(0,i.kt)("p",null,"So, whenever you want to define a Monad, you just define ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"\\>\\>="),", and to make the compiler happy and to give instances for\n",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative"),", there\\'s always a standard way of doing it."),(0,i.kt)("p",null,"We can do this in the example of ",(0,i.kt)("inlineCode",{parentName:"p"},"Writer"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"import Control.Monad\n\ninstance Functor Writer where\n   fmap = liftM\n\ninstance Applicative Writer where\n   pure = return\n   (<`>) = ap\n\ninstance Monad Writer where\n   return a = Writer a []\n   (>>=) = bindWriter\n")),(0,i.kt)("p",null,"We don\\'t have to do the same for ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," because they\nare already Monads defined by the Prelude."),(0,i.kt)("h3",{id:"why-is-this-useful"},"Why Is This useful?"),(0,i.kt)("p",null,"It is always useful, in general, to identify a common pattern and give\nit a name."),(0,i.kt)("p",null,"But, maybe the most important advantage is that there are lots of\nfunctions that don\\'t care which Monad we are dealing with - they will\nwork with all Monads."),(0,i.kt)("p",null,"Let\\'s generalize the example where we compute the sum of three\nintegers. We use a ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," in the example below for reasons that will\nbecome clear in moment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"threeInts :: Monad m => m Int -> m Int -> m Int -> m Int\nthreeInts mx my mz =\n   mx >>= \\k ->\n   my >>= \\l ->\n   mz >>= \\m ->\n   let s = k + l + m in return s\n")),(0,i.kt)("p",null,"Now we have this function, we can return to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," example and\nrewrite it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo'' :: String -> String -> String -> Maybe Int\nfoo'' x y z = threeInts (readMaybe x) (readMaybe y) (readMaybe z)\n")),(0,i.kt)("p",null,"We can do the same for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo'' :: String -> String -> String -> Either String Int\nfoo'' x y z = threeInts (readEither x) (readEither y) (readEither z)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Writer")," example is not exactly the same."),(0,i.kt)("p",null,"If we are happy not to have the log message for the sum, it is very\nsimple as it is already an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"threeInts"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo'' :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo'' x y z = threeInts\n")),(0,i.kt)("p",null,"However, if we want the final log message, it becomes a little more\ncomplicated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo'' :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo'' x y z = do\n   s <- threeInts x y z\n   tell [\"sum: \" ++ show s]\n   return s\n")),(0,i.kt)("p",null,"If you look into the Control.Monad module in the standard Haskell\nPrelude, you will see that there are many useful functions that you can\nuse for all Monads."),(0,i.kt)("p",null,"One way to think about a Monad is as a computation with a super power."),(0,i.kt)("p",null,"In the case of ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),", the super power would be having real-world\nside-effects. In the case of ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),", the super power is being able to\nfail. The super power of ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," is to fail with an error message. And\nin the case of ",(0,i.kt)("inlineCode",{parentName:"p"},"Writer"),", the super power is to log messages."),(0,i.kt)("p",null,"There is a saying in the Haskell community that Haskell has an\noverloaded semi-colon. The explanation for this is that in many\nimperative programming languages, you have semi-colons that end with a\nsemi-colon - each statement is executed one after the other, each\nseparated by a semi-colon. But, what exactly the semi-colon means\ndepends on the language. For example, there could be an exception, in\nwhich case computation would stop and wouldn\\'t continue with the next\nlines."),(0,i.kt)("p",null,"In a sense, ",(0,i.kt)("inlineCode",{parentName:"p"},"bind")," is like a semi-colon. And the cool thing about\nHaskell is that it is a programmable semi-colon. We get to say what the\nlogic is for combining two computations together."),(0,i.kt)("p",null,'Each Monad comes with its own \\"semi-colon\\".'),(0,i.kt)("h3",{id:"do-notation"},"\\'do\\' notation"),(0,i.kt)("p",null,"Because this pattern is so common and monadic computations are all over\nthe place, there is a special notation for this in Haskell, called ",(0,i.kt)("inlineCode",{parentName:"p"},"do"),"\nnotation."),(0,i.kt)("p",null,"It is syntactic sugar. Let\\'s rewrite ",(0,i.kt)("inlineCode",{parentName:"p"},"threeInts")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"do")," notation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"threeInts' :: Monad m => m Int -> m Int -> m Int -> m Int\nthreeInts' mx my mz = do\n   k <- mx\n   l <- my\n   m <- mz\n   let s = k + l + m\n   return s\n")),(0,i.kt)("p",null,"This does exactly the same thing as the non-",(0,i.kt)("inlineCode",{parentName:"p"},"do")," version, but it has\nless noise."),(0,i.kt)("p",null,"Note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," statement does not use an ",(0,i.kt)("inlineCode",{parentName:"p"},"in")," part. It does not\nneed to inside a ",(0,i.kt)("inlineCode",{parentName:"p"},"do")," block."),(0,i.kt)("p",null,"And that\\'s Monads. There is a lot more to say about them but hopefully\nyou now have an idea of what Monads are and how they work."),(0,i.kt)("p",null,"Often you are in a situation where you want several effects at once -for\nexample you may want optional failure ",(0,i.kt)("inlineCode",{parentName:"p"},"and")," log messages. There are ways\nto do that in Haskell. For example there are Monad Transformers where\none can basically build custom Monads with the features that you want."),(0,i.kt)("p",null,"There are other approaches. One is called Effect Systems, which has a\nsimilar objective. And this is incidentally what Plutus uses for\nimportant Monads. In particular the Contact Monad in the wallet, and the\nTrace Monad which is used to test Plutus code."),(0,i.kt)("p",null,"The good news is that you don\\'t need to understand Effect Systems to\nwork with these Monads. You just need to know that you are working with\na Monad, and what super powers it has."),(0,i.kt)("h2",{id:"plutus-monads"},"Plutus Monads"),(0,i.kt)("p",null,"Now that we have seen how to write monadic code, either by using bind\nand return or by using do notation, we can look a very important Monad,\nnamely the Contract Monad, which you may have already noticed in\nprevious code examples."),(0,i.kt)("p",null,"The Contract Monad defines code that will run in the wallet, which is\nthe off-chain part of Plutus."),(0,i.kt)("p",null,"But, before we go into details, we will talk about a second Monad, the\nEmulatorTrace monad."),(0,i.kt)("h3",{id:"the-emulatortrace-monad"},"The EmulatorTrace Monad"),(0,i.kt)("p",null,"You may have wondered if there is a way to execute Plutus code for\ntesting purposes without using the Plutus Playground. There is indeed,\nand this is done using the ",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorTrace")," Monad."),(0,i.kt)("p",null,"You can think of a program in this monad as what we do manually in the\n",(0,i.kt)("inlineCode",{parentName:"p"},"simulator")," tab of the playground. That is, we define the initial\nconditions, we define the actions such as which wallets invoke which\nendpoints with which parameters and we define the waiting periods\nbetween actions."),(0,i.kt)("p",null,"The relevant definitions are in the package ",(0,i.kt)("inlineCode",{parentName:"p"},"plutus-contract")," in module\n",(0,i.kt)("inlineCode",{parentName:"p"},"Plutus.Trace.Emulator"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"module Plutus.Trace.Emulator\n")),(0,i.kt)("p",null,"The most basic function is called ",(0,i.kt)("inlineCode",{parentName:"p"},"runEmulatorTrace"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"-- | Run an emulator trace to completion, returning a tuple of the final state\n-- of the emulator, the events, and any error, if any.\nrunEmulatorTrace\n    :: EmulatorConfig\n    -> EmulatorTrace ()\n    -> ([EmulatorEvent], Maybe EmulatorErr, EmulatorState)\nrunEmulatorTrace cfg trace =\n    (\\(xs :> (y, z)) -> (xs, y, z))\n    $ run\n    $ runReader ((initialDist . _initialChainState) cfg)\n    $ foldEmulatorStreamM (generalize list)\n    $ runEmulatorStream cfg trace\n")),(0,i.kt)("p",null,"It gets something called an ",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorConfig")," and an ",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorTrace ()"),",\nwhich is a pure computation where no real-world side effects are\ninvolved. It is a pure function that executes the trace on an emulated\nblockchain, and then gives a result as a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorEvent"),"s, maybe\nan error, if there was one, and then finally the final ",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorState"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorConfig")," is defined in a different module in the same package:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"module Wallet.Emulator.Stream\n\ndata EmulatorConfig =\nEmulatorConfig\n    { _initialChainState      :: InitialChainState -- ^ State of the blockchain at the beginning of the simulation. Can be given as a map of funds to wallets, or as a block of transactions.\n    } deriving (Eq, Show)\n\ntype InitialChainState = Either InitialDistribution Block\n")),(0,i.kt)("p",null,"We see it only has one field, which is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"InitialChainState")," and\nit is either ",(0,i.kt)("inlineCode",{parentName:"p"},"InitialDistribution")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Block"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"InitialDistribution")," is defined in another module in the same package,\nand it is a type synonym for a map of key value pairs of ",(0,i.kt)("inlineCode",{parentName:"p"},"Wallet"),"s to\n",(0,i.kt)("inlineCode",{parentName:"p"},"Value"),"s, as you would expect. ",(0,i.kt)("inlineCode",{parentName:"p"},"Value")," can be either lovelace or native\ntokens."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"module Plutus.Contract.Trace\n\ntype InitialDistribution = Map Wallet Value\n")),(0,i.kt)("p",null,"In the same module, we see something called ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultDist")," which returns\na default distribution for all wallets. It does this by passing the 10\nwallets defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"allWallets")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultDistFor")," which takes a list\nof wallets."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"-- | The wallets used in mockchain simulations by default. There are\n--   ten wallets because the emulator comes with ten private keys.\nallWallets :: [EM.Wallet]\nallWallets = EM.Wallet <$> [1 .. 10]\n\ndefaultDist :: InitialDistribution\ndefaultDist = defaultDistFor allWallets\n\ndefaultDistFor :: [EM.Wallet] -> InitialDistribution\ndefaultDistFor wallets = Map.fromList $ zip wallets (repeat (Ada.lovelaceValueOf 100_000_000))\n")),(0,i.kt)("p",null,"We can try this out in the REPL:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> import Plutus.Trace.Emulator\nPrelude Plutus.Trace.Emulator Week04.Contract> import Plutus.Contract.Trace\nPrelude Plutus.Trace.Emulator Plutus.Contract.Trace Week04.Contract> defaultDist\nfromList [(Wallet 1,Value (Map [(,Map [("",100000000)])])),(Wallet 2,Value (Map [(,Map [("",100000000)])])),(Wallet 3,Value (Map [(,Map [("",100000000)])])),(Wallet 4,Value (Map [(,Map [("",100000000)])])),(Wallet 5,Value (Map [(,Map [("",100000000)])])),(Wallet 6,Value (Map [(,Map [("",100000000)])])),(Wallet 7,Value (Map [(,Map [("",100000000)])])),(Wallet 8,Value (Map [(,Map [("",100000000)])])),(Wallet 9,Value (Map [(,Map [("",100000000)])])),(Wallet 10,Value (Map [(,Map [("",100000000)])]))]\n')),(0,i.kt)("p",null,"We can see that each of the 10 wallets has been given an initial\ndistribution of 100,000,000 lovelace."),(0,i.kt)("p",null,"We can also get the balances for a specific wallet or wallets:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Week04.Contract> defaultDistFor [Wallet 1]\nfromList [(Wallet 1,Value (Map [(,Map [("",100000000)])]))]\n')),(0,i.kt)("p",null,"If you want different initial values, of if you want native tokens, then\nyou have to specify that manually."),(0,i.kt)("p",null,"Let\\'s see what we need to run our first trace:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Week04.Contract> :t runEmulatorTrace\nrunEmulatorTrace\n:: EmulatorConfig\n-> EmulatorTrace ()\n-> ([Wallet.Emulator.MultiAgent.EmulatorEvent], Maybe EmulatorErr,\n      Wallet.Emulator.MultiAgent.EmulatorState)\n")),(0,i.kt)("p",null,"So, we need an ",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorConfig")," which we know takes an\n",(0,i.kt)("inlineCode",{parentName:"p"},"InitialChainState"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Week04.Contract> import Wallet.Emulator.Stream \nPrelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator.Stream Week04.Contract> :i InitialChainState \ntype InitialChainState :: `\ntype InitialChainState =\nEither InitialDistribution Ledger.Blockchain.Block\n      -- Defined in \u2018Wallet.Emulator.Stream\u2019\n")),(0,i.kt)("p",null,"If we take the ",(0,i.kt)("inlineCode",{parentName:"p"},"Left")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultDist")," will will get an\n",(0,i.kt)("inlineCode",{parentName:"p"},"InitialDistribution"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator.Stream Week04.Contract> :t Left defaultDist\nLeft defaultDist :: Either InitialDistribution b\n")),(0,i.kt)("p",null,"Which we can then use to construct an ",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorConfig"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator.Stream Week04.Contract> EmulatorConfig $ Left defaultDist\nEmulatorConfig {_initialChainState = Left (fromList [(Wallet 1,Value (Map [(,Map [("",100000000)])])),(Wallet 2,Value (Map [(,Map [("",100000000)])])),(Wallet 3,Value (Map [(,Map [("",100000000)])])),(Wallet 4,Value (Map [(,Map [("",100000000)])])),(Wallet 5,Value (Map [(,Map [("",100000000)])])),(Wallet 6,Value (Map [(,Map [("",100000000)])])),(Wallet 7,Value (Map [(,Map [("",100000000)])])),(Wallet 8,Value (Map [(,Map [("",100000000)])])),(Wallet 9,Value (Map [(,Map [("",100000000)])])),(Wallet 10,Value (Map [(,Map [("",100000000)])]))])}\n')),(0,i.kt)("p",null,"So, let\\'s try out ",(0,i.kt)("inlineCode",{parentName:"p"},"runEmulatorTrace"),". Recall that, as well as and\n",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorConfig"),", we also need to pass in an ",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorTrace"),", and the\nmost simple one we can create is simply one that returns Unit - ",(0,i.kt)("inlineCode",{parentName:"p"},"return\n()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"runEmulatorTrace (EmulatorConfig $ Left defaultDist) $ return ()\n")),(0,i.kt)("p",null,"If you run this in the REPL you will get a crazy amount of data output\nto the console, even though we are not doing anything with the trace. If\nyou want to make it useful, you must somehow filter all this data down\nto something that sensible, and aggregate it in some way."),(0,i.kt)("p",null,"Luckily, there are other functions as well as ",(0,i.kt)("inlineCode",{parentName:"p"},"runEmulatorTrace"),". One of\nthem is ",(0,i.kt)("inlineCode",{parentName:"p"},"runEmulatorTraceIo")," which runs the emulation then outputs the\ntrace in a nice form on the screen."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"runEmulatorTraceIO\n:: EmulatorTrace ()\n-> IO ()\nrunEmulatorTraceIO = runEmulatorTraceIO' def def\n")),(0,i.kt)("p",null,"To use this function, we don\\'t need to specify an ",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorConfig")," like\nwe did before, because by default will will just use the default\ndistribution."),(0,i.kt)("p",null,"In the REPL:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude...> runEmulatorTraceIO $ return ()\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.}"},'Slot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: SlotAdd Slot 2\nFinal balances\nWallet 1: \n{, ""}: 100000000\nWallet 2: \n{, ""}: 100000000\nWallet 3: \n{, ""}: 100000000\nWallet 4: \n{, ""}: 100000000\nWallet 5: \n{, ""}: 100000000\nWallet 6: \n{, ""}: 100000000\nWallet 7: \n{, ""}: 100000000\nWallet 8: \n{, ""}: 100000000\nWallet 9: \n{, ""}: 100000000\nWallet 10: \n{, ""}: 100000000\n')),(0,i.kt)("p",null,"And we see a much more manageable, concise output. Nothing happens, but\nwe see the Genesis transaction and then the final balances for each\nwallet."),(0,i.kt)("p",null,"If you want more control, there is also ",(0,i.kt)("inlineCode",{parentName:"p"},"runEmulatorTraceIO\\'"),", which\ndoes take an ",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorConfig"),", so we could specify a different\ndistribution."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"runEmulatorTraceIO'\n:: TraceConfig\n-> EmulatorConfig\n-> EmulatorTrace ()\n-> IO ()\nrunEmulatorTraceIO' tcfg cfg trace\n= runPrintEffect (outputHandle tcfg) $ runEmulatorTraceEff tcfg cfg trace\n")),(0,i.kt)("p",null,"It also takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"TraceConfig"),", which has two fields."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data TraceConfig = TraceConfig\n{ showEvent    :: EmulatorEvent' -> Maybe String\n-- ^ Function to decide how to print the particular events.\n, outputHandle :: Handle\n-- ^ Where to print the outputs to. Default: 'System.IO.stdout'\n}\n")),(0,i.kt)("p",null,"The first field, ",(0,i.kt)("inlineCode",{parentName:"p"},"showEvent")," is a function that specifies which\n",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorEvent"),"s are displayed and how they are displayed. It takes an\n",(0,i.kt)("inlineCode",{parentName:"p"},"EmulatorEvent")," as an argument and can return ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing")," it the event\nshould not be displayed, or a ",(0,i.kt)("inlineCode",{parentName:"p"},"Just")," with a ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," showing how the\nevent will be displayed."),(0,i.kt)("p",null,"Here is the default ",(0,i.kt)("inlineCode",{parentName:"p"},"TraceConfig")," used by ",(0,i.kt)("inlineCode",{parentName:"p"},"runEmulatorTraceIO"),". We can\nsee that most events are ignored and that we only get output for some of\nthe events."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'instance Default TraceConfig where\ndef = TraceConfig\n            { showEvent     = defaultShowEvent\n            , outputHandle  = stdout\n            }\n\ndefaultShowEvent :: EmulatorEvent\' -> Maybe String\ndefaultShowEvent = \\case\nUserThreadEvent (UserLog msg)                                        -> Just $ "*** USER LOG: " <> msg\nInstanceEvent (ContractInstanceLog (ContractLog (A.String msg)) _ _) -> Just $ "*** CONTRACT LOG: " <> show msg\nInstanceEvent (ContractInstanceLog (StoppedWithError err)       _ _) -> Just $ "*** CONTRACT STOPPED WITH ERROR: " <> show err\nInstanceEvent (ContractInstanceLog NoRequestsHandled            _ _) -> Nothing\nInstanceEvent (ContractInstanceLog (HandledRequest _)           _ _) -> Nothing\nInstanceEvent (ContractInstanceLog (CurrentRequests _)          _ _) -> Nothing\nSchedulerEvent _                                                     -> Nothing\nChainIndexEvent _ _                                                  -> Nothing\nWalletEvent _ _                                                      -> Nothing\nev                                                                   -> Just . renderString . layoutPretty defaultLayoutOptions . pretty $ ev\n')),(0,i.kt)("p",null,"The second field is a handle which defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"stdout"),", but we could\nalso specify a file here."),(0,i.kt)("p",null,"Now let\\'s look at a more interesting trace, using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Vesting"),"\ncontract from the last lecture."),(0,i.kt)("p",null,"First, we define a ",(0,i.kt)("inlineCode",{parentName:"p"},"Trace"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myTrace :: EmulatorTrace ()\nmyTrace = do\nh1 <- activateContractWallet (Wallet 1) endpoints\nh2 <- activateContractWallet (Wallet 2) endpoints\ncallEndpoint @"give" h1 $ GiveParams\n      { gpBeneficiary = pubKeyHash $ walletPubKey $ Wallet 2\n      , gpDeadline    = Slot 20\n      , gpAmount      = 1000\n      }\nvoid $ waitUntilSlot 20\ncallEndpoint @"grab" h2 ()\nvoid $ waitNSlots 1\n')),(0,i.kt)("p",null,"The first thing we have to do is to activate the wallets using the\nmonadic function ",(0,i.kt)("inlineCode",{parentName:"p"},"activateContractWallet"),". We bind the result of this\nfunction to ",(0,i.kt)("inlineCode",{parentName:"p"},"h1"),", and then bind the result of a second call (for Wallet\n2) to ",(0,i.kt)("inlineCode",{parentName:"p"},"h2"),". Those two values - ",(0,i.kt)("inlineCode",{parentName:"p"},"h1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"h2")," are handles to their\nrespective wallets."),(0,i.kt)("p",null,"Next, we use ",(0,i.kt)("inlineCode",{parentName:"p"},"callEndpoint")," to simulate Wallet 1 calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"give"),"\nendpoint, with the shown parameters. We then wait for 20 slots. The\nfunction ",(0,i.kt)("inlineCode",{parentName:"p"},"waitUntilSlot")," actually returns a value representing the slot\nthat was reached, but, as we are not interested in that value here, we\nuse ",(0,i.kt)("inlineCode",{parentName:"p"},"void")," to ignore it. We then simulate the call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"grab"),"\nendpoint by Wallet 2."),(0,i.kt)("p",null,"Now, we can write a function to call ",(0,i.kt)("inlineCode",{parentName:"p"},"runEmulatorTraceIO")," with out\n",(0,i.kt)("inlineCode",{parentName:"p"},"Trace"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"test :: IO ()\ntest = runEmulatorTraceIO myTrace\n")),(0,i.kt)("p",null,"And, we can then run this in the REPL:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.}"},'Slot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Contract instance started\nSlot 00001: 00000000-0000-4000-8000-000000000001 {Contract instance for wallet 2}:\n  Contract instance started\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Receive endpoint call: Object (fromList [("tag",String "give"),("value",Object (fromList [("unEndpointValue",Object (fromList [("gpAmount",Number 1000.0),("gpBeneficiary",Object (fromList [("getPubKeyHash",String "39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f")])),("gpDeadline",Object (fromList [("getSlot",Number 20.0)]))]))]))])\nSlot 00001: W1: TxSubmit: 49f326a21c09ba52eddee46b65bdb5fb33b3444745e9af1510a68f9043696eba\nSlot 00001: TxnValidate 49f326a21c09ba52eddee46b65bdb5fb33b3444745e9af1510a68f9043696eba\nSlot 00001: SlotAdd Slot 2\nSlot 00002: *** CONTRACT LOG: "made a gift of 1000 lovelace to 39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f with deadline Slot {getSlot = 20}"\nSlot 00002: SlotAdd Slot 3\nSlot 00003: SlotAdd Slot 4\nSlot 00004: SlotAdd Slot 5\nSlot 00005: SlotAdd Slot 6\nSlot 00006: SlotAdd Slot 7\nSlot 00007: SlotAdd Slot 8\nSlot 00008: SlotAdd Slot 9\nSlot 00009: SlotAdd Slot 10\nSlot 00010: SlotAdd Slot 11\nSlot 00011: SlotAdd Slot 12\nSlot 00012: SlotAdd Slot 13\nSlot 00013: SlotAdd Slot 14\nSlot 00014: SlotAdd Slot 15\nSlot 00015: SlotAdd Slot 16\nSlot 00016: SlotAdd Slot 17\nSlot 00017: SlotAdd Slot 18\nSlot 00018: SlotAdd Slot 19\nSlot 00019: SlotAdd Slot 20\nSlot 00020: 00000000-0000-4000-8000-000000000001 {Contract instance for wallet 2}:\n  Receive endpoint call: Object (fromList [("tag",String "grab"),("value",Object (fromList [("unEndpointValue",Array [])]))])\nSlot 00020: W2: TxSubmit: d9a2028384b4472242371f27cb51727f5c7c04327972e4278d1f69f606019a8b\nSlot 00020: TxnValidate d9a2028384b4472242371f27cb51727f5c7c04327972e4278d1f69f606019a8b\nSlot 00020: SlotAdd Slot 21\nSlot 00021: *** CONTRACT LOG: "collected gifts"\nSlot 00021: SlotAdd Slot 22\nFinal balances\nWallet 1: \n    {, ""}: 99998990\nWallet 2: \n    {, ""}: 100000990\nWallet 3: \n    {, ""}: 100000000\nWallet 4: \n    {, ""}: 100000000\nWallet 5: \n    {, ""}: 100000000\nWallet 6: \n    {, ""}: 100000000\nWallet 7: \n    {, ""}: 100000000\nWallet 8: \n    {, ""}: 100000000\nWallet 9: \n    {, ""}: 100000000\nWallet 10: \n    {, ""}: 100000000\n')),(0,i.kt)("p",null,"This output is very similar to the output we see in the playground. We\ncan see the Genesis transaction as well as both the ",(0,i.kt)("inlineCode",{parentName:"p"},"give")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"grab"),"\ntransactions from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Trace"),". We can also see some log output from the\ncontract itself, prefixed with ",(0,i.kt)("inlineCode",{parentName:"p"},"CONTRACT LOG"),"."),(0,i.kt)("p",null,"We can also log from inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"Trace")," monad. We could, for example,\nlof the result of the final ",(0,i.kt)("inlineCode",{parentName:"p"},"waitNSlots")," call:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myTrace :: EmulatorTrace ()\nmyTrace = do\n...\n...\ns <- waitNSlots 1\nExtras.logInfo $ "reached slot " ++ show s\n')),(0,i.kt)("p",null,"We would then see this output when we run the emulation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.}"},'...\nSlot 00020: SlotAdd Slot 21\nSlot 00021: *** USER LOG: reached slot Slot {getSlot = 21}\nSlot 00021: *** CONTRACT LOG: "collected gifts"\nSlot 00021: SlotAdd Slot 22\n...\n')),(0,i.kt)("p",null,"Now let\\'s look at the Contract Monad."),(0,i.kt)("h3",{id:"the-contract-monad"},"The Contract Monad"),(0,i.kt)("p",null,"The purpose of the Contract Monad is to define off-chain code that runs\nin the wallet. It has four type parameters:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"newtype Contract w s e a = Contract { unContract :: Eff (ContractEffs w s e) a }\n      deriving newtype (Functor, Applicative, Monad)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is the same as in every Monad - it denotes the result type of\nthe computation."),(0,i.kt)("p",null,"We will go into the other three in more detail later but just briefly:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"w is like our Writer monad example, it allows us to write log\nmessages of type ",(0,i.kt)("inlineCode",{parentName:"li"},"w"),"."),(0,i.kt)("li",{parentName:"ul"},"s describes the blockchain capabilities, e.g. waiting for a slot,\nsubmitting transactions, getting the wallet\\'s public key. It can\nalso contain specific endpoints."),(0,i.kt)("li",{parentName:"ul"},"e describes the type of error messages that this monad can throw.")),(0,i.kt)("p",null,"Let\\'s write an example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myContract1 :: Contract () BlockchainActions Text ()\nmyContract1 = Contract.logInfo @String "Hello from the contract!"\n')),(0,i.kt)("p",null,"Here, we pass a ",(0,i.kt)("inlineCode",{parentName:"p"},"Contract")," constructed with ",(0,i.kt)("inlineCode",{parentName:"p"},"Unit")," as the ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," type and\n",(0,i.kt)("inlineCode",{parentName:"p"},"BlockchainActions")," as the second argument, ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),". This gives us access to\nall the blockchain actions - the only thing we can\\'t do is to call\nspecific endpoints."),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," - the error message type, we use ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," is a Haskell\ntype which is like ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),", but it is much more efficient."),(0,i.kt)("p",null,"We don\\'t want a specific result, so we use ",(0,i.kt)("inlineCode",{parentName:"p"},"Unit")," for the type ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),"."),(0,i.kt)("p",null,"For the function body, we write a log message. We use ",(0,i.kt)("inlineCode",{parentName:"p"},"\\@String"),"\nbecause, we have imported the type ",(0,i.kt)("inlineCode",{parentName:"p"},"Data.Text")," and we have used the\n",(0,i.kt)("inlineCode",{parentName:"p"},"OverloadedStrings")," GHC compiler option, so the compiler needs to know\nwhat type we are referencing - a ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),". We can use\n",(0,i.kt)("inlineCode",{parentName:"p"},"\\@String")," if we also use the compiler option ",(0,i.kt)("inlineCode",{parentName:"p"},"TypeApplications"),"."),(0,i.kt)("p",null,"Let\\'s now define a ",(0,i.kt)("inlineCode",{parentName:"p"},"Trace")," that starts the contract in the wallet, and\na ",(0,i.kt)("inlineCode",{parentName:"p"},"test")," function to run it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"myTrace1 :: EmulatorTrace ()\nmyTrace1 = void $ activateContractWallet (Wallet 1) myContract1\n\ntest1 :: IO ()\ntest1 = runEmulatorTraceIO myTrace1\n")),(0,i.kt)("p",null,"If we run this in the REPL, we will see our log message from the\ncontract."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.Prelude",metastring:"Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test1","Plutus.Trace.Emulator":!0,"Plutus.Contract.Trace":!0,"Wallet.Emulator":!0,"Week04.Trace":!0,"Wallet.Emulator.Stream":!0,"Week04.Contract>":!0,test1:!0},'Slot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract instance started\nSlot 00001: *** CONTRACT LOG: \\"Hello from the contract!\\"\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract instance stopped (no errors)\nSlot 00001: SlotAdd Slot 2\nFinal balances\nWallet 1: \n{, \\"\\"}: 100000000\nWallet 2: \n{, \\"\\"}: 100000000\nWallet 3: \n{, \\"\\"}: 100000000\nWallet 4: \n{, \\"\\"}: 100000000\nWallet 5: \n{, \\"\\"}: 100000000\nWallet 6: \n{, \\"\\"}: 100000000\nWallet 7: \n{, \\"\\"}: 100000000\nWallet 8: \n{, \\"\\"}: 100000000\nWallet 9: \n{, \\"\\"}: 100000000\nWallet 10: \n{, \\"\\"}: 100000000}\n')),(0,i.kt)("p",null,"Now, let\\'s throw an exception."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myContract1 :: Contract () BlockchainActions Text ()\nmyContract1 = do\nvoid $ Contract.throwError "BOOM!"\nContract.logInfo @String "Hello from the contract!"\n')),(0,i.kt)("p",null,"Recall that we chose the type ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," as the error message."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test1\nSlot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract instance started\nSlot 00001: *** CONTRACT STOPPED WITH ERROR: "\\"BOOM!\\""\nSlot 00001: SlotAdd Slot 2\nFinal balances\nWallet 1: \n{, ""}: 100000000\nWallet 2: \n{, ""}: 100000000\nWallet 3: \n{, ""}: 100000000\nWallet 4: \n{, ""}: 100000000\nWallet 5: \n{, ""}: 100000000\nWallet 6: \n{, ""}: 100000000\nWallet 7: \n{, ""}: 100000000\nWallet 8: \n{, ""}: 100000000\nWallet 9: \n{, ""}: 100000000\nWallet 10: \n{, ""}: 100000000\n')),(0,i.kt)("p",null,"Now, we don\\'t get the log message, but we do get told that the contract\nstopped with an error and we see our exception message."),(0,i.kt)("p",null,"Another thing you can do is to handle exceptions. We will use the\n",(0,i.kt)("inlineCode",{parentName:"p"},"handleError")," function from module ",(0,i.kt)("inlineCode",{parentName:"p"},"Plutus.Contract.Types"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"handleError ::\n      forall w s e e' a.\n      (e -> Contract w s e' a)\n      -> Contract w s e a\n      -> Contract w s e' a\nhandleError f (Contract c) = Contract c' where\n      c' = E.handleError @e (raiseUnderN @'[E.Error e'] c) (fmap unContract f)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"handleError")," function takes an error handler and a ",(0,i.kt)("inlineCode",{parentName:"p"},"Contract"),"\ninstance. The error handler takes an argument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," from our\ncontract, and returns a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Contract")," with the same type parameters as\nthe first, but we can change the type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," argument - the error\ntype, which is expressed in the return ",(0,i.kt)("inlineCode",{parentName:"p"},"Contract")," argument list as\n",(0,i.kt)("inlineCode",{parentName:"p"},"e\\'"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myContract2 :: Contract () BlockchainActions Void ()\nmyContract2 = Contract.handleError\n      (\\err -> Contract.logError $ "Caught error: " ++ unpack err)\n      myContract1\n\nmyTrace2 :: EmulatorTrace ()\nmyTrace2 = void $ activateContractWallet (Wallet 1) myContract2\n\ntest2 :: IO ()\ntest2 = runEmulatorTraceIO myTrace2\n')),(0,i.kt)("p",null,"We use the type ",(0,i.kt)("inlineCode",{parentName:"p"},"Void")," as the error type. ",(0,i.kt)("inlineCode",{parentName:"p"},"Void")," is a type that can hold\nno value, so, by using this type we are saying that there cannot be any\nerrors for this contract."),(0,i.kt)("p",null,"::: {.note}\n::: {.title}\nNote\n:::"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"unpack")," is defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Data.Text")," module. It converts\na value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," to a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),".\n:::"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test2\nSlot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract instance started\nSlot 00001: *** CONTRACT LOG: "Caught error: BOOM!"\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract instance stopped (no errors)\nSlot 00001: SlotAdd Slot 2\nFinal balances\n...\n')),(0,i.kt)("p",null,'We no longer get the error message, but, instead we get a message from\nthe error handler showing the exception that was thrown by Contract1.\nNote that we still do not get the message \\"Hello from the contract!\\".\nContract 1 still stopped processing after its error, but there was no\noverall contract error due to the exception being caught and handled.'),(0,i.kt)("p",null,"Of course, exceptions can also happen even if they are not explicitly\nthrown by your contract code. There are operations, such as submitting a\ntransaction where there are insufficient inputs to make a payment for an\noutput, where Plutus will throw an exception."),(0,i.kt)("p",null,"Next, let\\'s look at the ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," parameter, the second parameter to\n",(0,i.kt)("inlineCode",{parentName:"p"},"Contract"),", that determines the available blockchain actions."),(0,i.kt)("p",null,"In the first two examples we just used the ",(0,i.kt)("inlineCode",{parentName:"p"},"BlockChainActions")," type\nwhich has all the standard functionality but without support for\nspecific endpoints. If we want support for specific endpoints, we must\nuse a different type."),(0,i.kt)("p",null,"The way that is usually done is by using a type synonym. The following\nexample will create a type synonym ",(0,i.kt)("inlineCode",{parentName:"p"},"MySchema")," that has all the\ncapabilities of ",(0,i.kt)("inlineCode",{parentName:"p"},"BlockChainActions")," but with the addition of being able\nto call endpoint ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," with an argument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'type MySchema = BlockchainActions .\\/ Endpoint "foo" Int\n')),(0,i.kt)("p",null,"::: {.note}\n::: {.title}\nNote\n:::"),(0,i.kt)("p",null,"The operator ",(0,i.kt)("inlineCode",{parentName:"p"},".\\\\/")," is a type operator - it operates on types, not\nvalues. In order to use this we need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"TypeOperators")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"DataKinds")," compiler options.\n:::"),(0,i.kt)("p",null,"Now, we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"MySchema")," type to define our contract."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myContract3 :: Contract () MySchema Text ()\nmyContract3 = do\n      n <- endpoint @"foo"\n      Contract.logInfo n\n')),(0,i.kt)("p",null,"This contract will block until the endpoint ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," is called with, in our\ncase, an ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),". Then the value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Int")," parameter will be bound to\n",(0,i.kt)("inlineCode",{parentName:"p"},"n"),". Because of this, it is no longer enough for us to just activate the\ncontract to test it. Now, we must invoke the endpoint as well."),(0,i.kt)("p",null,"In order to do this, we now need to handle from\n",(0,i.kt)("inlineCode",{parentName:"p"},"activateContractWallet"),", which we can then use to call the endpoint."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myTrace3 :: EmulatorTrace ()\nmyTrace3 = do\n      h <- activateContractWallet (Wallet 1) myContract3\n      callEndpoint @"foo" h 42\n\ntest3 :: IO ()\ntest3 = runEmulatorTraceIO myTrace3\n')),(0,i.kt)("p",null,"Running this in the REPL:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test3\nSlot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\n...\nReceive endpoint call: Object (fromList [("tag",String "foo"),("value",Object (fromList [("unEndpointValue",Number 42.0)]))])\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract log: Number 42.0\n...\nFinal balances\n...\nWallet 10: \n{, ""}: 100000000\n')),(0,i.kt)("p",null,"Finally, let\\'s look at the first type parameter, the writer. The ",(0,i.kt)("inlineCode",{parentName:"p"},"w"),"\ncannot be an arbitrary type, it must be an instance of the type class\n",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> :i Monoid\ntype Monoid :: ` -> Constraint\nclass Semigroup a => Monoid a where\nmempty :: a\nmappend :: a -> a -> a\nmconcat :: [a] -> a\n{-# MINIMAL mempty #-}\n      -- Defined in \u2018GHC.Base\u2019\ninstance Monoid [a] -- Defined in \u2018GHC.Base\u2019\ninstance Monoid Ordering -- Defined in \u2018GHC.Base\u2019\ninstance Semigroup a => Monoid (Maybe a) -- Defined in \u2018GHC.Base\u2019\ninstance Monoid a => Monoid (IO a) -- Defined in \u2018GHC.Base\u2019\ninstance Monoid b => Monoid (a -> b) -- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>\n      Monoid (a, b, c, d, e)\n-- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b, Monoid c, Monoid d) =>\n      Monoid (a, b, c, d)\n-- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)\n-- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b) => Monoid (a, b)\n-- Defined in \u2018GHC.Base\u2019\ninstance Monoid () -- Defined in \u2018GHC.Base\u2019\n")),(0,i.kt)("p",null,"This is a very important and very common type class in Haskell. It\ndefines ",(0,i.kt)("inlineCode",{parentName:"p"},"mempty")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"mappend"),"."),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"mempty")," is like the neutral element, and ",(0,i.kt)("inlineCode",{parentName:"p"},"mappend"),"\ncombines two elements of this type to create a new element of the same\ntype."),(0,i.kt)("p",null,"The prime example of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"List"),", when ",(0,i.kt)("inlineCode",{parentName:"p"},"mempty")," is the empty\nlist ",(0,i.kt)("inlineCode",{parentName:"p"},"\\[\\]"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"mappend")," is concatenation ",(0,i.kt)("inlineCode",{parentName:"p"},"++"),"."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude> mempty :: [Int]\n[]\nPrelude> mappend [1, 2, 3 :: Int] [4, 5, 6]\n[1,2,3,4,5,6]\n")),(0,i.kt)("p",null,"The are many, many other examples of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," type, and we will see\nother instances in this course."),(0,i.kt)("p",null,"But for now, let\\'s stick with lists and write our last example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"myContract4 :: Contract [Int] BlockchainActions Text ()\nmyContract4 = do\n    void $ Contract.waitNSlots 10\n    tell [1]\n    void $ Contract.waitNSlots 10\n    tell [2]\n    void $ Contract.waitNSlots 10\n")),(0,i.kt)("p",null,"Rather than using ",(0,i.kt)("inlineCode",{parentName:"p"},"Unit")," as our ",(0,i.kt)("inlineCode",{parentName:"p"},"w")," type, we are using ",(0,i.kt)("inlineCode",{parentName:"p"},"\\[Int\\]"),". This\nallows us to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"tell")," function as shown."),(0,i.kt)("p",null,"This now gives us access to those messages during the trace, using the\n",(0,i.kt)("inlineCode",{parentName:"p"},"observableState")," function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"myTrace4 :: EmulatorTrace ()\nmyTrace4 = do\n    h <- activateContractWallet (Wallet 1) myContract4\n\n    void $ Emulator.waitNSlots 5\n    xs <- observableState h\n    Extras.logInfo $ show xs\n\n    void $ Emulator.waitNSlots 10\n    ys <- observableState h\n    Extras.logInfo $ show ys\n\n    void $ Emulator.waitNSlots 10\n    zs <- observableState h\n    Extras.logInfo $ show zs\n\ntest4 :: IO ()\ntest4 = runEmulatorTraceIO myTrace4\n")),(0,i.kt)("p",null,"If we run this in the REPL, we can see the ",(0,i.kt)("inlineCode",{parentName:"p"},"USER LOG")," messages created\nusing the ",(0,i.kt)("inlineCode",{parentName:"p"},"tell")," function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-{.}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test4\nSlot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Contract instance started\nSlot 00001: SlotAdd Slot 2\n...\nSlot 00005: SlotAdd Slot 6\nSlot 00006: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Sending contract state to Thread 0\nSlot 00006: SlotAdd Slot 7\nSlot 00007: *** USER LOG: []\nSlot 00007: SlotAdd Slot 8\n...\nSlot 00015: SlotAdd Slot 16\nSlot 00016: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Sending contract state to Thread 0\nSlot 00016: SlotAdd Slot 17\nSlot 00017: *** USER LOG: [1]\nSlot 00017: SlotAdd Slot 18\n...\nSlot 00025: SlotAdd Slot 26\nSlot 00026: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Sending contract state to Thread 0\nSlot 00026: SlotAdd Slot 27\nSlot 00027: *** USER LOG: [1,2]\nFinal balances\nWallet 1: \n    {, ""}: 100000000\nWallet 2: \n    {, ""}: 100000000\n...\nWallet 10: \n    {, ""}: 100000000\n')),(0,i.kt)("p",null,"Using this mechanism, it is possible to pass information from the\ncontract running in the wallet to the outside world. Using endpoints we\ncan pass information into a contract. And using the ",(0,i.kt)("inlineCode",{parentName:"p"},"tell")," mechanism we\ncan get information out of the wallet."))}s.isMDXComponent=!0}}]);
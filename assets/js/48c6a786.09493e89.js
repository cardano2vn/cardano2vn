"use strict";(self.webpackChunkbringscdocs=self.webpackChunkbringscdocs||[]).push([[2670],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return u}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),h=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=h(e.components);return a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=h(t),u=i,g=c["".concat(s,".").concat(u)]||c[u]||d[u]||l;return t?a.createElement(g,r(r({ref:n},p),{},{components:t})):a.createElement(g,r({ref:n},p))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,r=new Array(l);r[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var h=2;h<l;h++)r[h]=t[h];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},707:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},metadata:function(){return s},toc:function(){return h},default:function(){return d}});var a=t(7462),i=t(3366),l=(t(7294),t(3905)),r=["components"],o={},s={unversionedId:"dr-lars-lession/week3",id:"dr-lars-lession/week3",isDocsHomePage:!1,title:"Week 03 - Script Context",description:"Note",source:"@site/docs/dr-lars-lession/week3.md",sourceDirName:"dr-lars-lession",slug:"/dr-lars-lession/week3",permalink:"/docs/dr-lars-lession/week3",editUrl:"https://github.com/cardano2vn/cardanovn-portal/edit/main/docs/dr-lars-lession/week3.md",version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"Week 02 - Validation",permalink:"/docs/dr-lars-lession/week2"},next:{title:"Week 04 - Monads",permalink:"/docs/dr-lars-lession/week4"}},h=[{value:"Tr\u01b0\u1edbc khi ch\xfang ta b\u1eaft \u0111\u1ea7u",id:"tr\u01b0\u1edbc-khi-ch\xfang-ta-b\u1eaft-\u0111\u1ea7u",children:[]},{value:"T\xf3m t\u1eaft l\u1ea1i",id:"t\xf3m-t\u1eaft-l\u1ea1i",children:[]},{value:"ScriptContext",id:"scriptcontext",children:[{value:"txInfoValidRange",id:"txinfovalidrange",children:[]},{value:"POSIXTimeRange",id:"posixtimerange",children:[]}]},{value:"Example - Vesting",id:"example---vesting",children:[{value:"In the playground",id:"in-the-playground",children:[]}]},{value:"Example 2 - Parameterized Contract",id:"example-2---parameterized-contract",children:[{value:"On-Chain",id:"on-chain",children:[]},{value:"Off-Chain",id:"off-chain",children:[]},{value:"Back to the playground",id:"back-to-the-playground",children:[]}]}],p={toc:h};function d(e){var n=e.components,o=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,a.Z)({},p,o,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"::: {.note}\n::: {.title}\nNote\n:::"),(0,l.kt)("p",null,"\u0110\xe2y l\xe0 phi\xean b\u1ea3n \u0111\xe3 d\u1ecbch c\u1ee7a ",(0,l.kt)("a",{parentName:"p",href:"https://youtu.be/WG3uw-TkW2k"},"B\xe0i gi\u1ea3ng s\u1ed1 3 Dr. Lars"),"."),(0,l.kt)("p",null,"Trong b\xe0i gi\u1ea3ng n\xe0y, ch\xfang ta t\xecm hi\u1ec3u v\u1ec1 context script (\u0111\u1ed1i s\u1ed1 x\xe1c th\u1ef1c th\u1ee9 ba), th\u1eddi gian x\u1eed l\xfd v\xe0 c\xe1c h\u1ee3p \u0111\u1ed3ng \u0111\u01b0\u1ee3c tham s\u1ed1 h\xf3a."),(0,l.kt)("p",null,"\u0110o\u1ea1n m\xe3 trong b\xe0i gi\u1ea3ng n\xe0y s\u1eed d\u1ee5ng Plutus commit l\xe0 ",(0,l.kt)("inlineCode",{parentName:"p"},"81ba78edb1d634a13371397d8c8b19829345ce0d"),"."),(0,l.kt)("h2",{id:"tr\u01b0\u1edbc-khi-ch\xfang-ta-b\u1eaft-\u0111\u1ea7u"},"Tr\u01b0\u1edbc khi ch\xfang ta b\u1eaft \u0111\u1ea7u"),(0,l.kt)("p",null,"K\u1ec3 t\u1eeb b\xe0i gi\u1ea3ng cu\u1ed1i c\xf9ng \u0111\xe3 c\xf3 m\u1ed9t b\u1ea3n c\u1eadp nh\u1eadt cho s\xe2n ch\u01a1i, c\xf3 trong b\u1ea3n cam k\u1ebft Plutus m\xe0 ch\xfang t\xf4i \u0111ang s\u1eed d\u1ee5ng cho b\xe0i gi\u1ea3ng n\xe0y (xem ghi ch\xfa \u1edf tr\xean)."),(0,l.kt)("p",null,"\u0110\xe3 x\u1ea3y ra s\u1ef1 c\u1ed1 khi th\u1eddi gian ch\u1edd \u0111\u01b0\u1ee3c m\xe3 h\xf3a c\u1ee9ng v\xe0o s\xe2n ch\u01a1i qu\xe1 ng\u1eafn. \u0110i\u1ec1u n\xe0y s\u1ebd khi\u1ebfn m\xf4 ph\u1ecfng kh\xf4ng th\xe0nh c\xf4ng n\u1ebfu ch\xfang m\u1ea5t nhi\u1ec1u th\u1eddi gian h\u01a1n th\u1eddi gian ch\u1edd m\xe3 c\u1ee9ng."),(0,l.kt)("p",null,"B\xe2y gi\u1edd c\xf3 m\u1ed9t t\xf9y ch\u1ecdn khi b\u1ea1n kh\u1edfi \u0111\u1ed9ng M\xe1y ch\u1ee7 s\xe2n ch\u01a1i Plutus cho ph\xe9p b\u1ea1n ch\u1ec9 \u0111\u1ecbnh th\u1eddi gian ch\u1edd. V\xed d\u1ee5 sau \u0111\u1eb7t th\u1eddi gian ch\u1edd th\xe0nh 120 gi\xe2y."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.}"},"plutus-playground-server -i 120s\n")),(0,l.kt)("h2",{id:"t\xf3m-t\u1eaft-l\u1ea1i"},"T\xf3m t\u1eaft l\u1ea1i"),(0,l.kt)("p",null,"Khi ch\xfang t\xf4i \u0111\xe3 gi\u1ea3i th\xedch (E) UTxO m\xf4 h\xecnh trong b\xe0i gi\u1ea3ng \u0111\u1ea7u ti\xean, ch\xfang t\xf4i \u0111\u1ec1 c\u1eadp r\u1eb1ng \u0111\u1ec3 m\u1edf kh\xf3a m\u1ed9t \u0111\u1ecba ch\u1ec9 k\u1ecbch b\u1ea3n, k\u1ecbch b\u1ea3n g\u1eafn li\u1ec1n v\u1edbi \u0111\u1ecba ch\u1ec9 \u0111\u01b0\u1ee3c ch\u1ea1y, v\xe0 k\u1ecbch b\u1ea3n m\xe0 \u0111\u01b0\u1ee3c ba m\u1ea9u th\xf4ng tin -\n",(0,l.kt)("em",{parentName:"p"},"datum"),",  ",(0,l.kt)("em",{parentName:"p"},"redeemer")," v\xe0 ",(0,l.kt)("em",{parentName:"p"},"context"),"."),(0,l.kt)("p",null,"Trong b\xe0i gi\u1ea3ng th\u1ee9 hai, ch\xfang ta \u0111\xe3 xem c\xe1c v\xed d\u1ee5 v\u1ec1 \u0111i\u1ec1u \u0111\xf3 v\xe0 ch\xfang ta \u0111\xe3 th\u1ea5y n\xf3 th\u1ef1c s\u1ef1 ho\u1ea1t \u0111\u1ed9ng nh\u01b0 th\u1ebf n\xe0o trong Haskell."),(0,l.kt)("p",null,"Ch\xfang t\xf4i \u0111\xe3 th\u1ea5y vi\u1ec7c tri\u1ec3n khai c\u1ea5p th\u1ea5p, trong \u0111\xf3 c\u1ea3 ba \u0111\u1ed1i s\u1ed1 \u0111\u1ec1u \u0111\u01b0\u1ee3c bi\u1ec3u th\u1ecb b\u1eb1ng ki\u1ec3u ",(0,l.kt)("inlineCode",{parentName:"p"},"Data"),". Ch\xfang t\xf4i c\u0169ng th\u1ea5y r\u1eb1ng trong th\u1ef1c t\u1ebf \u0111i\u1ec1u n\xe0y kh\xf4ng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng."),(0,l.kt)("p",null,"Thay v\xe0o \u0111\xf3, ch\xfang t\xf4i s\u1eed d\u1ee5ng phi\xean b\u1ea3n \u0111\xe3 nh\u1eadp, trong \u0111\xf3 d\u1eef li\u1ec7u v\xe0 c\xf4ng c\u1ee5 \u0111\u1ed5i c\xf3 th\u1ec3 l\xe0 ki\u1ec3u t\xf9y ch\u1ec9nh (mi\u1ec5n l\xe0 ch\xfang tri\u1ec3n khai l\u1edbp ki\u1ec3u ",(0,l.kt)("inlineCode",{parentName:"p"},"IsData"),") v\xe0 trong \u0111\xf3 \u0111\u1ed1i s\u1ed1 th\u1ee9 ba l\xe0 ki\u1ec3u ",(0,l.kt)("inlineCode",{parentName:"p"},"ScriptContext"),"."),(0,l.kt)("p",null,"Trong c\xe1c v\xed d\u1ee5 m\xe0 ch\xfang t\xf4i \u0111\xe3 th\u1ea5y cho \u0111\u1ebfn nay, ch\xfang t\xf4i \u0111\xe3 xem x\xe9t d\u1eef li\u1ec7u v\xe0 c\xf4ng c\u1ee5 \u0111\u1ed5i, nh\u01b0ng ch\xfang t\xf4i lu\xf4n b\u1ecf qua ng\u1eef c\u1ea3nh. Nh\u01b0ng b\u1ed1i c\u1ea3nh, t\u1ea5t nhi\xean, r\u1ea5t quan tr\u1ecdng. V\xec v\u1eady, trong b\xe0i gi\u1ea3ng n\xe0y, ch\xfang ta s\u1ebd b\u1eaft \u0111\u1ea7u xem x\xe9t context."),(0,l.kt)("h2",{id:"scriptcontext"},"ScriptContext"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"ScriptContext")," \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong g\xf3i ",(0,l.kt)("inlineCode",{parentName:"p"},"plutus-ledger-api"),", m\xe0 l\xe0 m\u1ed9t g\xf3i ph\u1ea7n m\u1ec1m \u0111\xf3, cho \u0111\u1ebfn b\xe2y gi\u1edd, ch\xfang t\xf4i \u0111\xe3 kh\xf4ng c\u1ea7n thi\u1ebft. Nh\u01b0ng b\xe2y gi\u1edd ch\xfang t\xf4i c\u1ea7n n\xf3, v\xe0 n\xf3 \u0111\xe3 \u0111\u01b0\u1ee3c \u0111\u01b0a v\xe0o files ",(0,l.kt)("inlineCode",{parentName:"p"},".cabal")," c\u1ee7a tu\u1ea7n n\xe0y . N\xf3 \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong m\xf4-\u0111un ",(0,l.kt)("inlineCode",{parentName:"p"},"Plutus.V1.Ledger.Contexts"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data ScriptContext = ScriptContext { \n            scriptContextTxInfo :: TxInfo, \n            scriptContextPurpose :: ScriptPurpose \n      }\n")),(0,l.kt)("p",null,"N\xf3 l\xe0 m\u1ed9t lo\u1ea1i b\u1ea3n ghi c\xf3 hai tr\u01b0\u1eddng."),(0,l.kt)("p",null,"Tr\u01b0\u1eddng th\u1ee9 hai thu\u1ed9c lo\u1ea1i ",(0,l.kt)("inlineCode",{parentName:"p"},"ScriptPurpose"),", \u0111\u01b0\u1ee3c x\xe1c \u0111\u1ecbnh trong c\xf9ng m\u1ed9t m\xf4-\u0111un. N\xf3 x\xe1c \u0111\u1ecbnh m\u1ee5c \u0111\xedch m\xe0 m\u1ed9t t\u1eadp l\u1ec7nh \u0111ang \u0111\u01b0\u1ee3c ch\u1ea1y."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data ScriptPurpose\n   = Minting CurrencySymbol\n   | Spending TxOutRef\n   | Rewarding StakingCredential\n   | Certifying DCert\n")),(0,l.kt)("p",null,"\u0110\u1ed1i v\u1edbi ch\xfang t\xf4i, quan tr\u1ecdng nh\u1ea5t l\xe0 ",(0,l.kt)("inlineCode",{parentName:"p"},"Spending"),". \u0110\xe2y l\xe0 nh\u1eefng g\xec ch\xfang ta \u0111\xe3 n\xf3i cho \u0111\u1ebfn nay trong context c\u1ee7a m\xf4 h\xecnh (E) UTxO. \u0110\xe2y l\xe0 khi m\u1ed9t t\u1eadp l\u1ec7nh \u0111\u01b0\u1ee3c ch\u1ea1y \u0111\u1ec3 x\xe1c th\u1ef1c \u0111\u1ea7u v\xe0o chi ti\xeau cho m\u1ed9t giao d\u1ecbch."),(0,l.kt)("p",null,"C\xe1c ",(0,l.kt)("inlineCode",{parentName:"p"},"Minting")," d\xf9ng khi b\u1ea1n mu\u1ed1n \u0111\u1ecbnh ngh\u0129a m\u1ed9t token g\u1ed1c. M\u1ee5c \u0111\xedch c\u1ee7a n\xf3 l\xe0 ch\xfang t\xf4i m\xf4 t\u1ea3 trong nh\u1eefng tr\u01b0\u1eddng h\u1ee3p n\xe0o token g\u1ed1c c\xf3 th\u1ec3 \u0111\u01b0\u1ee3c \u0111\xfac ho\u1eb7c \u0111\u1ed1t."),(0,l.kt)("p",null,"Ngo\xe0i ra c\xf2n c\xf3 hai m\u1ee5c \u0111\xedch ho\xe0n to\xe0n m\u1edbi -",(0,l.kt)("inlineCode",{parentName:"p"},"Rewarding"),"-  li\xean quan \u0111\u1ebfn \u0111\u1eb7t c\u01b0\u1ee3c v\xe0 ",(0,l.kt)("em",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"em"},"Certifying")),"  li\xean quan \u0111\u1ebfn \u1ee7y quy\u1ec1n c\u1ed5 ph\u1ea7n."),(0,l.kt)("p",null,"Tr\u01b0\u1eddng th\xfa v\u1ecb nh\u1ea5t, tr\u01b0\u1eddng ch\u1ee9a ng\u1eef c\u1ea3nh th\u1ef1c t\u1ebf ",(0,l.kt)("inlineCode",{parentName:"p"},"scriptContextTxInfo")," l\xe0 tr\u01b0\u1eddng thu\u1ed9c lo\u1ea1i ",(0,l.kt)("inlineCode",{parentName:"p"},"TxInfo"),", c\u0169ng \u0111\u01b0\u1ee3c x\xe1c \u0111\u1ecbnh trong c\xf9ng m\u1ed9t m\xf4-\u0111un."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data TxInfo = TxInfo\n   { txInfoInputs      :: [TxInInfo] -- ^ Transaction inputs\n   , txInfoOutputs     :: [TxOut] -- ^ Transaction outputs\n   , txInfoFee         :: Value -- ^ The fee paid by this transaction.\n   , txInfoForge       :: Value -- ^ The 'Value' forged by this transaction.\n   , txInfoDCert       :: [DCert] -- ^ Digests of certificates included in this transaction\n   , txInfoWdrl        :: [(StakingCredential, Integer)] -- ^ Withdrawals\n   , txInfoValidRange  :: SlotRange -- ^ The valid range for the transaction.\n   , txInfoSignatories :: [PubKeyHash] -- ^ Signatures provided with the transaction, attested that they all signed the tx\n   , txInfoData        :: [(DatumHash, Datum)]\n   , txInfoId          :: TxId\n   -- ^ Hash of the pending transaction (excluding witnesses)\n   } deriving (Generic)\n")),(0,l.kt)("p",null,"N\xf3 m\xf4 t\u1ea3 giao d\u1ecbch chi ti\xeau. Trong m\xf4 h\xecnh (E) UTxO, b\u1ed1i c\u1ea3nh x\xe1c th\u1ef1c l\xe0 giao d\u1ecbch chi ti\xeau v\xe0 c\xe1c \u0111\u1ea7u v\xe0o v\xe0 \u0111\u1ea7u ra c\u1ee7a n\xf3. B\u1ed1i c\u1ea3nh n\xe0y \u0111\u01b0\u1ee3c th\u1ec3 hi\u1ec7n trong ",(0,l.kt)("inlineCode",{parentName:"p"},"TxInfo"),"."),(0,l.kt)("p",null,"C\xf3 m\u1ed9t s\u1ed1 tr\u01b0\u1eddng l\xe0 to\xe0n c\u1ea7u cho to\xe0n b\u1ed9 giao d\u1ecbch v\xe0 c\u1ee5 th\u1ec3 l\xe0 ch\xfang t\xf4i c\xf3 danh s\xe1ch t\u1ea5t c\u1ea3 c\xe1c \u0111\u1ea7u v\xe0o ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoInputs")," v\xe0 danh s\xe1ch t\u1ea5t c\u1ea3 c\xe1c \u0111\u1ea7u ra ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoOutputs"),". M\u1ed7i ng\u01b0\u1eddi trong s\u1ed1 h\u1ecd c\xf3 nhi\u1ec1u l\u0129nh v\u1ef1c kh\xe1c nhau \u0111\u1ec3 \u0111i s\xe2u v\xe0o t\u1eebng \u0111\u1ea7u v\xe0o ho\u1eb7c \u0111\u1ea7u ra ri\xeang l\u1ebb."),(0,l.kt)("p",null,"Ch\xfang t\xf4i c\u0169ng th\u1ea5y c\xe1c tr\u01b0\u1eddng v\u1ec1 ph\xed ",(0,l.kt)("inlineCode",{parentName:"p"},"txFee"),", gi\xe1 tr\u1ecb gi\u1ea3 m\u1ea1o ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoForge"),", \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng khi \u0111\xfac ho\u1eb7c \u0111\u1ed1t c\xe1c token g\u1ed1c."),(0,l.kt)("p",null,"Sau \u0111\xf3, ch\xfang t\xf4i c\xf3 m\u1ed9t danh s\xe1ch c\xe1c ch\u1ee9ng ch\u1ec9 \u1ee7y quy\u1ec1n trong ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoDCert")," v\xe0 m\u1ed9t tr\u01b0\u1eddng ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoWdrl")," \u0111\u1ec3 n\u1eafm gi\u1eef th\xf4ng tin v\u1ec1 vi\u1ec7c r\xfat ti\u1ec1n \u0111\u1eb7t c\u01b0\u1ee3c."),(0,l.kt)("p",null,"Tr\u01b0\u1eddng ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoValidRange")," m\xe0 ch\xfang ta s\u1ebd xem x\xe9t chi ti\u1ebft h\u01a1n trong gi\xe2y l\xe1t, x\xe1c \u0111\u1ecbnh ph\u1ea1m vi v\u1ecb tr\xed m\xe0 giao d\u1ecbch n\xe0y h\u1ee3p l\u1ec7."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"txInfoSignatories")," l\xe0 danh s\xe1ch c\xe1c kh\xf3a c\xf4ng khai \u0111\xe3 k\xfd k\u1ebft giao d\u1ecbch n\xe0y."),(0,l.kt)("p",null,"C\xe1c giao d\u1ecbch s\u1eed d\u1ee5ng \u0111\u1ea7u ra t\u1eadp l\u1ec7nh c\u1ea7n ph\u1ea3i bao g\u1ed3m d\u1eef li\u1ec7u c\u1ee7a \u0111\u1ea7u ra t\u1eadp l\u1ec7nh. C\xe1c ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoData")," l\u0129nh v\u1ef1c l\xe0 m\u1ed9t danh s\xe1ch li\xean k\u1ebft datums v\u1edbi b\u0103m t\u01b0\u01a1ng \u1ee9ng c\u1ee7a h\u1ecd. N\u1ebfu c\xf3 m\u1ed9t \u0111\u1ea7u ra giao d\u1ecbch t\u1edbi m\u1ed9t \u0111\u1ecba ch\u1ec9 t\u1eadp l\u1ec7nh mang m\u1ed9t s\u1ed1 d\u1eef li\u1ec7u n\xe0o \u0111\xf3, b\u1ea1n kh\xf4ng c\u1ea7n ph\u1ea3i bao g\u1ed3m d\u1eef li\u1ec7u \u0111\xf3, b\u1ea1n ch\u1ec9 c\xf3 th\u1ec3 bao g\u1ed3m b\u0103m d\u1eef li\u1ec7u. Tuy nhi\xean, c\xe1c t\u1eadp l\u1ec7nh s\u1eed d\u1ee5ng m\u1ed9t \u0111\u1ea7u ra c\u1ea7n ph\u1ea3i bao g\u1ed3m d\u1eef li\u1ec7u, trong tr\u01b0\u1eddng h\u1ee3p \u0111\xf3, n\xf3 s\u1ebd \u0111\u01b0\u1ee3c \u0111\u01b0a v\xe0o danh s\xe1ch ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoData")," ."),(0,l.kt)("p",null,"Cu\u1ed1i c\xf9ng, tr\u01b0\u1eddng ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoId")," l\xe0 ID c\u1ee7a giao d\u1ecbch n\xe0y."),(0,l.kt)("h3",{id:"txinfovalidrange"},"txInfoValidRange"),(0,l.kt)("p",null,"M\u1eb7c d\xf9 c\xf3 r\u1ea5t nhi\u1ec1u th\xf4ng tin ch\u1ee9a trong ki\u1ec3u ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfo"),", nh\u01b0ng \u0111\u1ed1i v\u1edbi v\xed d\u1ee5 \u0111\u1ea7u ti\xean c\u1ee7a ch\xfang t\xf4i v\u1ec1 c\xe1ch s\u1eed d\u1ee5ng \u0111\u1ed1i s\u1ed1 th\u1ee9 ba \u0111\u1ec3 x\xe1c th\u1ef1c, ch\xfang t\xf4i s\u1ebd t\u1eadp trung v\xe0o tr\u01b0\u1eddng ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoValidRange")," n\xe0y."),(0,l.kt)("p",null,"\u0110i\u1ec1u n\xe0y \u0111\u01b0a ch\xfang ta \u0111\u1ebfn m\u1ed9t t\xecnh hu\u1ed1ng kh\xf3 x\u1eed th\xfa v\u1ecb. Ch\xfang t\xf4i \u0111\xe3 nh\u1ea5n m\u1ea1nh nhi\u1ec1u l\u1ea7n r\u1eb1ng l\u1ee3i th\u1ebf l\u1edbn m\xe0 Cardano c\xf3 so v\u1edbi m\u1ed9t th\u1ee9 nh\u01b0 Ethereum l\xe0 vi\u1ec7c x\xe1c th\u1ef1c c\xf3 th\u1ec3 x\u1ea3y ra trong v\xed. Nh\u01b0ng ch\xfang t\xf4i c\u0169ng \u0111\xe3 l\u01b0u \xfd r\u1eb1ng m\u1ed9t giao d\u1ecbch v\u1eabn c\xf3 th\u1ec3 kh\xf4ng th\xe0nh c\xf4ng on-chain sau khi x\xe1c th\u1ef1c, n\u1ebfu khi giao d\u1ecbch tr\xean blockchain, n\xf3 \u0111\xe3 b\u1ecb ng\u01b0\u1eddi kh\xe1c s\u1eed d\u1ee5ng. Trong tr\u01b0\u1eddng h\u1ee3p n\xe0y, giao d\u1ecbch kh\xf4ng th\xe0nh c\xf4ng m\xe0 kh\xf4ng ph\u1ea3i tr\u1ea3 ph\xed."),(0,l.kt)("p",null,"\u0110i\u1ec1u kh\xf4ng bao gi\u1edd n\xean x\u1ea3y ra trong c\xe1c tr\u01b0\u1eddng h\u1ee3p b\xecnh th\u01b0\u1eddng l\xe0 m\u1ed9t t\u1eadp l\u1ec7nh x\xe1c th\u1ef1c ch\u1ea1y v\xe0 sau \u0111\xf3 kh\xf4ng th\xe0nh c\xf4ng. \u0110i\u1ec1u n\xe0y l\xe0 do b\u1ea1n lu\xf4n c\xf3 th\u1ec3 ch\u1ea1y x\xe1c th\u1ef1c trong c\xf9ng m\u1ed9t \u0111i\u1ec1u ki\u1ec7n trong v\xed, v\xec v\u1eady n\xf3 s\u1ebd kh\xf4ng th\xe0nh c\xf4ng tr\u01b0\u1edbc khi b\u1ea1n g\u1eedi n\xf3."),(0,l.kt)("p",null,"V\xec v\u1eady, \u0111\xf3 l\xe0 m\u1ed9t t\xednh n\u0103ng r\u1ea5t hay, nh\u01b0ng kh\xf4ng r\xf5 r\xe0ng l\xe0 l\xe0m th\u1ebf n\xe0o \u0111\u1ec3 qu\u1ea3n l\xfd th\u1eddi gian trong context \u0111\xf3. Th\u1eddi gian r\u1ea5t quan tr\u1ecdng, b\u1edfi v\xec ch\xfang t\xf4i mu\u1ed1n th\u1ec3 hi\u1ec7n r\u1eb1ng m\u1ed9t giao d\u1ecbch nh\u1ea5t \u0111\u1ecbnh ch\u1ec9 c\xf3 hi\u1ec7u l\u1ef1c tr\u01b0\u1edbc ho\u1eb7c ch\u1ec9 c\xf3 hi\u1ec7u l\u1ef1c sau khi \u0111\xe3 \u0111\u1ea1t \u0111\u1ebfn m\u1ed9t th\u1eddi \u0111i\u1ec3m nh\u1ea5t \u0111\u1ecbnh."),(0,l.kt)("p",null,"Ch\xfang ta \u0111\xe3 th\u1ea5y m\u1ed9t v\xed d\u1ee5 v\u1ec1 \u0111i\u1ec1u n\xe0y trong b\xe0i gi\u1ea3ng m\u1ed9t - v\xed d\u1ee5 \u0111\u1ea5u gi\xe1 (bid), trong \u0111\xf3 gi\xe1 th\u1ea7u ch\u1ec9 \u0111\u01b0\u1ee3c ph\xe9p cho \u0111\u1ebfn khi \u0111\u1ea1t \u0111\u1ebfn th\u1eddi h\u1ea1n cu\u1ed1i c\xf9ng v\xe0 ",(0,l.kt)("inlineCode",{parentName:"p"},"close")," ch\u1ec9 khi c\xf3 th\u1ec3 g\u1ecdi ",(0,l.kt)("em",{parentName:"p"},"Endpoint")," sau khi th\u1eddi h\u1ea1n \u0111\xe3 qua."),(0,l.kt)("p",null,"\u0110i\u1ec1u \u0111\xf3 d\u01b0\u1eddng nh\u01b0 l\xe0 m\u1ed9t s\u1ef1 m\xe2u thu\u1eabn, b\u1edfi v\xec th\u1eddi gian r\xf5 r\xe0ng l\xe0 \u0111ang tr\xf4i. V\xec v\u1eady, khi b\u1ea1n c\u1ed1 g\u1eafng x\xe1c th\u1ef1c m\u1ed9t giao d\u1ecbch m\xe0 b\u1ea1n \u0111ang t\u1ea1o trong v\xed c\u1ee7a m\xecnh, t\u1ea5t nhi\xean, th\u1eddi gian b\u1ea1n \u0111ang th\u1ef1c hi\u1ec7n c\xf3 th\u1ec3 kh\xe1c v\u1edbi th\u1eddi gian giao d\u1ecbch \u0111\u1ebfn m\u1ed9t n\xfat \u0111\u1ec3 x\xe1c th\u1ef1c. V\xec v\u1eady, kh\xf4ng r\xf5 l\xe0m th\u1ebf n\xe0o \u0111\u1ec3 k\u1ebft h\u1ee3p hai \u0111i\u1ec1u n\xe0y l\u1ea1i v\u1edbi nhau \u0111\u1ec3 x\xe1c th\u1ef1c l\xe0 x\xe1c \u0111\u1ecbnh v\xe0 \u0111\u1ec3 \u0111\u1ea3m b\u1ea3o r\u1eb1ng n\u1ebfu v\xe0 ch\u1ec9 khi, x\xe1c th\u1ef1c th\xe0nh c\xf4ng trong v\xed, th\xec n\xf3 c\u0169ng s\u1ebd th\xe0nh c\xf4ng trong n\xfat."),(0,l.kt)("p",null,"C\xe1ch Cardano gi\u1ea3i quy\u1ebft \u0111i\u1ec1u \u0111\xf3, l\xe0 b\u1eb1ng c\xe1ch th\xeam tr\u01b0\u1eddng ph\u1ea1m vi v\u1ecb tr\xed ",(0,l.kt)("inlineCode",{parentName:"p"},"txInfoValidRange"),' v\xe0o m\u1ed9t giao d\u1ecbch, v\u1ec1 c\u01a1 b\u1ea3n n\xf3i r\u1eb1ng "Giao d\u1ecbch n\xe0y h\u1ee3p l\u1ec7 gi\u1eefa v\u1ecb tr\xed n\xe0y v\xe0 v\u1ecb tr\xed kia ".'),(0,l.kt)("p",null,"Khi m\u1ed9t giao d\u1ecbch \u0111\u01b0\u1ee3c g\u1eedi \u0111\u1ebfn blockchain v\xe0 \u0111\u01b0\u1ee3c x\xe1c th\u1ef1c b\u1edfi m\u1ed9t n\xfat, sau \u0111\xf3 tr\u01b0\u1edbc khi ch\u1ea1y b\u1ea5t k\u1ef3 t\u1eadp l\u1ec7nh n\xe0o, m\u1ed9t s\u1ed1 ki\u1ec3m tra chung s\u1ebd \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n, ch\u1eb3ng h\u1ea1n nh\u01b0 t\u1ea5t c\u1ea3 c\xe1c \u0111\u1ea7u v\xe0o \u0111\u1ec1u c\xf3 m\u1eb7t v\xe0 s\u1ed1 d\u01b0 c\u1ed9ng l\u1ea1i, ph\xed \u0111\u01b0\u1ee3c bao g\u1ed3m, v.v."),(0,l.kt)("p",null,"M\u1ed9t trong nh\u1eefng ki\u1ec3m tra x\u1ea3y ra tr\u01b0\u1edbc khi x\xe1c th\u1ef1c l\xe0 ki\u1ec3m tra xem ph\u1ea1m vi v\u1ecb tr\xed c\xf3 h\u1ee3p l\u1ec7 hay kh\xf4ng. N\xfat s\u1ebd xem x\xe9t th\u1eddi \u0111i\u1ec3m hi\u1ec7n t\u1ea1i v\xe0 ki\u1ec3m tra xem n\xf3 c\xf3 n\u1eb1m trong ph\u1ea1m vi v\u1ecb tr\xed h\u1ee3p l\u1ec7 c\u1ee7a giao d\u1ecbch hay kh\xf4ng. N\u1ebfu kh\xf4ng, th\xec x\xe1c th\u1ef1c kh\xf4ng th\xe0nh c\xf4ng ngay l\u1eadp t\u1ee9c m\xe0 kh\xf4ng bao gi\u1edd ch\u1ea1y c\xe1c t\u1eadp l\u1ec7nh tr\xecnh x\xe1c th\u1ef1c."),(0,l.kt)("p",null,"V\xec v\u1eady, n\u1ebfu ki\u1ec3m tra tr\u01b0\u1edbc th\xe0nh c\xf4ng, th\xec \u0111i\u1ec1u n\xe0y c\xf3 ngh\u0129a l\xe0 th\u1eddi gian hi\u1ec7n t\u1ea1i r\u01a1i v\xe0o ph\u1ea1m vi v\u1ecb tr\xed h\u1ee3p l\u1ec7. \u0110\u1ebfn l\u01b0\u1ee3t n\xf3, \u0111i\u1ec1u n\xe0y c\xf3 ngh\u0129a l\xe0 ch\xfang ta l\u1ea1i ho\xe0n to\xe0n x\xe1c \u0111\u1ecbnh \u0111\u01b0\u1ee3c. T\u1eadp l\u1ec7nh x\xe1c th\u1ef1c c\xf3 th\u1ec3 \u0111\u01a1n gi\u1ea3n gi\u1ea3 \u0111\u1ecbnh r\u1eb1ng n\xf3 \u0111ang \u0111\u01b0\u1ee3c ch\u1ea1y t\u1ea1i m\u1ed9t v\u1ecb tr\xed h\u1ee3p l\u1ec7."),(0,l.kt)("p",null,"Theo m\u1eb7c \u0111\u1ecbnh, m\u1ed9t t\u1eadp l\u1ec7nh s\u1ebd s\u1eed d\u1ee5ng ph\u1ea1m vi v\u1ecb tr\xed v\xf4 h\u1ea1n, m\u1ed9t t\u1eadp l\u1ec7nh bao g\u1ed3m t\u1ea5t c\u1ea3 c\xe1c v\u1ecb tr\xed b\u1eaft \u0111\u1ea7u t\u1eeb kh\u1ed1i g\u1ed1c v\xe0 ch\u1ea1y cho \u0111\u1ebfn h\u1ebft th\u1eddi gian."),(0,l.kt)("p",null,"C\xf3 m\u1ed9t s\u1ef1 ph\u1ee9c t\u1ea1p nh\u1ecf v\u1edbi \u0111i\u1ec1u n\xe0y, \u0111\xf3 l\xe0 Ouroboros, giao th\u1ee9c \u0111\u1ed3ng thu\u1eadn cung c\u1ea5p n\u0103ng l\u01b0\u1ee3ng cho Cardano kh\xf4ng s\u1eed d\u1ee5ng th\u1eddi gian POSIX, n\xf3 s\u1eed d\u1ee5ng c\xe1c khe c\u1eafm. Nh\u01b0ng Plutus s\u1eed d\u1ee5ng th\u1eddi gian th\u1ef1c, v\xec v\u1eady ch\xfang ta c\u1ea7n c\xf3 kh\u1ea3 n\u0103ng chuy\u1ec3n \u0111\u1ed5i qua l\u1ea1i gi\u1eefa th\u1eddi gian th\u1ef1c v\xe0 th\u1eddi \u0111i\u1ec3m. \u0110i\u1ec1u n\xe0y kh\xf4ng c\xf3 v\u1ea5n \u0111\u1ec1 g\xec mi\u1ec5n l\xe0 th\u1eddi gian r\xe3nh \u0111\u01b0\u1ee3c c\u1ed1 \u0111\u1ecbnh. Ngay b\xe2y gi\u1edd l\xe0 m\u1ed9t gi\xe2y, v\xec v\u1eady ngay b\xe2y gi\u1edd n\xf3 l\xe0 d\u1ec5 d\xe0ng."),(0,l.kt)("p",null,"Tuy nhi\xean, \u0111i\u1ec1u n\xe0y c\xf3 th\u1ec3 thay \u0111\u1ed5i trong t\u01b0\u01a1ng lai. C\xf3 th\u1ec3 c\xf3 m\u1ed9t \u0111\u1ee3t hard fork v\u1edbi m\u1ed9t s\u1ed1 thay \u0111\u1ed5i th\xf4ng s\u1ed1 s\u1ebd thay \u0111\u1ed5i th\u1eddi gian c\u1ee7a v\u1ecb tr\xed. Ch\xfang t\xf4i kh\xf4ng th\u1ec3 bi\u1ebft tr\u01b0\u1edbc \u0111i\u1ec1u \u0111\xf3. V\xed d\u1ee5, ch\xfang t\xf4i kh\xf4ng bi\u1ebft \u0111\u1ed9 d\xe0i v\u1ecb tr\xed s\u1ebd l\xe0 bao nhi\xeau trong 10 n\u0103m n\u1eefa."),(0,l.kt)("p",null,"\u0110i\u1ec1u \u0111\xf3 c\xf3 ngh\u0129a l\xe0 c\xe1c kho\u1ea3ng th\u1eddi gian \u0111\u01b0\u1ee3c x\xe1c \u0111\u1ecbnh cho c\xe1c giao d\u1ecbch kh\xf4ng \u0111\u01b0\u1ee3c c\xf3 gi\u1edbi h\u1ea1n tr\xean x\xe1c \u0111\u1ecbnh l\xe0 qu\xe1 xa trong t\u01b0\u01a1ng lai. Ch\u1ec9 c\xe0ng xa trong t\u01b0\u01a1ng lai th\xec ng\u01b0\u1eddi ta m\u1edbi c\xf3 th\u1ec3 bi\u1ebft \u0111\u01b0\u1ee3c \u0111\u1ed9 d\xe0i r\xe3nh s\u1ebd l\xe0 bao nhi\xeau. \u0110i\u1ec1u n\xe0y x\u1ea3y ra t\u01b0\u01a1ng t\u1ef1 nh\u01b0 36 gi\u1edd. Ch\xfang t\xf4i bi\u1ebft r\u1eb1ng n\u1ebfu s\u1eafp c\xf3 m\u1ed9t \u0111\u1ee3t hard fork, ch\xfang t\xf4i s\u1ebd bi\u1ebft v\u1ec1 n\xf3 tr\u01b0\u1edbc \xedt nh\u1ea5t 36 gi\u1edd."),(0,l.kt)("h3",{id:"posixtimerange"},"POSIXTimeRange"),(0,l.kt)("p",null,"H\xe3y xem ",(0,l.kt)("inlineCode",{parentName:"p"},"POSIXTimeRange")," n\xe0y , \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong ",(0,l.kt)("inlineCode",{parentName:"p"},"Plutus.V1.Ledger.Time"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"type POSIXTimeRange = Interval POSIXTime.\n")),(0,l.kt)("p",null,"N\xf3 l\xe0 m\u1ed9t lo\u1ea1i t\u1eeb \u0111\u1ed3ng ngh\u0129a v\u1edbi ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval POSIXTime")," v\xe0 ch\xfang ta th\u1ea5y r\u1eb1ng n\xf3 ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a b\u1edfi  ",(0,l.kt)("inlineCode",{parentName:"p"},"LowerBound")," v\xe0 ",(0,l.kt)("inlineCode",{parentName:"p"},"UpperBound"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Interval\n      ivFrom :: LowerBound a\n      inTo   :: UpperBound a      \n")),(0,l.kt)("p",null,"N\u1ebfu ch\xfang ta \u0111i s\xe2u v\xe0o, ",(0,l.kt)("inlineCode",{parentName:"p"},"LowerBound")," ch\xfang ta s\u1ebd th\u1ea5y h\xe0m t\u1ea1o"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data LowerBound a = LowerBound (Extended a) Closure\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Closure")," l\xe0 m\u1ed9t t\u1eeb \u0111\xf4ng ngh\u0129a v\u1edbi ",(0,l.kt)("inlineCode",{parentName:"p"},"Bool")," v\xe0 ch\u1eafc ch\u1eafn r\u1eb1ng c\xf3 \u0111\u01b0a v\xe0o ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," hay kh\xf4ng."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Extended")," c\xf3 th\u1ec3 l\xe0 ",(0,l.kt)("inlineCode",{parentName:"p"},"NegInf")," \xe2m v\xf4 c\xf9ng, ",(0,l.kt)("inlineCode",{parentName:"p"},"PosInf")," d\u01b0\u01a1ng v\xf4 c\xf9ng, ho\u1eb7c ",(0,l.kt)("inlineCode",{parentName:"p"},"Finite"),"."),(0,l.kt)("p",null,"Ch\xfang t\xf4i c\u0169ng t\xecm th\u1ea5y m\u1ed9t s\u1ed1 h\xe0m tr\u1ee3 gi\xfap bao g\u1ed3m c\u1ea3 h\xe0m ",(0,l.kt)("inlineCode",{parentName:"p"},"member")," ki\u1ec3m tra xem m\u1ed9t c\xe1i \u0111\xe3 cho ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," c\xf3 ph\u1ea3i l\xe0 m\u1ed9t ph\u1ea7n c\u1ee7a m\u1ed9t c\xe1i \u0111\xe3 cho hay kh\xf4ng ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval"),", mi\u1ec5n l\xe0 ki\u1ec3u c\u1ee7a ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," l\xe0 m\u1ed9t ki\u1ec3u con c\u1ee7a ",(0,l.kt)("inlineCode",{parentName:"p"},"Ord"),", \u0111\xe2y l\xe0 tr\u01b0\u1eddng h\u1ee3p cho ",(0,l.kt)("inlineCode",{parentName:"p"},"POSIXTime"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"member :: Ord a => a -> Interval a -> Bool\nmember a i = i `contains` singleton a\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"interval")," l\xe0 m\u1ed9t h\xe0m t\u1ea1o th\xf4ng minh cho ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," Ki\u1ec3u n\xe0y t\u1ea1o ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," v\u1edbi gi\u1edbi h\u1ea1n tr\xean v\xe0 d\u01b0\u1edbi."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"interval :: a -> a -> Interval a\ninterval s s' = Interval (lowerBound s) (upperBound s')\n")),(0,l.kt)("p",null,"Sau \u0111\xf3 ch\xfang ta c\xf3 ",(0,l.kt)("inlineCode",{parentName:"p"},"from")," v\u1edbi ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," c\xe1i n\xe0y b\u1eaft \u0111\u1ea7u t\u1eeb ",(0,l.kt)("inlineCode",{parentName:"p"},"a"),"\nv\xe0 k\xe9o d\xe0i \u0111\u1ebfn v\xf4 c\xf9ng."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"from :: a -> Interval a\nfrom s = Interval (lowerBound s) (UpperBound PosInf True)\n")),(0,l.kt)("p",null,"V\xe0 ch\xfang ta c\xf3 ",(0,l.kt)("inlineCode",{parentName:"p"},"to"),", n\xf3 l\xe0 ng\u01b0\u1edbc l\u1ea1i v\u1edbi ",(0,l.kt)("inlineCode",{parentName:"p"},"from"),". N\xf3 c\u0169ng \u0111\u01b0\u1ee3c d\xf9ng ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval"),"\nn\xf3 b\u1eaft \u0111\u1ea7u block genesis t\u1edbi ",(0,l.kt)("inlineCode",{parentName:"p"},"a"),", v\xe0 bao g\u1ed3m c\u1ea3 ",(0,l.kt)("inlineCode",{parentName:"p"},"a"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"to :: a -> Interval a\nto s = Interval (LowerBound NegInf True) (upperBound s)\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"always")," lu\xf4n m\u1eb7c \u0111\u1ecbnh ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," bao g\u1ed3m t\u1ea5t c\u1ea3 t\u1eeb \xe2m v\xf4 c\xf9ng \u0111\u1ebfn d\u01b0\u01a1ng v\xf4 c\xf9ng."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"always :: Interval a\nalways = Interval (LowerBound NegInf True) (UpperBound PosInf True)\n")),(0,l.kt)("p",null,"v\xe0 c\xf3 \u0111i\u1ec1u ng\u01b0\u01a1c l\u1ea1i, ",(0,l.kt)("inlineCode",{parentName:"p"},"never"),", N\xf3 kh\xf4ng ch\u1ee9a slots n\xe0o."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"never :: Interval a\nnever = Interval (LowerBound PosInf True) (UpperBound NegInf True)\n")),(0,l.kt)("p",null,"Ngo\xe0i ra c\xf2n tr\xecnh tr\u1ee3 gi\xfap ",(0,l.kt)("inlineCode",{parentName:"p"},"singleton"),", n\xf3 bao g\u1ed3m m\u1ed9t slot"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"singleton :: a -> Interval a\nsingleton s = interval s s      \n")),(0,l.kt)("p",null,"H\xe0m ",(0,l.kt)("inlineCode",{parentName:"p"},"hull")," cho kho\u1ea3ng nh\u1ecf nh\u1ea5t ch\u1ee9a c\u1ea3 hai kho\u1ea3ng \u0111\xe3 cho."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"hull :: Ord a => Interval a -> Interval a -> Interval a\nhull (Interval l1 h1) (Interval l2 h2) = Interval (min l1 l2) (max h1 h2)\n")),(0,l.kt)("p",null,"Ch\u1ee9c n\u0103ng ",(0,l.kt)("inlineCode",{parentName:"p"},"intersection")," x\xe1c \u0111\u1ecbnh kho\u1ea3ng th\u1eddi gian l\u1edbn nh\u1ea5t \u0111\u01b0\u1ee3c ch\u1ee9a trong c\u1ea3 kho\u1ea3ng th\u1eddi gian nh\u1ea5t \u0111\u1ecbnh. \u0110\xe2y l\xe0 m\u1ed9t ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," b\u1eaft \u0111\u1ea7u t\u1eeb gi\u1edbi h\u1ea1n d\u01b0\u1edbi l\u1edbn nh\u1ea5t c\u1ee7a hai kho\u1ea3ng v\xe0 k\xe9o d\xe0i cho \u0111\u1ebfn gi\u1edbi h\u1ea1n tr\xean nh\u1ecf nh\u1ea5t."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"intersection :: Ord a => Interval a -> Interval a -> Interval a\nintersection (Interval l1 h1) (Interval l2 h2) = Interval (max l1 l2) (min h1 h2)    \n")),(0,l.kt)("p",null,"H\xe0m ",(0,l.kt)("inlineCode",{parentName:"p"},"overlaps")," ki\u1ec3m tra ch\u1ee9c n\u0103ng cho d\xf9 hai kho\u1ea3ng th\u1eddi gian ch\u1ed3ng l\xean nhau, c\xf3 ngh\u0129a l\xe0, cho d\xf9 c\xf3 m\u1ed9t gi\xe1 tr\u1ecb ch\u1ed3ng l\xean nhau c\u1ee7a c\u1ea3 hai kho\u1ea3ng th\u1eddi gian."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"overlaps :: Ord a => Interval a -> Interval a -> Bool\noverlaps l r = isEmpty (l `intersection` r)\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"contains")," tl\u1ea5y hai kho\u1ea3ng v\xe0 x\xe1c \u0111\u1ecbnh xem kho\u1ea3ng th\u1ee9 hai c\xf3 ho\xe0n to\xe0n n\u1eb1m trong kho\u1ea3ng th\u1eddi gian \u0111\u1ea7u ti\xean hay kh\xf4ng."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"contains :: Ord a => Interval a -> Interval a -> Bool\ncontains (Interval l1 h1) (Interval l2 h2) = l1 <= l2 && h2 <= h1\n")),(0,l.kt)("p",null,"V\xe0 ch\xfang t\xf4i c\xf3 c\xe1c ch\u1ee9c n\u0103ng ",(0,l.kt)("inlineCode",{parentName:"p"},"before")," v\xe0 ",(0,l.kt)("inlineCode",{parentName:"p"},"after")," \u0111\u1ec3 x\xe1c \u0111\u1ecbnh n\u1ebfu m\u1ed9t th\u1eddi gian nh\u1ea5t \u0111\u1ecbnh t\u01b0\u01a1ng \u1ee9ng, tr\u01b0\u1edbc ho\u1eb7c sau m\u1ecdi th\u1ee9 trong m\u1ed9t th\u1eddi gian nh\u1ea5t \u0111\u1ecbnh ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"before :: Ord a => a -> Interval a -> Bool\nbefore h (Interval f _) = lowerBound h < f\n\nafter :: Ord a => a -> Interval a -> Bool\nafter h (Interval _ t) = upperBound h > t\n")),(0,l.kt)("p",null,"H\xe3y v\xe0o trong REPL."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week03.Homework1> import Plutus.V1.Ledger.Interval\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1>\n")),(0,l.kt)("p",null,"H\xe3y x\xe2y d\u1ef1ng ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," t\u1eeb 10 \u0111\u1ebfn 20, bao g\u1ed3m c\u1ea3 hai \u0111\u1ea7u."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.V1.Ledger.Interval Week03.Homework1> interval (10 :: Integer) 20\nInterval {ivFrom = LowerBound (Finite 10) True, ivTo = UpperBound (Finite 20) True}\n")),(0,l.kt)("p",null,"Ch\xfang ta c\xf3 th\u1ec3 ki\u1ec3m tra xem m\u1ed9t gi\xe1 tr\u1ecb c\xf3 ph\u1ea3i l\xe0 th\xe0nh vi\xean c\u1ee7a m\u1ed9t kho\u1ea3ng hay kh\xf4ng:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.V1.Ledger.Interval Week03.Homework1> member 9 $ interval (10 :: Integer) 20\nFalse\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> member 10 $ interval (10 :: Integer) 20\nTrue\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> member 12 $ interval (10 :: Integer) 20\nTrue\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> member 20 $ interval (10 :: Integer) 20\nTrue\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> member 21 $ interval (10 :: Integer) 20\nFalse\n")),(0,l.kt)("p",null,"Ch\xfang ta c\xf3 th\u1ec3 s\u1eed d\u1ee5ng h\xe0m ",(0,l.kt)("inlineCode",{parentName:"p"},"from"),". \u1ede \u0111\xe2y gi\u1edbi h\u1ea1n d\u01b0\u1edbi l\u1ea1i l\xe0 m\u1ed9t slot h\u1eefu h\u1ea1n, nh\u01b0ng gi\u1edbi h\u1ea1n tr\xean l\xe0 d\u01b0\u01a1ng v\xf4 c\xf9ng."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.V1.Ledger.Interval Week03.Homework1> member 21 $ from (30 :: Integer)\nFalse\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> member 30 $ from (30 :: Integer)\nTrue\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> member 300000 $ from (30 :: Integer)\nTrue\n")),(0,l.kt)("p",null,"And the ",(0,l.kt)("inlineCode",{parentName:"p"},"to")," constructor. Here the lower bound is negative infinity,\nwhile the upper bound is a finite slot number."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.V1.Ledger.Interval Week03.Homework1> member 300000 $ to (30 :: Integer)\nFalse\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> member 31 $ to (30 :: Integer)\nFalse\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> member 30 $ to (30 :: Integer)\nTrue\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> member 7 $ to (30 :: Integer)\nTrue\n")),(0,l.kt)("p",null,"Now, let\\'s try the ",(0,l.kt)("inlineCode",{parentName:"p"},"intersection")," function on the ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," from 10 to\n20 and the ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," from 18 to 30."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.V1.Ledger.Interval Week03.Homework1> intersection (interval (10 :: Integer) 20) $ interval 18 30\nInterval {ivFrom = LowerBound (Finite 18) True, ivTo = UpperBound (Finite 20) True}\n")),(0,l.kt)("p",null,"As expected, we get the ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," that runs from 18 to 20, inclusive."),(0,l.kt)("p",null,"We can check whether one ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," contains another."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.V1.Ledger.Interval Week03.Homework1> contains (to (100 :: Integer)) $ interval 30 80\nTrue\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> contains (to (100 :: Integer)) $ interval 30 100\nTrue\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> contains (to (100 :: Integer)) $ interval 30 101\nFalse\n")),(0,l.kt)("p",null,"We see that as soon as the second ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," extends to 101, it is no\nlonger fully contained within the ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," that runs to 100."),(0,l.kt)("p",null,"However, if we check with ",(0,l.kt)("inlineCode",{parentName:"p"},"overlaps"),", then it will be true because there\nare elements, such as 40, that are contained in both intervals."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.V1.Ledger.Interval Week03.Homework1> overlaps (to (100 :: Integer)) $ interval 30 101\nTrue\n\nPrelude Plutus.V1.Ledger.Interval Week03.Homework1> overlaps (to (100 :: Integer)) $ interval 101 110\nFalse\n")),(0,l.kt)("h2",{id:"example---vesting"},"Example - Vesting"),(0,l.kt)("p",null,"Imagine you want to give a gift of Ada to a child. You want the child to\nown the Ada, but you only want the child to have access to it he or she\nturns eighteen."),(0,l.kt)("p",null,"Using Plutus, it is very easy to implement. As our first contract that\nwill look at the context argument, we will implement a contract that\nimplements a vesting scheme. Money will be put into a script and then it\ncan be retrieved by a certain person, but only once a certain deadline\nhas been reached."),(0,l.kt)("p",null,"We start by copying the ",(0,l.kt)("inlineCode",{parentName:"p"},"IsData")," contract from lecture two into a new\nmodule called ",(0,l.kt)("inlineCode",{parentName:"p"},"Vesting"),"."),(0,l.kt)("p",null,"The first step is to think about the types for the datum and redeemer."),(0,l.kt)("p",null,"For datum, it makes sense to have two pieces of information, the\nbeneficiary and the deadline. So, let\\'s define this type:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data VestingDatum = VestingDatum\n   { beneficiary :: PubKeyHash\n   , deadline    :: POSIXTime\n   } deriving Show\n\nPlutusTx.unstableMakeIsData ''VestingDatum\n")),(0,l.kt)("p",null,"In order to know if someone can spend this script output, two pieces\ninformation are required, i.e. the beneficiary\\'s signature and the time\nof the transaction. In this case, both those pieces of information are\ncontained in the transaction itself. This means that we don\\'t need any\ninformation in the redeemer, so we can just use ",(0,l.kt)("inlineCode",{parentName:"p"},"()")," for the redeemer."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"mkValidator :: VestingDatum -> () -> ScriptContext -> Bool\n")),(0,l.kt)("p",null,"We need to check two conditions."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"That only the correct beneficiary can unlock a UTxO sitting at this\naddress. This we can validate by checking that the beneficiary\\'s\nsignature is included in the transaction."),(0,l.kt)("li",{parentName:"ol"},"That this transaction is only executed after the deadline is\nreached.")),(0,l.kt)("p",null,"We could probably just write this in one go, but we will write it in a\nmore top-down fashion and delegate to some helper functions."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'mkValidator dat () ctx =\n      mkValidator dat () ctx = traceIfFalse "beneficiary\'s signature missing" signedByBeneficiary &&\n                               traceIfFalse "deadline not reached" deadlineReached\nwhere\n      info :: TxInfo\n      info = scriptContextTxInfo ctx\n')),(0,l.kt)("p",null,"To check that the transaction is signed by the beneficiary, we can get\nthe public key of the beneficiary from the datum and pass it, along with\nthe transaction information to the ",(0,l.kt)("inlineCode",{parentName:"p"},"txSignedBy")," function."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"signedByBeneficiary :: Bool\nsignedByBeneficiary = txSignedBy info $ beneficiary dat\n")),(0,l.kt)("p",null,"How do we check that the deadline has passed?"),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(3963).Z})),(0,l.kt)("p",null,"Let\\'s consider a transaction with a validity that crosses the deadline,\nwhich is shown as the uppermost range in the above diagram."),(0,l.kt)("p",null,"Recall that before the validator script is run, other checks are made,\nincluding the time check. The node checks that the current time falls\ninto the valid range of the transaction and only then is the validator\nrun. So we know that, if we are in the validator, the current time lies\nsomewhere within the validity interval."),(0,l.kt)("p",null,"In the case of the range that crosses the deadline, the validator code\ncannot know whether the current time is before or after the deadline. In\nthis case, the validator must declare that the transaction is invalid."),(0,l.kt)("p",null,"The second example in the diagram, however, is fine. We still don\\'t\nknow what the current time is exactly, but we know that whatever the\ntime is, it will be after the deadline."),(0,l.kt)("p",null,"So, what we are checking for is that the whole validity interval is to\nthe right of the deadline. One way to do this is to use the ",(0,l.kt)("inlineCode",{parentName:"p"},"contains"),"\nfunction to check whether the validity interval is fully contained\nwithin the interval that starts from the deadline and extends until the\nend of time."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"deadlineReached :: Bool\ndeadlineReached = contains (from $ deadline dat) $ txInfoValidRange info\n")),(0,l.kt)("p",null,"That completes the validation logic. Let\\'s take care of some\nboilerplate."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data Vesting\ninstance Scripts.ValidatorTypes Vesting where\n    type instance DatumType Vesting = VestingDatum\n    type instance RedeemerType Vesting = ()\n\ntypedValidator :: Scripts.TypedValidator Vesting\ntypedValidator = Scripts.mkTypedValidator @Vesting\n    $$(PlutusTx.compile [|| mkValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @VestingDatum @()\n")),(0,l.kt)("p",null,"We will focus more on the wallet part of the script later, but here are\nthe changes."),(0,l.kt)("p",null,"In addition to some new ",(0,l.kt)("inlineCode",{parentName:"p"},"LANGUAGE")," pragmas and some extra imports, we\nhave created a ",(0,l.kt)("inlineCode",{parentName:"p"},"GiveParams")," type, and modified the ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," endpoint to\nrequire no parameters."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"VestingSchema")," type defines the endpoints that we want to expose to\nthe user. As in our last example, ",(0,l.kt)("inlineCode",{parentName:"p"},"give")," will be used by the user who\nputs funds into the contract, then ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," will be used by the user\nwanting to claim the funds."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'type VestingSchema =\n   .\\/ Endpoint "give" GiveParams\n   .\\/ Endpoint "grab" ()\n')),(0,l.kt)("p",null,"So what parameters do we need for ",(0,l.kt)("inlineCode",{parentName:"p"},"give"),"? The endpoint will create a\nUTxO at the vesting script address with an amount and a datum. If you\nrecall, our datum contains the beneficiary and the deadline. So, there\nare three pieces of information that we must pass to the ",(0,l.kt)("inlineCode",{parentName:"p"},"give"),"\nendpoint."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data GiveParams = GiveParams\n   { gpBeneficiary :: !PubKeyHash\n   , gpDeadline    :: !POSIXTime\n   , gpAmount      :: !Integer\n   } deriving (Generic, ToJSON, FromJSON, ToSchema)\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," endpoint doesn\\'t require any parameters because the\nbeneficiary will just look for UTxOs sitting at the script address and\ncan then check whether they are the beneficiary and whether the deadline\nhas passed. If so, they can consume them."),(0,l.kt)("p",null,"Let\\'s quickly look at the ",(0,l.kt)("inlineCode",{parentName:"p"},"give")," endpoint."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'give :: AsContractError e => GiveParams -> Contract w s e ()\ngive gp = do\n    let dat = VestingDatum\n                { beneficiary = gpBeneficiary gp\n                , deadline    = gpDeadline gp\n                }\n        tx  = mustPayToTheScript dat $ Ada.lovelaceValueOf $ gpAmount gp\n    ledgerTx <- submitTxConstraints typedValidator tx\n    void $ awaitTxConfirmed $ txId ledgerTx\n    logInfo @String $ printf "made a gift of %d lovelace to %s with deadline %s"\n        (gpAmount gp)\n        (show $ gpBeneficiary gp)\n        (show $ gpDeadline gp)\n')),(0,l.kt)("p",null,"First we compute the datum we want to use, and we can get both pieces of\ninformation from the ",(0,l.kt)("inlineCode",{parentName:"p"},"GiveParams")," which is passed into the function."),(0,l.kt)("p",null,"Then, for the transaction, we add a constraint that there must be an\noutput at this script address with the datum that we just defined and a\ncertain number of lovelace, which we also get from the ",(0,l.kt)("inlineCode",{parentName:"p"},"GiveParams"),"."),(0,l.kt)("p",null,"The rest of the function is as before, just with a different log\nmessage."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," endpoint is a bit more involved."),(0,l.kt)("p",null,"There can be many UTxOs at this script address and some of them might\nnot be suitable for us, either because we are not the beneficiary, or\nbecause the deadline has not yet passed. If we try to submit a\ntransaction when there are no suitable UTxOs, we will pay fees, but get\nnothing in return."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'grab :: forall w s e. AsContractError e => Contract w s e ()\ngrab = do\n    now   <- currentTime\n    pkh   <- pubKeyHash <$> ownPubKey\n    utxos <- Map.filter (isSuitable pkh now) <$> utxoAt scrAddress\n    if Map.null utxos\n        then logInfo @String $ "no gifts available"\n        else do\n            let orefs   = fst <$> Map.toList utxos\n                lookups = Constraints.unspentOutputs utxos  <>\n                          Constraints.otherScript validator\n                tx :: TxConstraints Void Void\n                tx      = mconcat [mustSpendScriptOutput oref $ Redeemer $ PlutusTx.toData () | oref <- orefs] <>\n                          mustValidateIn (from now)\n            ledgerTx <- submitTxConstraintsWith @Void lookups tx\n            void $ awaitTxConfirmed $ txId ledgerTx\n            logInfo @String $ "collected gifts"\n  where\n    isSuitable :: PubKeyHash -> POSIXTime -> TxOutTx -> Bool\n    isSuitable pkh now o = case txOutDatumHash $ txOutTxOut o of\n        Nothing -> False\n        Just h  -> case Map.lookup h $ txData $ txOutTxTx o of\n            Nothing        -> False\n            Just (Datum e) -> case PlutusTx.fromData e of\n                Nothing -> False\n                Just d  -> beneficiary d == pkh && deadline d <= now\n')),(0,l.kt)("p",null,"First, we get the current time and calculate our public key hash. We\nthen look up all the UTxOs at this address and filter them using the\n",(0,l.kt)("inlineCode",{parentName:"p"},"isSuitable")," helper function, which is defined in the ",(0,l.kt)("inlineCode",{parentName:"p"},"where")," clause."),(0,l.kt)("p",null,"It first checks the datum hash, and, if it finds it, it attempts to look\nup the corresponding datum. Recall that the producing transaction, in\nthis case ",(0,l.kt)("inlineCode",{parentName:"p"},"give")," doesn\\'t have to supply the datum, it need only supply\nthe datum hash. However, in our case we need to have the datum available\nto the ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," endpoint, so the ",(0,l.kt)("inlineCode",{parentName:"p"},"give")," endpoint does provide the datum."),(0,l.kt)("p",null,"If the ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," endpoint finds the datum, it must deserialise it to the\n",(0,l.kt)("inlineCode",{parentName:"p"},"Vesting")," type."),(0,l.kt)("p",null,"If all of this succeeds we can check whether we are the beneficiary and\nwhether the deadline has passed."),(0,l.kt)("p",null,"At this point, ",(0,l.kt)("inlineCode",{parentName:"p"},"utxos")," contains all the UTxOs that we can consume. If we\nfind none, then we just log a message to that effect. If there is at\nleast one, then we construct one transaction that consumes all of them\nas inputs and pays the funds to our wallet."),(0,l.kt)("p",null,"As ",(0,l.kt)("inlineCode",{parentName:"p"},"lookups"),", we provide the list of UTxOs as well as the validator\nscript. Recall that, in order to consume UTxOs at this address, the\nspending transaction must provide the validation script."),(0,l.kt)("p",null,"We then create a transaction that spends all the suitable UTxOs along\nwith a constraint that it must validate in the ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," which\nstretches from now until the end of time. If we don\\'t provide the\ninterval here, then validation will fail, because the default interval\nis from genesis until the end of time. The on-chain validation would\nreject this as it needs an interval that is fully contained in the\ninterval stretching from the deadline until the end of time."),(0,l.kt)("p",null,"We could use the singleton ",(0,l.kt)("inlineCode",{parentName:"p"},"Interval")," ",(0,l.kt)("inlineCode",{parentName:"p"},"now"),", but, if there were any\nissues, for example network delays, and the transaction arrived at a\nnode a slot or two later, then validation would no longer work."),(0,l.kt)("p",null,"The, we just bundle up the endpoints."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"endpoints :: Contract () VestingSchema Text ()\nendpoints = (give' `select` grab') >> endpoints\n  where\n    give' = endpoint @\"give\" >>= give\n    grab' = endpoint @\"grab\" >>  grab\n")),(0,l.kt)("p",null,"Then there is some boilerplate which is just used in the playground."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"mkSchemaDefinitions ''VestingSchema\n\nmkKnownCurrencies []\n")),(0,l.kt)("h3",{id:"in-the-playground"},"In the playground"),(0,l.kt)("p",null,"First, let\\'s add a third wallet. We are going to create a scenario\nwhere Wallet 1 makes two gifts to Wallet 2 with different deadlines and\nalso makes one gift to Wallet 3."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(5828).Z})),(0,l.kt)("p",null,"Normally it would be possible to submit both ",(0,l.kt)("inlineCode",{parentName:"p"},"give")," transactions in the\nsame slot, but the way our code is implemented, we wait for\nconfirmation, which means we need to add a wait action. This is maybe\nnot the best way to do it, but that\\'s how it is for the time being."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(2711).Z})),(0,l.kt)("p",null,"Here we run into our first problem. We need to supply the beneficiary\naddress, but there is no way in the playground to get the public key\nhash of a wallet."),(0,l.kt)("p",null,"But we can get it from the REPL."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week03.Homework1> :l src/Week03/Vesting.hs \nOk, one module loaded.\nPrelude Week03.Vesting> import Ledger\nPrelude Ledger Week03.Vesting> import Wallet.Emulator\nPrelude Ledger Wallet.Emulator Week03.Vesting> pubKeyHash $ walletPubKey $ Wallet 2\n39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f\nPrelude Ledger Wallet.Emulator Week03.Vesting> pubKeyHash $ walletPubKey $ Wallet 3\ndac073e0123bdea59dd9b3bda9cf6037f63aca82627d7abcd5c4ac29dd74003e\n")),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(2552).Z})),(0,l.kt)("p",null,"The next problem is the deadline. In the last lecture we saw how to\nconvert between slots and POSIX times. This has changed. Previously you\njust needed a slot and out came a POSIX time. Now there is a second\nargument."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Ledger Wallet.Emulator Week03.Vesting> import Ledger.TimeSlot \nPrelude Ledger Wallet.Emulator Ledger.TimeSlot Week03.Vesting> :t slotToBeginPOSIXTime\nslotToBeginPOSIXTime :: SlotConfig -> Slot -> POSIXTime\n")),(0,l.kt)("p",null,"There are also versions of ",(0,l.kt)("inlineCode",{parentName:"p"},"slotToBeginPOSIXTime")," that have a begin and\nan end time. This is because a slot is not just a point in time, it\\'s a\nduration in time."),(0,l.kt)("p",null,"So what is this ",(0,l.kt)("inlineCode",{parentName:"p"},"SlotConfig"),"?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Ledger Wallet.Emulator Ledger.TimeSlot Week03.Vesting> :i SlotConfig \ntype SlotConfig :: *\ndata SlotConfig\n  = SlotConfig {scSlotLength :: Integer, scZeroSlotTime :: POSIXTime}\n        -- Defined in \u2018Ledger.TimeSlot\u2019\ninstance Eq SlotConfig -- Defined in \u2018Ledger.TimeSlot\u2019\ninstance Show SlotConfig -- Defined in \u2018Ledger.TimeSlot\u2019\n")),(0,l.kt)("p",null,"It takes the slot length and the time at which slot zero starts."),(0,l.kt)("p",null,"So now we have to find out what ",(0,l.kt)("inlineCode",{parentName:"p"},"SlotConfig")," to use for the playground.\nLuckily, it\\'s the default. For that we need to use the ",(0,l.kt)("inlineCode",{parentName:"p"},"Data.Default"),"\nmodule."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Ledger Wallet.Emulator Ledger.TimeSlot Week03.Vesting> import Data.Default\nPrelude Ledger Wallet.Emulator Ledger.TimeSlot Data.Default Week03.Vesting> def :: SlotConfig\nSlotConfig {scSlotLength = 1000, scZeroSlotTime = POSIXTime {getPOSIXTime = 1596059091000}}\n")),(0,l.kt)("p",null,"Now we can use ",(0,l.kt)("inlineCode",{parentName:"p"},"slotToBeginPOSIXTime")," with the default config to get the\nPOSIX time for slot 10 and slot 20."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Ledger Wallet.Emulator Ledger.TimeSlot Data.Default Week03.Vesting> slotToBeginPOSIXTime def 10\nPOSIXTime {getPOSIXTime = 1596059101000}\n\nPrelude Ledger Wallet.Emulator Ledger.TimeSlot Data.Default Week03.Vesting> slotToBeginPOSIXTime def 20\nPOSIXTime {getPOSIXTime = 1596059111000}\n")),(0,l.kt)("p",null,"And we can use these in the playground. We\\'ll use slot 10 as the\ndeadline for the first and third ",(0,l.kt)("inlineCode",{parentName:"p"},"give"),"s and slot 20 for the second\n",(0,l.kt)("inlineCode",{parentName:"p"},"give"),". We\\'ll also give 10 Ada in each case."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(186).Z})),(0,l.kt)("p",null,"Let\\'s create a scenario where everything works. Wallet 3 grabs at slot\n10 when the deadline for Wallet 3 has passed, and Wallet 2 grabs at slot\n20, when both the Wallet 2 deadlines have passed. We will use the\n",(0,l.kt)("inlineCode",{parentName:"p"},"Wait Until..")," option for this."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(6408).Z})),(0,l.kt)("p",null,"After evaluation, we first see the Genesis transaction."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(7678).Z})),(0,l.kt)("p",null,"If we look at the next transaction, we see the gift from Wallet 1 to\nWallet 2 with the deadline of 10. Here, ten Ada get locked in the script\naddress."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(1807).Z})),(0,l.kt)("p",null,"The next transaction is the gift from Wallet 1 to Wallet 2 with the\ndeadline of 20. A new UTxO is now created at the script address with ten\nAda."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(6735).Z})),(0,l.kt)("p",null,"And the third gift, this time to Wallet 3, with a deadline of 10. Wallet\n1 now has about 70 Ada, and another UTxO is created with 10 Ada locked\nat the script address."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(4669).Z})),(0,l.kt)("p",null,"At slot 10, Wallet 3 grabs successfully. The third UTxO is the input,\nsome fees are paid, and then the remainder of the lovelace is sent to\nWallet 3."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(2105).Z})),(0,l.kt)("p",null,"Then at slot 20, Wallet 2 successfully grabs both the UTxOs for which\nthey are the beneficiary. This time the fee is higher because two\nvalidators have to run."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(8068).Z})),(0,l.kt)("p",null,"The final balances reflect the changes."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(3400).Z})),(0,l.kt)("p",null,"Now let\\'s look at the case where the grab happens too early. We\\'ll\nmake Wallet 2 grab at slot 15 instead of slot 20."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(2058).Z})),(0,l.kt)("p",null,"Now we see that the first transactions are the same, but that the final\ntransaction at slot 15 has only one input, because the second UTxO is\nnot yet available."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(1032).Z})),(0,l.kt)("p",null,"And we can see that there are 10 Ada still locked at the script address."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(1032).Z})),(0,l.kt)("p",null,"Our off-chain code was written in such a way that it will only submit a\ntransaction if there is a suitable UTxO that can be grabbed. This means\nthat we don\\'t really exercise the validator because we are only sending\ntransactions to the blockchain that will pass validation."),(0,l.kt)("p",null,"If you want to test the validator, you could modify the wallet code so\nthat the grab endpoint attempts to grab everything and then validation\nwill fail if you are not the beneficiary or the deadline has not been\nreached."),(0,l.kt)("p",null,"You need to keep in mind that anybody can write off-chain code. So, even\nthough it works now as long as you use the ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," endpoint that we wrote\nourselves, somebody could write a different piece of off-chain code that\ndoesn\\'t filter the UTxOs as we did. In this case, if the validator is\nnot correct something could be horribly wrong."),(0,l.kt)("h2",{id:"example-2---parameterized-contract"},"Example 2 - Parameterized Contract"),(0,l.kt)("p",null,"We\\'ll start the next example by copying the code from the vesting\nexample into a new module called ",(0,l.kt)("inlineCode",{parentName:"p"},"Week03.Parameterized"),"."),(0,l.kt)("h3",{id:"on-chain"},"On-Chain"),(0,l.kt)("p",null,"Note that in the vesting example we used the ",(0,l.kt)("inlineCode",{parentName:"p"},"Vesting")," type as the\ndatum, but it was just fixed, it didn\\'t change. Alternatively, we could\nhave baked it into the contract, so to speak, so that we have a contract\nwhere the script itself already contains the beneficiary and deadline\ninformation."),(0,l.kt)("p",null,"All the examples of contracts we have seen so far were fixed. We used a\n",(0,l.kt)("inlineCode",{parentName:"p"},"TypedValidator")," as a compile-time constant. The idea of parameterized\nscripts is that you can have a parameter and, depending on the value of\nthe parameter, you get different values of ",(0,l.kt)("inlineCode",{parentName:"p"},"TypedValidator"),"."),(0,l.kt)("p",null,"So, instead of defining one script, with a single script address, with\nall UTxOs sitting at the same address, you can define a family of\nscripts that are parameterized by a given parameter. In our case, this\nwill mean that UTxOs for different beneficiaries and/or deadlines will\nbe a different script addresses, as they will have parameterized\nvalidators specific to their parameters rather than specific to the\ndatum of the UTxO."),(0,l.kt)("p",null,"We are going to demonstrate how to do this by, instead of using datum\nfor the beneficiary and deadline values, using a parameter."),(0,l.kt)("p",null,"Let\\'s start by renaming ",(0,l.kt)("inlineCode",{parentName:"p"},"VestingDatum")," to something more suitable."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data VestingParam = VestingParam\n      { beneficiary :: PubKeyHash\n      , deadline    :: POSIXTime\n      } deriving Show\n")),(0,l.kt)("p",null,"We will also remove the ",(0,l.kt)("inlineCode",{parentName:"p"},"unstableMakeIsData")," call as we don\\'t need this\nanymore."),(0,l.kt)("p",null,"The reason we don\\'t need it, is because we are just going to use ",(0,l.kt)("inlineCode",{parentName:"p"},"()"),"\nfor the datum in the ",(0,l.kt)("inlineCode",{parentName:"p"},"mkValidator")," function. All the information we\nrequire will be in a new argument to ",(0,l.kt)("inlineCode",{parentName:"p"},"mkValidator"),", of type\n",(0,l.kt)("inlineCode",{parentName:"p"},"VestingParam"),", which we add at the beginning of the list of arguments."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'{-# INLINABLE mkValidator #-}\nmkValidator :: VestingParam -> () -> () -> ScriptContext -> Bool\nmkValidator p () () ctx = traceIfFalse "beneficiary\'s signature missing" signedByBeneficiary &&\n                          traceIfFalse "deadline not reached" deadlineReached\n  where\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n\n    signedByBeneficiary :: Bool\n    signedByBeneficiary = txSignedBy info $ beneficiary p\n\n    deadlineReached :: Bool\n    deadlineReached = contains (from $ deadline p) $ txInfoValidRange info\n')),(0,l.kt)("p",null,"We also change the ",(0,l.kt)("inlineCode",{parentName:"p"},"Vesting")," type to reflect the change to the datum."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data Vesting\ninstance Scripts.ValidatorTypes Vesting where\n    type instance DatumType Vesting = ()\n    type instance RedeemerType Vesting = ()     \n")),(0,l.kt)("p",null,"Now, the ",(0,l.kt)("inlineCode",{parentName:"p"},"TypedValidator")," will no longer be a constant value. Instead it\nwill take a parameter."),(0,l.kt)("p",null,"Recall that the function ",(0,l.kt)("inlineCode",{parentName:"p"},"mkTypedValidator")," requires as its first\nargument the compiled code of a function that takes three arguments and\nreturns a ",(0,l.kt)("inlineCode",{parentName:"p"},"Bool"),". But now, it has four arguments, so we need to account\nfor that."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"typedValidator :: VestingParam -> Scripts.TypedValidator Vesting\ntypedValidator p = Scripts.mkTypedValidator @Vesting      \n")),(0,l.kt)("p",null,"Now, what we would like to do is something like this, passing in the new\nparameter ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"mkValidator")," so that the compiled code within the\nOxford brackets would have the correct type."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"-- this won't work\n$$(PlutusTx.compile [|| mkValidator p ||])\n$$(PlutusTx.compile [|| wrap ||])\nwhere\nwrap = Scripts.wrapValidator @() @()\n")),(0,l.kt)("p",null,"This code will not work, but before we investigate, let\\'s leave the\ncode as it is for now and make some more changes to the rest of the\ncode."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"validator")," now will take a ",(0,l.kt)("inlineCode",{parentName:"p"},"VestingParam")," and will return a composed\nfunction. The returned function has the effect that any paramater passed\nto ",(0,l.kt)("inlineCode",{parentName:"p"},"validator")," would now effectively get passed to the ",(0,l.kt)("inlineCode",{parentName:"p"},"typedValidator"),"\nfunction, whose return value would in turned get passed to the\n",(0,l.kt)("inlineCode",{parentName:"p"},"validatorScript")," function."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"validator :: VestingParam -> Validator\nvalidator = Scripts.validatorScript . typedValidator\n")),(0,l.kt)("p",null,"And the same for ",(0,l.kt)("inlineCode",{parentName:"p"},"valHash")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"scrAddress"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"valHash :: VestingParam -> Ledger.ValidatorHash\nvalHash = Scripts.validatorHash . typedValidator\n\nscrAddress :: VestingParam -> Ledger.Address\nscrAddress = scriptAddress . validator\n")),(0,l.kt)("p",null,"Now, let\\'s find out what\\'s wrong with out ",(0,l.kt)("inlineCode",{parentName:"p"},"typedValidator")," function."),(0,l.kt)("p",null,"If we try to launch the REPL, we get a compile error."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'GHC Core to PLC plugin: E043:Error: Reference to a name which is not a local, a builtin, or an external INLINABLE function: Variable p\nNo unfolding\nContext: Compiling expr: p\nContext: Compiling expr: Week03.Parameterized.mkValidator p\nContext: Compiling expr at "plutus-pioneer-program-week03-0.1.0.0-inplace:Week03.Parameterized:(67,10)-(67,48)"\n')),(0,l.kt)("p",null,"The problem is this line."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"-- this won't work\n$$(PlutusTx.compile [|| mkValidator p ||])\n")),(0,l.kt)("p",null,"Recall that everything inside the Oxford brackets must be explicitly\nknown at compile time. Normally it would even need all the code to be\nwritten explicitly, but by using the ",(0,l.kt)("inlineCode",{parentName:"p"},"INLINABLE")," pragma on the\n",(0,l.kt)("inlineCode",{parentName:"p"},"mkValidator")," function we can reference the function instead. However,\nit must still be known at compile time, because that\\'s how Template\nHaskell works - it is executed before the main compiler."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," is not known at compile time, because we intend to supply it at\nruntime. Luckily there is a way around this."),(0,l.kt)("p",null,"On the Haskell side, we have our ",(0,l.kt)("inlineCode",{parentName:"p"},"mkValidator")," function and we have ",(0,l.kt)("inlineCode",{parentName:"p"},"p"),"\nof type ",(0,l.kt)("inlineCode",{parentName:"p"},"VestingParam"),". We can compile ",(0,l.kt)("inlineCode",{parentName:"p"},"mkValidator")," to Plutus, but we\ncan\\'t compile ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," to Plutus because we don\\'t know what it is. But, if\nwe could get our hands on the compiled version of ",(0,l.kt)("inlineCode",{parentName:"p"},"p"),", we could apply\nthis compiled version to the compiled ",(0,l.kt)("inlineCode",{parentName:"p"},"mkValidator"),", and this would give\nus what we want."),(0,l.kt)("p",null,"This seems to solve nothing, because we still need a compiled version of\n",(0,l.kt)("inlineCode",{parentName:"p"},"p")," and we have the same problem that ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," is not known at compile time."),(0,l.kt)("p",null,"However, ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," is not some arbitrary Haskell code, it\\'s data, so it\ndoesn\\'t contain any function types. If we make the type of ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," an\ninstance of a type class called ",(0,l.kt)("inlineCode",{parentName:"p"},"Lift"),". We can use ",(0,l.kt)("inlineCode",{parentName:"p"},"liftCode")," to compile\n",(0,l.kt)("inlineCode",{parentName:"p"},"p")," at runtime to Plutus Core and then, using ",(0,l.kt)("inlineCode",{parentName:"p"},"applyCode")," we can apply\nthe Plutus Core ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," to the Plutus Core ",(0,l.kt)("inlineCode",{parentName:"p"},"mkValidator"),"."),(0,l.kt)("h4",{id:"the-lift-class"},"The Lift Class"),(0,l.kt)("p",null,"Let\\'s briefly look at the ",(0,l.kt)("inlineCode",{parentName:"p"},"Lift")," class. It is defined in package\n",(0,l.kt)("inlineCode",{parentName:"p"},"plutus-tx"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"module PlutusTx.Lift.Class\n")),(0,l.kt)("p",null,"It only has one function, ",(0,l.kt)("inlineCode",{parentName:"p"},"Lift"),". However, we won\\'t use this function\ndirectly."),(0,l.kt)("p",null,"The importance of the class is that it allows us to, at runtime, lift\nHaskell values into corresponding Plutus script values. And this is\nexactly what we need to convert our parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," into code."),(0,l.kt)("p",null,"We will use a different function, defined in the same package but in a\ndifferent module."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"module PlutusTx.Lift\n")),(0,l.kt)("p",null,"The function we will use is called ",(0,l.kt)("inlineCode",{parentName:"p"},"liftCode"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"-- | Get a Plutus Core program corresponding to the given value as a 'CompiledCodeIn', throwing any errors that occur as exceptions and ignoring fresh names.\nliftCode\n   :: (Lift.Lift uni a, Throwable uni fun, PLC.ToBuiltinMeaning uni fun)\n   => a -> CompiledCodeIn uni fun a\nliftCode x = unsafely $ safeLiftCode x\n")),(0,l.kt)("p",null,"It takes a Haskell value of type ",(0,l.kt)("inlineCode",{parentName:"p"},"a"),", provided ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," is an instance of the\n",(0,l.kt)("inlineCode",{parentName:"p"},"Lift")," class, and turns it into a piece of Plutus script code\ncorresponding to the same type."),(0,l.kt)("p",null,"Now we can fix our validator."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"typedValidator :: VestingParam -> Scripts.TypedValidator Vesting\ntypedValidator p = Scripts.mkTypedValidator @Vesting\n    ($$(PlutusTx.compile [|| mkValidator ||]) `PlutusTx.applyCode` PlutusTx.liftCode p)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @() @()\n")),(0,l.kt)("p",null,"This code is fine, but it won\\'t yet compile, because ",(0,l.kt)("inlineCode",{parentName:"p"},"VestingParam")," is\nnot an instance of ",(0,l.kt)("inlineCode",{parentName:"p"},"Lift"),". To fix this, we can use ",(0,l.kt)("inlineCode",{parentName:"p"},"makeLift"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"PlutusTx.makeLift ''VestingParam\n")),(0,l.kt)("p",null,"And, we need to enable a GHC extension."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"{-# LANGUAGE MultiParamTypeClasses #-}\n")),(0,l.kt)("p",null,"Now it will compile."),(0,l.kt)("h3",{id:"off-chain"},"Off-Chain"),(0,l.kt)("p",null,"The off-chain code hasn\\'t changed much."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"GiveParams")," are still the same."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data GiveParams = GiveParams\n      { gpBeneficiary :: !PubKeyHash\n      , gpDeadline    :: !POSIXTime\n      , gpAmount      :: !Integer\n      } deriving (Generic, ToJSON, FromJSON, ToSchema)      \n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"VestingSchema")," has slightly changed because the ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," endpoint now\nrelies on knowing the beneficiary and deadline in order to know\ndetermine the script address. We know the beneficiary because it will be\nthe public key hash of the wallet that calls ",(0,l.kt)("inlineCode",{parentName:"p"},"grab"),", but we don\\'t know\nthe deadline, so we must pass it to ",(0,l.kt)("inlineCode",{parentName:"p"},"grab"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'type VestingSchema =\n          Endpoint "give" GiveParams\n      .\\/ Endpoint "grab" POSIXTime\n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"give")," endpoint is similar to the vesting example, but there are\nsome differences."),(0,l.kt)("p",null,"Instead of computing the datum, we will construct something of type\n",(0,l.kt)("inlineCode",{parentName:"p"},"VestingParam"),". We also change the reference to the datum in\n",(0,l.kt)("inlineCode",{parentName:"p"},"mustPayToTheScript")," to become ",(0,l.kt)("inlineCode",{parentName:"p"},"()"),", and we provide the type ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," to\n",(0,l.kt)("inlineCode",{parentName:"p"},"typedValidator")," as it is no longer a constant."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'give :: AsContractError e => GiveParams -> Contract w s e ()\ngive gp = do\n    let p  = VestingParam\n                { beneficiary = gpBeneficiary gp\n                , deadline    = gpDeadline gp\n                }\n        tx = mustPayToTheScript () $ Ada.lovelaceValueOf $ gpAmount gp\n    ledgerTx <- submitTxConstraints (typedValidator p) tx\n    void $ awaitTxConfirmed $ txId ledgerTx\n    logInfo @String $ printf "made a gift of %d lovelace to %s with deadline %s"\n        (gpAmount gp)\n        (show $ gpBeneficiary gp)\n        (show $ gpDeadline gp)      \n')),(0,l.kt)("p",null,"In the ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," endpoint, there are also some changes."),(0,l.kt)("p",null,"Recall that earlier we got all the UTxOs sitting at this one script\naddress and that they could be for arbitrary beneficiaries and for\narbitrary deadlines. For this reason, we had to filter those UTxOs which\nwere for us and where the deadline had been reached."),(0,l.kt)("p",null,"We now have the additional parameter, which we\\'ll call ",(0,l.kt)("inlineCode",{parentName:"p"},"d"),", which\nrepresents the deadline. So we can immediately see if the deadline has\nbeen reached or not."),(0,l.kt)("p",null,"If it has not been reached, we write a log message and stop, otherwise\nwe continue and construct the ",(0,l.kt)("inlineCode",{parentName:"p"},"VestingParam"),"."),(0,l.kt)("p",null,"Then, we look up the UTxOs that are sitting at this address. Address is\nnot a constant anymore, it takes a parameter. So, now, we will only get\nUTxOs which are for us and that have a deadline that has been reached.\nWe don\\'t need to filter anything."),(0,l.kt)("p",null,"If there are none, we log a message to that effect and stop, otherwise\nwe do more or less what we did before."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'grab d = do\nnow   <- currentTime\npkh   <- pubKeyHash <$> ownPubKey\nif now < d\n    then logInfo @String $ "too early"\n    else do\n        let p = VestingParam\n                    { beneficiary = pkh\n                    , deadline    = d\n                    }\n                    utxos <- utxoAt $ scrAddress p\n                    if Map.null utxos\n                        then logInfo @String $ "no gifts available"\n                        else do\n                            let orefs   = fst <$> Map.toList utxos\n                                lookups = Constraints.unspentOutputs utxos      <>\n                                          Constraints.otherScript (validator p)\n                                tx :: TxConstraints Void Void\n                                tx      = mconcat [mustSpendScriptOutput oref $ Redeemer $ PlutusTx.toData () | oref <- orefs] <>\n                                          mustValidateIn (from now)\n                            ledgerTx <- submitTxConstraintsWith @Void lookups tx\n                            void $ awaitTxConfirmed $ txId ledgerTx\n                            logInfo @String $ "collected gifts"                          \n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"endpoints")," function is slightly different due to the new parameter\nfor ",(0,l.kt)("inlineCode",{parentName:"p"},"grab"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"endpoints :: Contract () VestingSchema Text ()\nendpoints = (give' `select` grab') >> endpoints\n  where\n    give' = endpoint @\"give\" >>= give\n    grab' = endpoint @\"grab\" >>= grab\n")),(0,l.kt)("h3",{id:"back-to-the-playground"},"Back to the playground"),(0,l.kt)("p",null,"We will now copy and paste this new contract into the playground and\nsetup a new scenario."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"give")," transactions are the same."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(4233).Z})),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," is slightly different. In our earlier implementation, one\nwallet could grab UTxOs with different deadlines provided that the\ndeadlines had passed. Now the deadline is part of the script parameter,\nso we need to specify it in order to get the script address. This means\nthat Wallet 2 cannot grab the gifts for slots 10 and 20 at the same\ntime, at least not in the way that we have implemented it."),(0,l.kt)("p",null,"First we can wait until slot 10 and then Wallet 2 should be able to grab\nits first gift and Wallet 3 should be able to claim its single gift."),(0,l.kt)("p",null,"We\\'ll add a ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," for Wallets 2 and 3. Here, we don\\'t need to wain in\nbetween each transaction because it is two different wallets."),(0,l.kt)("p",null,"We then wait until slot 20 and perform Wallet 2\\'s second ",(0,l.kt)("inlineCode",{parentName:"p"},"grab")," and\nthen wait for 1 block, as usual."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(6877).Z})),(0,l.kt)("p",null,"So let\\'s see if it works by clicking ",(0,l.kt)("inlineCode",{parentName:"p"},"Evaluate"),"."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(2740).Z})),(0,l.kt)("p",null,"Take note of the script address for that transaction out at slot 1."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(3086).Z})),(0,l.kt)("p",null,"And compare this with the script address for the transaction output at\nslot 2."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(7619).Z})),(0,l.kt)("p",null,"Notice that the script address for the UTxOs is different. In our first\nversion of the vesting contract, the script address was a constant. This\nmeant that all our gifts ended up at the same script address and only\nthe datum in each UTxO was different."),(0,l.kt)("p",null,"Now, the datum is just ",(0,l.kt)("inlineCode",{parentName:"p"},"()")," and the beneficiary and the deadline are\nincluded as part of the script itself, so the addresses are now\ndifferent depending on the beneficiary and deadline parameters."),(0,l.kt)("p",null,"For the gift to Wallet 3 we see yet another address."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(1191).Z})),(0,l.kt)("p",null,"We see two grabs in slot 10, one by Wallets 2 and one by Wallet 3. The\norder in which they are processed is not deterministic."),(0,l.kt)("p",null,"Then, finally in slot 20, Wallet 2 grabs its remaining gift."),(0,l.kt)("p",null,"And the final balances reflect the transactions that have occurred."),(0,l.kt)("p",null,(0,l.kt)("img",{src:t(5054).Z})))}d.isMDXComponent=!0},2058:function(e,n,t){n.Z=t.p+"assets/images/pic__00010-86ac7d37c76a594b6967b6f7648e5335.png"},5828:function(e,n,t){n.Z=t.p+"assets/images/pic__00043-90836e56ce8338b63ac410965d2cc39c.png"},2711:function(e,n,t){n.Z=t.p+"assets/images/pic__00044-ae789cd0b18189a70d1c764d465b5002.png"},3963:function(e,n,t){n.Z=t.p+"assets/images/pic__00046-91ac81d2e6110ca563ef34a48b448bb4.png"},2552:function(e,n,t){n.Z=t.p+"assets/images/pic__00047-e701ccc70650672796705049bc861960.png"},186:function(e,n,t){n.Z=t.p+"assets/images/pic__00048-d7da99592a35e7501ca80f88da6366d0.png"},6408:function(e,n,t){n.Z=t.p+"assets/images/pic__00049-d73f83f7294dd0187da15f4eaa3c7247.png"},7678:function(e,n,t){n.Z=t.p+"assets/images/pic__00050-cd1459efe52e84b5c3fcebd8fb077b08.png"},1807:function(e,n,t){n.Z=t.p+"assets/images/pic__00051-74d33494d0e068519bd23ae9b42ae1ca.png"},6735:function(e,n,t){n.Z=t.p+"assets/images/pic__00052-baa346bdcdad8c6a6cf40acf94e227d3.png"},4669:function(e,n,t){n.Z=t.p+"assets/images/pic__00053-95169853875b3a94d47aacb5be95d8f1.png"},2105:function(e,n,t){n.Z=t.p+"assets/images/pic__00054-914e9e6153e10e5200376f911ef80451.png"},8068:function(e,n,t){n.Z=t.p+"assets/images/pic__00055-9d7a06572c0cabe917a527aa359cf8e8.png"},3400:function(e,n,t){n.Z=t.p+"assets/images/pic__00056-ffd977106823023ce72d426f5bf57051.png"},1032:function(e,n,t){n.Z=t.p+"assets/images/pic__00057-deaf409949adb584abc3ce5ca4253d5a.png"},4233:function(e,n,t){n.Z=t.p+"assets/images/pic__00059-7f45bb1aa7d141818049b51dd65f2e37.png"},6877:function(e,n,t){n.Z=t.p+"assets/images/pic__00060-1d269ec56accfe952503077c80c645d2.png"},2740:function(e,n,t){n.Z=t.p+"assets/images/pic__00061-34ad2459354578430639958932e6ab4e.png"},3086:function(e,n,t){n.Z=t.p+"assets/images/pic__00062-e875c97dd2255764dd0f1526e5f9922a.png"},7619:function(e,n,t){n.Z=t.p+"assets/images/pic__00063-3044e6b470677ac95cdbeeee08d43c7d.png"},1191:function(e,n,t){n.Z=t.p+"assets/images/pic__00064-a48c950dd5dece774d65874dc96f8994.png"},5054:function(e,n,t){n.Z=t.p+"assets/images/pic__00065-00802007ba5f1b30c6122d3f2985f8fa.png"}}]);
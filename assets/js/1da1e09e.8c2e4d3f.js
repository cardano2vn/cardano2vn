"use strict";(self.webpackChunkbringscdocs=self.webpackChunkbringscdocs||[]).push([[2500],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=s(n),u=l,d=m["".concat(p,".").concat(u)]||m[u]||h[u]||r;return n?a.createElement(d,o(o({ref:t},c),{},{components:n})):a.createElement(d,o({ref:t},c))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,o=new Array(r);o[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:l,o[1]=i;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5628:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return p},toc:function(){return s},default:function(){return h}});var a=n(7462),l=n(3366),r=(n(7294),n(3905)),o=["components"],i={},p={unversionedId:"dr-lars-lession/week4",id:"dr-lars-lession/week4",isDocsHomePage:!1,title:"Week 04 - Monads",description:"Note",source:"@site/docs/dr-lars-lession/week4.md",sourceDirName:"dr-lars-lession",slug:"/dr-lars-lession/week4",permalink:"/docs/dr-lars-lession/week4",editUrl:"https://github.com/cardano2vn/cardanovn-portal/edit/main/docs/dr-lars-lession/week4.md",version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"Week 03 - Script Context",permalink:"/docs/dr-lars-lession/week3"}},s=[{value:"Monads",id:"monads",children:[{value:"Hello World",id:"hello-world",children:[]},{value:"getLine",id:"getline",children:[]},{value:"Maybe",id:"maybe",children:[]},{value:"Either",id:"either",children:[]},{value:"Writer",id:"writer",children:[]},{value:"What is a Monad?",id:"what-is-a-monad",children:[]},{value:"Why Is This useful?",id:"why-is-this-useful",children:[]},{value:"&#39;do&#39; notation",id:"do-notation",children:[]}]},{value:"Plutus Monads",id:"plutus-monads",children:[{value:"The EmulatorTrace Monad",id:"the-emulatortrace-monad",children:[]},{value:"The Contract Monad",id:"the-contract-monad",children:[]}]}],c={toc:s};function h(e){var t=e.components,n=(0,l.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"::: {.note}\n::: {.title}\nNote\n:::"),(0,r.kt)("p",null,"\u0110\xe2y l\xe0 phi\xean b\u1ea3n vi\u1ebft c\u1ee7a B\xe0i ",(0,r.kt)("a",{parentName:"p",href:"https://youtu.be/HLJOcKlEucI"},"gi\u1ea3ng s\u1ed1\n4"),"."),(0,r.kt)("p",null,"Trong b\xe0i gi\u1ea3ng n\xe0y, ch\xfang ta t\xecm hi\u1ec3u v\u1ec1 \u0110\u01a1n nguy\xean. \u0110\u1eb7c bi\u1ec7t l\xe0 c\xe1c\nmonads EmulatorTrace v\xe0 Contract..\n:::"),(0,r.kt)("p",null,"T\u1ed5ng quat ","-","-","-","-","-","-","-","-"),(0,r.kt)("p",null,"Ch\xfang t\xf4i \u0111\xe3 d\xe0nh hai b\xe0i gi\u1ea3ng cu\u1ed1i c\xf9ng \u0111\u1ec3 n\xf3i v\u1ec1 ph\u1ea7n on-chain c\u1ee7a\nPlutus - logic x\xe1c th\u1ef1c \u0111\u01b0\u1ee3c bi\xean d\u1ecbch th\xe0nh t\u1eadp l\u1ec7nh Plutus v\xe0 th\u1ef1c s\u1ef1\ns\u1ed1ng tr\xean blockchain v\xe0 \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n b\u1edfi c\xe1c n\xfat x\xe1c th\u1ef1c giao d\u1ecbch."),(0,r.kt)("p",null,"C\xf2n r\u1ea5t nhi\u1ec1u \u0111i\u1ec1u \u0111\u1ec3 n\xf3i v\u1ec1 b\u1ed9 ph\u1eadn on-chain \u0111\xf3."),(0,r.kt)("p",null,"Ch\xfang t\xf4i ch\u01b0a xem x\xe9t c\xe1c v\xed d\u1ee5 ph\u1ee9c t\u1ea1p h\u01a1n v\u1ec1 x\xe1c th\u1ef1c s\u1eed d\u1ee5ng ng\u1eef\nc\u1ea3nh ph\u1ee9c t\u1ea1p h\u01a1n v\xe0 ch\xfang t\xf4i ch\u01b0a th\u1ea5y c\xe1ch m\xe3 th\xf4ng b\xe1o g\u1ed1c ho\u1ea1t \u0111\u1ed9ng\nnh\u01b0 th\u1ebf n\xe0o (t\u1eadp l\u1ec7nh Plutus c\u0169ng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 x\xe1c th\u1ef1c vi\u1ec7c \u0111\xfac v\xe0\n\u0111\u1ed1t m\xe3 th\xf4ng b\xe1o g\u1ed1c)."),(0,r.kt)("p",null,"Ch\xfang ta ch\u1eafc ch\u1eafn s\u1ebd ph\u1ea3i n\xf3i v\u1ec1 nh\u1eefng ch\u1ee7 \u0111\u1ec1 \u0111\xf3, v\xe0 quay l\u1ea1i v\u1ea5n \u0111\u1ec1\n\u0111\xf3."),(0,r.kt)("p",null,"Tuy nhi\xean, tr\u01b0\u1edbc khi \u0111i v\xe0o qu\xe1 nhi\u1ec1u ch\u1ee7 \u0111\u1ec1 ph\u1ee9c t\u1ea1p v\u1ec1 x\xe1c th\u1ef1c tr\xean\nchu\u1ed7i, ch\xfang ta kh\xf4ng \u0111\u01b0\u1ee3c b\u1ecf qua ph\u1ea7n ngo\xe0i chu\u1ed7i, v\xec n\xf3 c\u0169ng quan\ntr\u1ecdng kh\xf4ng k\xe9m."),(0,r.kt)("p",null,"Ph\u1ea7n on-chain \u0111\u1ea3m nh\u1eadn vi\u1ec7c x\xe1c th\u1ef1c nh\u01b0ng \u0111\u1ec3 c\xf3 th\u1ee9 g\xec \u0111\xf3 \u0111\u01b0\u1ee3c x\xe1c\nth\u1ef1c, ch\xfang ta ph\u1ea3i x\xe2y d\u1ef1ng m\u1ed9t giao d\u1ecbch v\xe0 g\u1eedi n\xf3 l\xean blockchain. V\xe0,\n\u0111\xf3 l\xe0 nh\u1eefng g\xec ph\u1ea7n off-chain th\u1ef1c hi\u1ec7n."),(0,r.kt)("p",null,"V\xec v\u1eady, ch\xfang ta s\u1ebd b\u1eaft \u0111\u1ea7u n\xf3i v\u1ec1 c\xe1ch vi\u1ebft m\xe3 Plutus ngo\xe0i chu\u1ed7i."),(0,r.kt)("p",null,"Th\u1eadt kh\xf4ng may, c\xf3 m\u1ed9t v\u1ea5n \u0111\u1ec1 nh\u1ecf li\xean quan \u0111\u1ebfn c\xe1c t\xednh n\u0103ng Haskell\nc\u1ea7n thi\u1ebft."),(0,r.kt)("p",null,"Ph\u1ea7n on-chain m\xe0 ch\xfang ta \u0111\xe3 th\u1ea5y cho \u0111\u1ebfn nay h\u01a1i xa l\u1ea1 v\xe0 c\u1ea7n l\xe0m quen\nm\u1ed9t ch\xfat, do th\u1ef1c t\u1ebf l\xe0 ch\xfang ta c\xf3 th\xeam s\u1ef1 ph\u1ee9c t\u1ea1p c\u1ee7a qu\xe1 tr\xecnh bi\xean\nd\u1ecbch sang t\u1eadp l\u1ec7nh Plutus. Nh\u01b0ng, ch\xfang ta kh\xf4ng th\u1ef1c s\u1ef1 ph\u1ea3i lo l\u1eafng v\u1ec1\n\u0111i\u1ec1u \u0111\xf3 n\u1ebfu ch\xfang ta s\u1eed d\u1ee5ng ph\xe9p thu\u1eadt Template Haskell. Trong tr\u01b0\u1eddng\nh\u1ee3p \u0111\xf3, h\xe0m x\xe1c nh\u1eadn ch\u1ec9 l\xe0 m\u1ed9t h\xe0m \u0111\u01a1n gi\u1ea3n."),(0,r.kt)("p",null,"V\xe0 n\xf3 th\u1ef1c s\u1ef1 l\xe0 m\u1ed9t h\xe0m Haskell r\u1ea5t \u0111\u01a1n gi\u1ea3n theo quan \u0111i\u1ec3m k\u1ef9 thu\u1eadt.\nCh\xfang t\xf4i kh\xf4ng s\u1eed d\u1ee5ng b\u1ea5t k\u1ef3 t\xednh n\u0103ng Haskell \u01b0a th\xedch n\xe0o \u0111\u1ec3 vi\u1ebft\nh\xe0m n\xe0y."),(0,r.kt)("p",null,"M\u1ed9t trong nh\u1eefng l\xfd do cho \u0111i\u1ec1u \u0111\xf3 l\xe0 c\xe1ch th\u1ee9c ho\u1ea1t \u0111\u1ed9ng c\u1ee7a qu\xe1 tr\xecnh\nbi\xean d\u1ecbch Plutus. Ch\xfang t\xf4i \u0111\xe3 th\u1ea5y l\xe0m th\u1ebf n\xe0o \u0111\u1ec3 vi\u1ec7c bi\xean d\u1ecbch sang\nPlutus th\xe0nh c\xf4ng, t\u1ea5t c\u1ea3 m\xe3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng b\u1edfi h\xe0m x\xe1c nh\u1eadn ph\u1ea3i c\xf3 s\u1eb5n\ntrong Oxford Brackets. \u0110i\u1ec1u n\xe0y c\xf3 ngh\u0129a l\xe0 t\u1ea5t c\u1ea3 c\xe1c ch\u1ee9c n\u0103ng \u0111\u01b0\u1ee3c s\u1eed\nd\u1ee5ng b\u1edfi ch\u1ee9c n\u0103ng ",(0,r.kt)("em",{parentName:"p"},"mkValidator")," ph\u1ea3i s\u1eed d\u1ee5ng pragma INLINABLE."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"{-# INLINABLE mkValidator #-}\nmkValidator :: Data -> Data -> Data -> ()\nmkValidator _ _ _ = ()\n\n$$(PlutusTx.compile [|| mkValidator ||])\n")),(0,r.kt)("p",null,"V\xe0 h\xe3y nh\u1edb l\u1ea1i r\u1eb1ng v\xec c\xe1c h\xe0m Haskell ti\xeau chu\u1ea9n kh\xf4ng c\xf3 pragma C\xd3 TH\u1ec2\nL\u1ec6NH n\xe0y, n\xean c\xf3 m\u1ed9t m\xf4-\u0111un Plutus Prelude m\u1edbi t\u01b0\u01a1ng t\u1ef1 nh\u01b0 Haskell\nPrelude ti\xeau chu\u1ea9n, nh\u01b0ng v\u1edbi c\xe1c ch\u1ee9c n\u0103ng \u0111\u01b0\u1ee3c x\xe1c \u0111\u1ecbnh v\u1edbi pragma\nINLINABLE."),(0,r.kt)("p",null,"Nh\u01b0ng, t\u1ea5t nhi\xean, c\xf3 h\xe0ng tr\u0103m th\u01b0 vi\u1ec7n Haskell ngo\xe0i kia v\xe0 h\u1ea7u h\u1ebft\nch\xfang kh\xf4ng \u0111\u01b0\u1ee3c vi\u1ebft v\u1edbi Plutus, v\xec v\u1eady ch\xfang t\xf4i kh\xf4ng th\u1ec3 s\u1eed d\u1ee5ng\nch\xfang trong qu\xe1 tr\xecnh x\xe1c th\u1ef1c. V\xe0, \u0111i\u1ec1u \u0111\xf3 c\xf3 t\xe1c d\u1ee5ng l\xe0 x\xe1c th\u1ef1c b\xean\ntrong Haskell s\u1ebd t\u01b0\u01a1ng \u0111\u1ed1i \u0111\u01a1n gi\u1ea3n v\xe0 s\u1ebd kh\xf4ng c\xf3 nhi\u1ec1u ph\u1ee5 thu\u1ed9c."),(0,r.kt)("h2",{id:"monads"},"Monads"),(0,r.kt)("p",null,"Trong ph\u1ea7n off-chain c\u1ee7a Plutus, t\xecnh h\xecnh \u0111\xe3 \u0111\u1ea3o ng\u01b0\u1ee3c. Ch\xfang ta kh\xf4ng\nph\u1ea3i lo l\u1eafng v\u1ec1 vi\u1ec7c bi\xean d\u1ecbch sang t\u1eadp l\u1ec7nh Plutus - n\xf3 ch\u1ec9 l\xe0 Haskell\n\u0111\u01a1n gi\u1ea3n. Tuy nhi\xean, m\u1eb7t tr\xe1i c\u1ee7a n\xf3 l\xe0, c\xe1ch n\xf3 \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n, n\xf3 s\u1eed\nd\u1ee5ng c\xe1c t\xednh n\u0103ng Haskell ph\u1ee9c t\u1ea1p h\u01a1n nhi\u1ec1u - v\xed d\u1ee5 nh\u01b0 c\xe1i g\u1ecdi l\xe0 h\u1ec7\nth\u1ed1ng hi\u1ec7u \u1ee9ng, ph\xe1t tr\u1ef1c tuy\u1ebfn v\xe0 \u0111\u1eb7c bi\u1ec7t l\xe0 monads."),(0,r.kt)("p",null,"T\u1ea5t c\u1ea3 m\xe3 off-chain (m\xe3 v\xed), \u0111\u01b0\u1ee3c vi\u1ebft b\u1eb1ng m\u1ed9t \u0111\u01a1n nguy\xean \u0111\u1eb7c bi\u1ec7t -\n\u0110\u01a1n nguy\xean h\u1ee3p \u0111\u1ed3ng."),(0,r.kt)("p",null,"C\xe1c tu vi\u1ec7n n\u1ed5i ti\u1ebfng trong th\u1ebf gi\u1edbi Haskell. \u0110\xe2y th\u01b0\u1eddng l\xe0 tr\u1edf ng\u1ea1i \u0111\u1ea7u\nti\xean khi b\u1eaft \u0111\u1ea7u l\u1eadp tr\xecnh vi\xean Haskell."),(0,r.kt)("p",null,"C\xf3 r\u1ea5t nhi\u1ec1u h\u01b0\u1edbng d\u1eabn c\u1ed1 g\u1eafng gi\u1ea3i th\xedch c\xe1c Monads. Monads \u0111\u01b0\u1ee3c so\ns\xe1nh v\u1edbi burritos, v\xe0 t\u1ea5t c\u1ea3 c\xe1c lo\u1ea1i \u1ea9n d\u1ee5 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 c\u1ed1 g\u1eafng gi\u1ea3i\nth\xedch kh\xe1i ni\u1ec7m. Nh\u01b0ng \u1edf \u0111\xe2y, \xedt nh\u1ea5t ch\xfang ta h\xe3y c\u1ed1 g\u1eafng cung c\u1ea5p m\u1ed9t\nkh\xf3a h\u1ecdc c\u01a1 b\u1ea3n v\u1ec1 monads cho nh\u1eefng ng\u01b0\u1eddi m\u1edbi s\u1eed d\u1ee5ng Haskell."),(0,r.kt)("p",null,"Tr\u01b0\u1edbc khi \u0111\u1ebfn v\u1edbi c\xe1c \u0111\u01a1n nguy\xean chung, ch\xfang ta s\u1ebd b\u1eaft \u0111\u1ea7u v\u1edbi IO , \u0111\xf3\nl\xe0 c\xe1ch x\u1eed l\xfd c\xe1c t\xe1c d\u1ee5ng ph\u1ee5 c\u1ee7a IO trong Haskell. Tuy nhi\xean, tr\u01b0\u1edbc\nkhi \u0111\u1ebfn v\u1edbi Haskell, ch\xfang ta h\xe3y xem x\xe9t m\u1ed9t ng\xf4n ng\u1eef ch\xednh th\u1ed1ng nh\u01b0\nJava."),(0,r.kt)("p",null,"H\xe3y xem x\xe9t ph\u01b0\u01a1ng ph\xe1p Java sau \u0111\xe2y."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.java}"},"public static int foo() {\n   ...\n}\n")),(0,r.kt)("p",null,"H\xe0m n\xe0y kh\xf4ng c\xf3 \u0111\u1ed1i s\u1ed1 v\xe0 n\xf3 tr\u1ea3 v\u1ec1 ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),". H\xe3y t\u01b0\u1edfng t\u01b0\u1ee3ng n\xf3 \u0111\u01b0\u1ee3c g\u1ecdi\nhai l\u1ea7n trong m\xe3."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.java}"},"...\nfinal int a = foo();\n...\nfinal int b = foo();\n")),(0,r.kt)("p",null,"B\xe2y gi\u1edd, ch\xfang ta l\u01b0u \xfd r\u1eb1ng, ch\u1eebng n\xe0o ch\xfang ta kh\xf4ng bi\u1ebft \u0111i\u1ec1u g\xec \u0111ang\nx\u1ea3y ra b\xean trong h\xe0m foo(), th\xec gi\xe1 tr\u1ecb tr\u1ea3 v\u1ec1 c\u1ee7a bi\u1ec3u th\u1ee9c sau l\xe0\nkh\xf4ng x\xe1c \u0111\u1ecbnh."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.java}"},"a == b; // true or false? at compile time, we don't know\n")),(0,r.kt)("p",null,"Ch\xfang t\xf4i kh\xf4ng bi\u1ebft c\xf3 ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," gi\u1ed1ng nh\u01b0 ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," v\u1eady kh\xf4ng v\xec trong Java, ho\xe0n\nto\xe0n c\xf3 th\u1ec3 x\u1ea3y ra m\u1ed9t s\u1ed1 IO b\xean trong ",(0,r.kt)("inlineCode",{parentName:"p"},"foo"),". V\xed d\u1ee5: c\xf3 m\xe3 l\xe0 m\xe3 y\xeau c\u1ea7u\nng\u01b0\u1eddi d\xf9ng nh\u1eadp \u0111\u1ea7u v\xe0o tr\xean b\u1ea3ng \u0111i\u1ec1u khi\u1ec3n v\xe0 s\u1eed d\u1ee5ng m\xe3 n\xe0y \u0111\u1ec3 t\xednh\nto\xe1n gi\xe1 tr\u1ecb tr\u1ea3 v\u1ec1."),(0,r.kt)("p",null,"\u0110i\u1ec1u n\xe0y c\xf3 ngh\u0129a l\xe0, \u0111\u1ec3 l\u1eadp lu\u1eadn v\u1ec1 m\xe3, ch\xfang ta c\u1ea7n ph\u1ea3i nh\xecn v\xe0o b\xean\ntrong ",(0,r.kt)("inlineCode",{parentName:"p"},"foo"),", \u0111i\u1ec1u n\xe0y l\xe0m cho vi\u1ec7c th\u1eed nghi\u1ec7m tr\u1edf n\xean kh\xf3 kh\u0103n h\u01a1n. V\xe0\nn\xf3 c\xf3 ngh\u0129a l\xe0, ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," v\xed d\u1ee5 , \u0111\xf3 l\xe0 l\u1ec7nh g\u1ecdi tr\u1ea3 v\u1ec1 \u0111\u1ea7u ti\xean ",(0,r.kt)("inlineCode",{parentName:"p"},"13"),"- ch\xfang\nta kh\xf4ng th\u1ec3 thay th\u1ebf t\u1ea5t c\u1ea3 c\xe1c l\u1ec7nh g\u1ecdi kh\xe1c \u0111\u1ebfn ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," b\u1eb1ng gi\xe1 tr\u1ecb\ntr\u1ea3 v\u1ec1 \u0111\xe3 bi\u1ebft c\u1ee7a ",(0,r.kt)("inlineCode",{parentName:"p"},"13"),"."),(0,r.kt)("p",null,"\u1ede Haskell, t\xecnh h\xecnh r\u1ea5t kh\xe1c v\xec Haskell l\xe0 m\u1ed9t ng\xf4n ng\u1eef ch\u1ee9c n\u0103ng thu\u1ea7n\nt\xfay. Ch\u1eef k\xfd t\u01b0\u01a1ng \u0111\u01b0\u01a1ng trong Haskell s\u1ebd gi\u1ed1ng nh\u01b0 sau:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo :: Int\nfoo = ...\n")),(0,r.kt)("p",null,"B\xe2y gi\u1edd, n\u1ebfu ch\xfang ta g\u1eb7p tr\u01b0\u1eddng h\u1ee3p ch\xfang ta g\u1ecdi ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," hai l\u1ea7n, m\u1eb7c d\xf9\nch\xfang ta kh\xf4ng bi\u1ebft gi\xe1 tr\u1ecb c\u1ee7a ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," l\xe0 g\xec, ch\xfang ta bi\u1ebft ch\u1eafc r\u1eb1ng hai\ngi\xe1 tr\u1ecb tr\u1ea3 v\u1ec1 s\u1ebd gi\u1ed1ng nhau."),(0,r.kt)("p",null,"\u0110\xe2y l\xe0 m\u1ed9t t\xednh n\u0103ng r\u1ea5t quan tr\u1ecdng \u0111\u01b0\u1ee3c g\u1ecdi l\xe0 t\xednh minh b\u1ea1ch tham\nchi\u1ebfu . Tr\xean th\u1ef1c t\u1ebf, c\xf3 m\u1ed9t s\u1ed1 c\u1eeda tho\xe1t hi\u1ec3m \u0111\u1ec3 gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 n\xe0y,\nnh\u01b0ng ch\xfang ta c\xf3 th\u1ec3 b\u1ecf qua \u0111i\u1ec1u n\xe0y."),(0,r.kt)("p",null,"\u0110i\u1ec1u n\xe0y l\xe0m cho c\xe1c t\xe1c v\u1ee5 nh\u01b0 t\xe1i c\u1ea5u tr\xfac v\xe0 ki\u1ec3m tra d\u1ec5 d\xe0ng h\u01a1n\nnhi\u1ec1u."),(0,r.kt)("p",null,"\u0110i\u1ec1u n\xe0y l\xe0 r\u1ea5t t\u1ed1t, nh\u01b0ng b\u1ea1n c\u1ea7n c\xf3 t\xe1c d\u1ee5ng ph\u1ee5 \u0111\u1ec3 c\xf3 \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn\nth\u1ebf gi\u1edbi. N\u1ebfu kh\xf4ng, t\u1ea5t c\u1ea3 nh\u1eefng g\xec ch\u01b0\u01a1ng tr\xecnh c\u1ee7a b\u1ea1n l\xe0m l\xe0 l\xe0m\nn\xf3ng b\u1ed9 x\u1eed l\xfd."),(0,r.kt)("p",null,"B\u1ea1n c\u1ea7n \u0111\u1ea7u v\xe0o v\xe0 \u0111\u1ea7u ra. B\u1ea1n ph\u1ea3i c\xf3 kh\u1ea3 n\u0103ng ghi k\u1ebft qu\u1ea3 \u0111\u1ea7u ra ra\nm\xe0n h\xecnh, ho\u1eb7c \u0111\u1ecdc \u0111\u1ea7u v\xe0o t\u1eeb b\xe0n ph\xedm, k\u1ebft n\u1ed1i m\u1ea1ng ho\u1eb7c t\u1ec7p, ch\u1eb3ng\nh\u1ea1n."),(0,r.kt)("p",null,"C\xf3 m\u1ed9t ",(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=iSmkqocn0oQ"},"video n\u1ed5i ti\u1ebfng c\u1ee7a Simon Peyton-Jones l\xe0 Haskell Is\nUseless")," gi\u1ea3i th\xedch r\u1eb1ng\nng\xf4n ng\u1eef thu\u1ea7n t\xfay, kh\xf4ng c\xf3 t\xe1c d\u1ee5ng ph\u1ee5 th\xec r\u1ea5t \u0111\u1eb9p v\u1ec1 m\u1eb7t to\xe1n h\u1ecdc,\nnh\u01b0ng cu\u1ed1i c\xf9ng th\xec b\u1ea1n c\u0169ng c\u1ea7n c\xf3 t\xe1c d\u1ee5ng ph\u1ee5 \u0111\u1ec3 bi\u1ebfn b\u1ea5t c\u1ee9 \u0111i\u1ec1u g\xec\nx\u1ea3y ra."),(0,r.kt)("p",null,"V\xe0 Haskell c\xf3 m\u1ed9t c\xe1ch \u0111\u1ec3 x\u1eed l\xfd c\xe1c t\xe1c d\u1ee5ng ph\u1ee5 v\xe0 \u0111\xf3 l\xe0 \u0110\u01a1n nguy\xean IO.\nTuy nhi\xean, \u0111\u1eebng lo l\u1eafng v\u1ec1 ph\u1ea7n \u0111\u01a1n nguy\xean."),(0,r.kt)("p",null,"\u0110\xe2y l\xe0 c\xe1ch ch\xfang t\xf4i l\xe0m \u0111i\u1ec1u \u0111\xf3 trong Haskell."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo :: IO Int\nfoo = ...\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"IO")," l\xe0 m\u1ed9t ph\u01b0\u01a1ng th\u1ee9c kh\u1edfi t\u1ea1o ki\u1ec3u nh\u1eadn m\u1ed9t \u0111\u1ed1i s\u1ed1, gi\u1ed1ng nh\u01b0 m\u1ed9t s\u1ed1\nv\xed d\u1ee5 kh\xe1c v\u1ec1 c\xe1c h\xe0m t\u1ea1o ki\u1ec3u nh\u01b0 ",(0,r.kt)("em",{parentName:"p"},"Maybe")," and ",(0,r.kt)("em",{parentName:"p"},"List")," . Tuy nhi\xean, kh\xf4ng\ngi\u1ed1ng nh\u01b0 nh\u1eefng v\xed d\u1ee5 \u0111\xf3, ",(0,r.kt)("em",{parentName:"p"},"IO")," \u0111\u1eb7c bi\u1ec7t, theo ngh\u0129a l\xe0 b\u1ea1n kh\xf4ng th\u1ec3\ntri\u1ec3n khai n\xf3 b\u1eb1ng ch\xednh ng\xf4n ng\u1eef. N\xf3 l\xe0 m\u1ed9t nguy\xean th\u1ee7y \u0111\u01b0\u1ee3c t\xedch h\u1ee3p\ns\u1eb5n."),(0,r.kt)("p",null,"Gi\xe1 tr\u1ecb tr\u1ea3 v\u1ec1 ",(0,r.kt)("em",{parentName:"p"},"IO Int")," cho ch\xfang ta bi\u1ebft r\u1eb1ng \u0111\xe2y l\xe0 m\u1ed9t c\xf4ng th\u1ee9c \u0111\u1ec3\nt\xednh Int v\xe0 c\xf4ng th\u1ee9c n\xe0y c\xf3 th\u1ec3 g\xe2y ra c\xe1c ph\u1ea3n \u1ee9ng ph\u1ee5. M\u1ed9t danh s\xe1ch\nc\xe1c h\u01b0\u1edbng d\u1eabn cho m\xe1y t\xednh bi\u1ebft ph\u1ea3i l\xe0m g\xec \u0111\u1ec3 k\u1ebft th\xfac v\u1edbi m\u1ed9t ",(0,r.kt)("em",{parentName:"p"},"Int")," ."),(0,r.kt)("p",null,"\u0110i\u1ec1u quan tr\u1ecdng c\u1ea7n l\u01b0u \xfd l\xe0 t\xednh minh b\u1ea1ch c\u1ee7a tham chi\u1ebfu kh\xf4ng b\u1ecb ph\xe1\nv\u1ee1 \u1edf \u0111\xe2y. K\u1ebft qu\u1ea3 \u0111\xe1nh gi\xe1 foo l\xe0 ch\xednh c\xf4ng th\u1ee9c, kh\xf4ng ph\u1ea3i gi\xe1 tr\u1ecb\n",(0,r.kt)("em",{parentName:"p"},"Int")," . V\xe0 v\xec c\xf4ng th\u1ee9c lu\xf4n gi\u1ed1ng nhau, n\xean t\xednh minh b\u1ea1ch c\u1ee7a tham\nchi\u1ebfu \u0111\u01b0\u1ee3c duy tr\xec."),(0,r.kt)("p",null,"C\xe1ch duy nh\u1ea5t \u0111\u1ec3 th\u1ef1c s\u1ef1 th\u1ef1c hi\u1ec7n m\u1ed9t c\xf4ng th\u1ee9c nh\u01b0 v\u1eady trong ch\u01b0\u01a1ng\ntr\xecnh Haskell l\xe0 t\u1eeb \u0111i\u1ec3m nh\u1eadp ch\xednh c\u1ee7a ch\u01b0\u01a1ng tr\xecnh - h\xe0m ch\xednh . B\u1ea1n\nc\u0169ng c\xf3 th\u1ec3 th\u1ef1c hi\u1ec7n c\xe1c h\xe0nh \u0111\u1ed9ng IO trong REPL."),(0,r.kt)("h3",{id:"hello-world"},"Hello World"),(0,r.kt)("p",null,"Hello World in Haskell tr\xf4ng nh\u01b0 th\u1ebf n\xe0y:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'main :: IO ()\nmain = putStrLn "Hello, world!"\n')),(0,r.kt)("p",null,"\u1ede \u0111\xe2y, ",(0,r.kt)("em",{parentName:"p"},"main")," l\xe0 m\u1ed9t c\xf4ng th\u1ee9c th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 t\xe1c d\u1ee5ng ph\u1ee5 v\xe0 tr\u1ea3 v\u1ec1\n\u0110\u01a1n v\u1ecb - kh\xf4ng c\xf3 g\xec \u0111\xe1ng quan t\xe2m."),(0,r.kt)("p",null,"H\xe3y xem ",(0,r.kt)("em",{parentName:"p"},"putStrLn")," trong REPL. Ch\xfang t\xf4i th\u1ea5y r\u1eb1ng \u0111\xf3 l\xe0 m\u1ed9t h\xe0nh \u0111\u1ed9ng\nIO s\u1eed d\u1ee5ng ",(0,r.kt)("em",{parentName:"p"},"String")," v\xe0 kh\xf4ng tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 th\xfa v\u1ecb n\xe0o."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> :t putStrLn\nputStrLn :: String -> IO ()\n\nPrelude Week04.Contract> :t putStrLn "Hello, world!"\nputStrLn "Hello, world!" :: IO ()\n')),(0,r.kt)("p",null,"Ch\xfang t\xf4i c\u0169ng c\xf3 th\u1ec3 ch\u1ea1y \u0111i\u1ec1u n\xe0y. M\u1edf \u1ee9ng d\u1ee5ng / t\u1ec7p Main.sh v\xe0 ch\u1ec9nh\ns\u1eeda ch\u1ee9c n\u0103ng ch\xednh \u0111\u1ec3 n\xf3 \u0111\u1ecdc:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'main :: IO ()\nmain = putStrLn "Hello, world!"\n')),(0,r.kt)("p",null,"Sau \u0111\xf3 ch\u1ea1y"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.bash}"},"cabal run hello\n")),(0,r.kt)("p",null,"Ch\xfang ta s\u1ebd xem x\xe9t nhanh t\u1ec7p cabal ngay b\xe2y gi\u1edd."),(0,r.kt)("p",null,"Trong c\xe1c b\xe0i gi\u1ea3ng tr\u01b0\u1edbc, ch\xfang ta ch\u1ec9 c\u1ea7n ph\u1ea7n th\u01b0 vi\u1ec7n ",(0,r.kt)("em",{parentName:"p"},"library"),"\ntrong t\u1ec7p ",(0,r.kt)("em",{parentName:"p"},"plutus-pioneer-program-week04.cabal")," v\xec ch\xfang ta ch\u1ec9 x\u1eed l\xfd\nc\xe1c h\xe0m th\u01b0 vi\u1ec7n. B\xe2y gi\u1edd, ch\xfang ta c\u1ea7n th\xeam m\u1ed9t kh\u1ed5 th\u01a1 c\xf3 th\u1ec3 th\u1ef1c thi\n\u0111\u01b0\u1ee3c ."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.cabal}"},"executable hello\nhs-source-dirs:      app\nmain-is:             hello.hs\nbuild-depends:       base ^>=4.14.1.0\ndefault-language:    Haskell2010\nghc-options:         -Wall -O2\n")),(0,r.kt)("p",null,"\u0110i\u1ec1u n\xe0y ch\u1ec9 \u0111\u1ecbnh th\u01b0 m\u1ee5c ngu\u1ed3n v\xe0 t\u1ec7p n\xe0o gi\u1eef ch\u1ee9c n\u0103ng ch\xednh. Th\xf4ng\nth\u01b0\u1eddng t\xean t\u1ec7p ph\u1ea3i kh\u1edbp v\u1edbi t\xean m\xf4-\u0111un, nh\u01b0ng ",(0,r.kt)("em",{parentName:"p"},"main")," l\xe0 m\u1ed9t ngo\u1ea1i l\u1ec7."),(0,r.kt)("p",null,"Thay v\xec ch\u1ec9 y\xeau c\u1ea7u lo\u1ea1i ",(0,r.kt)("em",{parentName:"p"},"putStrLn")," , ch\xfang ta c\xf3 th\u1ec3 ch\u1ea1y n\xf3 trong\nREPL. Nh\u01b0 \u0111\xe3 \u0111\u1ec1 c\u1eadp, REPL cho ph\xe9p ch\xfang ta th\u1ef1c hi\u1ec7n c\xe1c h\xe0nh \u0111\u1ed9ng IO."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> putStrLn "Hello, world!"\nHello, world!\n')),(0,r.kt)("h3",{id:"getline"},"getLine"),(0,r.kt)("p",null,"H\xe3y xem ",(0,r.kt)("em",{parentName:"p"},"getLine")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :t getLine\ngetLine :: IO String\n")),(0,r.kt)("p",null,"\u0110i\u1ec1u n\xe0y cho th\u1ea5y r\u1eb1ng \u0111\xf3 l\xe0 m\u1ed9t c\xf4ng th\u1ee9c, c\xf3 th\u1ec3 t\u1ea1o ra c\xe1c hi\u1ec7u \u1ee9ng\nph\u1ee5, khi \u0111\u01b0\u1ee3c th\u1ef1c thi s\u1ebd t\u1ea1o ra m\u1ed9t Chu\u1ed7i . Trong tr\u01b0\u1eddng h\u1ee3p getLine ,\nt\xe1c d\u1ee5ng ph\u1ee5 \u0111\u01b0\u1ee3c \u0111\u1ec1 c\u1eadp l\xe0 n\xf3 s\u1ebd \u0111\u1ee3i ng\u01b0\u1eddi d\xf9ng nh\u1eadp t\u1eeb b\xe0n ph\xedm."),(0,r.kt)("p",null,"N\u1ebfu ch\xfang ta th\u1ef1c thi getLine trong REPL."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> getLine\n")),(0,r.kt)("p",null,"N\xf3 ch\u1edd nh\u1eadp b\xe0n ph\xedm. Sau \u0111\xf3, n\u1ebfu ch\xfang ta nh\u1eadp m\u1ed9t c\xe1i g\xec \u0111\xf3, n\xf3 s\u1ebd tr\u1ea3\nv\u1ec1 k\u1ebft qu\u1ea3."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Haskell\n"Haskell"\n')),(0,r.kt)("p",null,"C\xf3 m\u1ed9t lo\u1ea1t c\xe1c h\xe0nh \u0111\u1ed9ng IO \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong Haskell \u0111\u1ec3 th\u1ef1c hi\u1ec7n\nt\u1ea5t c\u1ea3 c\xe1c lo\u1ea1i nh\u01b0 \u0111\u1ecdc t\u1ec7p, ghi t\u1ec7p, \u0111\u1ecdc t\u1eeb v\xe0 ghi v\xe0o \u1ed5 c\u1eafm."),(0,r.kt)("p",null,"Nh\u01b0ng cho d\xf9 b\u1ea1n c\xf3 bao nhi\xeau h\xe0nh \u0111\u1ed9ng \u0111\u01b0\u1ee3c x\xe1c \u0111\u1ecbnh tr\u01b0\u1edbc, \u0111i\u1ec1u \u0111\xf3 s\u1ebd\nkh\xf4ng bao gi\u1edd l\xe0 \u0111\u1ee7 \u0111\u1ec3 \u0111\u1ea1t \u0111\u01b0\u1ee3c \u0111i\u1ec1u g\xec \u0111\xf3 ph\u1ee9c t\u1ea1p, v\xec v\u1eady c\u1ea7n ph\u1ea3i c\xf3\nc\xe1ch \u0111\u1ec3 k\u1ebft h\u1ee3p c\xe1c h\xe0nh \u0111\u1ed9ng IO nguy\xean th\u1ee7y n\xe0y th\xe0nh nh\u1eefng c\xf4ng th\u1ee9c\nl\u1edbn h\u01a1n, ph\u1ee9c t\u1ea1p h\u01a1n."),(0,r.kt)("p",null,"M\u1ed9t \u0111i\u1ec1u ch\xfang ta c\xf3 th\u1ec3 l\xe0m l\xe0 s\u1eed d\u1ee5ng phi\xean b\u1ea3n ki\u1ec3u ",(0,r.kt)("em",{parentName:"p"},"Functor")," c\u1ee7a IO.\nH\xe3y xem x\xe9t c\xe1c tr\u01b0\u1eddng h\u1ee3p lo\u1ea1i c\u1ee7a ",(0,r.kt)("em",{parentName:"p"},"IO")," trong REPL."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i IO\ntype IO :: * -> *\nnewtype IO a\n= ghc-prim-0.6.1:GHC.Types.IO (ghc-prim-0.6.1:GHC.Prim.State#\n                                 ghc-prim-0.6.1:GHC.Prim.RealWorld\n                                 -> (# ghc-prim-0.6.1:GHC.Prim.State#\n                                       ghc-prim-0.6.1:GHC.Prim.RealWorld,\n                                       a #))\n   -- Defined in \u2018ghc-prim-0.6.1:GHC.Types\u2019\ninstance Applicative IO -- Defined in \u2018GHC.Base\u2019\ninstance Functor IO -- Defined in \u2018GHC.Base\u2019\ninstance Monad IO -- Defined in \u2018GHC.Base\u2019\ninstance Monoid a => Monoid (IO a) -- Defined in \u2018GHC.Base\u2019\ninstance Semigroup a => Semigroup (IO a) -- Defined in \u2018GHC.Base\u2019\ninstance MonadFail IO -- Defined in \u2018Control.Monad.Fail\u2019\n")),(0,r.kt)("p",null,"Ch\xfang ta th\u1ea5y c\xe1 th\u1ec3 ",(0,r.kt)("em",{parentName:"p"},"Monad")," \u0111\xe1ng s\u1ee3 , nh\u01b0ng ch\xfang ta c\u0169ng th\u1ea5y m\u1ed9t c\xe1\nth\u1ec3 ",(0,r.kt)("em",{parentName:"p"},"Functor"),". ",(0,r.kt)("em",{parentName:"p"},"Functor")," l\xe0 m\u1ed9t lo\u1ea1i l\u1edbp r\u1ea5t quan tr\u1ecdng trong Haskell.\nN\u1ebfu ch\xfang ta nh\xecn v\xe0o n\xf3 trong REPL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Functor\ntype Functor :: (* -> *) -> Constraint\nclass Functor f where\nfmap :: (a -> b) -> f a -> f b\n(<$) :: a -> f b -> f a\n{-# MINIMAL fmap #-}\n   -- Defined in \u2018GHC.Base\u2019\ninstance Functor (Either a) -- Defined in \u2018Data.Either\u2019\ninstance Functor [] -- Defined in \u2018GHC.Base\u2019\ninstance Functor Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Functor IO -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((->) r) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,,,) a b c) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,,) a b) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,) a) -- Defined in \u2018GHC.Base\u2019\n")),(0,r.kt)("p",null,"Ph\u01b0\u01a1ng ph\xe1p quan tr\u1ecdng \u1edf \u0111\xe2y l\xe0 fmap . H\xe0m th\u1ee9 hai (\\<\\$) l\xe0 m\u1ed9t h\xe0m\nti\u1ec7n l\u1ee3i."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"fmap :: (a -> b) -> f a -> f b\n")),(0,r.kt)("p",null,"H\xe0m n\xe0y ",(0,r.kt)("em",{parentName:"p"},"fmap")," , m\xe0 t\u1ea5t c\u1ea3 ",(0,r.kt)("em",{parentName:"p"},"Functor"),"s c\xf3 cho ch\xfang ta bi\u1ebft r\u1eb1ng, n\u1ebfu\nch\xfang ta c\u1ea5p cho n\xf3 quy\u1ec1n truy c\u1eadp v\xe0o m\u1ed9t h\xe0m c\xf3 th\u1ec3 bi\u1ebfn ",(0,r.kt)("em",{parentName:"p"},"a")," th\xe0ng ",(0,r.kt)("em",{parentName:"p"},"b"),"\n, th\xec n\xf3 c\xf3 th\u1ec3 bi\u1ebfn fa th\xe0nh fb cho ch\xfang ta. \u1ede \u0111\xe2y, ch\xfang ta quan t\xe2m\n\u0111\u1ebfn tr\u01b0\u1eddng h\u1ee3p f l\xe0 IO ."),(0,r.kt)("p",null,"N\u1ebfu ch\xfang ta chuy\xean bi\u1ec7t h\xf3a h\xe0m cho ",(0,r.kt)("em",{parentName:"p"},"IO")," , ch\xfang ta s\u1ebd c\xf3 m\u1ed9t h\xe0m nh\u01b0:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"fmap' :: (a -> b) -> IO a -> IO b\n")),(0,r.kt)("p",null,"L\xe0m th\u1ebf n\xe0o \u0111\u1ec3 l\xe0m vi\u1ec7c \u0111\xf3. \xc0, ",(0,r.kt)("em",{parentName:"p"},"IO a")," l\xe0 m\u1ed9t c\xf4ng th\u1ee9c c\xf3 t\xe1c d\u1ee5ng ph\u1ee5\nv\xe0 t\u1ea1o ra ",(0,r.kt)("em",{parentName:"p"},"a")," . V\xec v\u1eady, l\xe0m th\u1ebf n\xe0o \u0111\u1ec3 ch\xfang ta c\xf3 \u0111\u01b0\u1ee3c m\u1ed9t ",(0,r.kt)("em",{parentName:"p"},"b")," trong s\u1ed1\n\u0111\xf3? Ch\xfang t\xf4i th\u1ef1c hi\u1ec7n c\xf4ng th\u1ee9c, nh\u01b0ng, tr\u01b0\u1edbc khi tr\u1ea3 v\u1ec1 a , ch\xfang t\xf4i\n\xe1p d\u1ee5ng h\xe0m ",(0,r.kt)("em",{parentName:"p"},"(a -",">"," b)")," cho ",(0,r.kt)("em",{parentName:"p"},"a")," v\xe0 tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 l\xe0 ",(0,r.kt)("em",{parentName:"p"},"b")," ."),(0,r.kt)("p",null,"Trong REPL, ch\xfang ta h\xe3y xem x\xe9t h\xe0m ",(0,r.kt)("em",{parentName:"p"},"toUpper")," ."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> import Data.Char\nPrelude Data.Char Week04.Contract> :t toUpper\ntoUpper :: Char -> Char\nPrelude Data.Char Week04.Contract> toUpper 'q'\n'Q'\n")),(0,r.kt)("p",null,"N\u1ebfu ch\xfang ta mu\u1ed1n \xe1p d\u1ee5ng \u0111\u01b0\u1ee3c cho m\u1ed9t chu\u1ed7i ch\u1ee9 kh\xf4ng ph\u1ea3i l\xe0 m\u1ed9t Char\nch\xfang ta c\xf3 th\u1ec3 s\u1eed d\u1ee5ng b\u1ea3n \u0111\u1ed3 ch\u1ee9c n\u0103ng. C\xe1c chu\u1ed7i ",(0,r.kt)("em",{parentName:"p"},"String"),"s trong\nHaskell ch\u1ec9 l\xe0 ",(0,r.kt)("em",{parentName:"p"},"Char"),"s ."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Data.Char Week04.Contract> map toUpper "Haskell"\n"HASKELL"\n')),(0,r.kt)("p",null,"H\xe0m ",(0,r.kt)("em",{parentName:"p"},"map toUpper")," l\xe0 m\u1ed9t h\xe0m chuy\u1ec3n t\u1eeb ",(0,r.kt)("em",{parentName:"p"},"String")," to ",(0,r.kt)("em",{parentName:"p"},"String"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Data.Char Week04.Contract> :t map toUpper\nmap toUpper :: [Char] -> [Char]\n")),(0,r.kt)("p",null,"V\xe0 ch\xfang ta c\xf3 th\u1ec3 s\u1eed d\u1ee5ng k\u1ebft h\u1ee3p v\u1edbi ",(0,r.kt)("em",{parentName:"p"},"fmap"),". N\u1ebfu ch\xfang ta s\u1eed d\u1ee5ng ",(0,r.kt)("em",{parentName:"p"},"map\ntoUpper")," l\xe0m ch\u1ee9c n\u0103ng chuy\u1ec3n \u0111\u1ed5i ",(0,r.kt)("em",{parentName:"p"},"a")," th\xe0nh ",(0,r.kt)("em",{parentName:"p"},"b")," , ch\xfang ta c\xf3 th\u1ec3 th\u1ea5y\nlo\u1ea1i \u0111\u1ea7u ra c\u1ee7a fmap s\u1ebd nh\u01b0 th\u1ebf n\xe0o khi \xe1p d\u1ee5ng cho ",(0,r.kt)("em",{parentName:"p"},"IO a")," ."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Data.Char Week04.Contract> :t fmap (map toUpper) getLine\nfmap (map toUpper) getLine :: IO [Char]\n")),(0,r.kt)("p",null,"H\xe3y xem n\xf3 trong h\xe0nh \u0111\u1ed9ng."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Data.Char Week04.Contract> fmap (map toUpper) getLine\nhaskell\n"HASKELL"\n')),(0,r.kt)("p",null,"Ch\xfang ta c\u0169ng c\xf3 th\u1ec3 s\u1eed d\u1ee5ng to\xe1n t\u1eed ",(0,r.kt)("em",{parentName:"p"},">",">")," . \u0110i\u1ec1u n\xe0y chu\u1ed7i hai h\xe0nh\n\u0111\u1ed9ng ",(0,r.kt)("em",{parentName:"p"},"IO")," l\u1ea1i v\u1edbi nhau, b\u1ecf qua k\u1ebft qu\u1ea3 c\u1ee7a h\xe0nh \u0111\u1ed9ng \u0111\u1ea7u ti\xean. Trong v\xed\nd\u1ee5 sau, c\u1ea3 hai h\xe0nh \u0111\u1ed9ng s\u1ebd \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n theo tr\xecnh t\u1ef1."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> putStrLn "Hello" >> putStrLn "World"\nHello\nWorld\n')),(0,r.kt)("p",null,"Here, there is no result from ",(0,r.kt)("em",{parentName:"p"},"putStrLn"),", but if there were, it would\nhave been ignored. Its side effects would have been performed, its\nresult ignored, then the second ",(0,r.kt)("em",{parentName:"p"},"putStrLn")," side effects would been\nperformed before returning the result of the second call."),(0,r.kt)("p",null,"Then, there is an important operator that does not ignore the result of\nthe first ",(0,r.kt)("em",{parentName:"p"},"IO")," action, and that is called ",(0,r.kt)("em",{parentName:"p"},"bind"),". It is written as the\n",(0,r.kt)("em",{parentName:"p"},">",">","=")," symbol."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :t (>>=)\n(>>=) :: Monad m => m a -> (a -> m b) -> m b\n")),(0,r.kt)("p",null,"We see the ",(0,r.kt)("em",{parentName:"p"},"Monad")," constraint, but we can ignore that for now and just\nthink of ",(0,r.kt)("em",{parentName:"p"},"IO"),"."),(0,r.kt)("p",null,"What this says is that if I have a recipe that performs side effects\nthen gives me a result ",(0,r.kt)("em",{parentName:"p"},"a"),", and given that I have a function that takes\nan ",(0,r.kt)("em",{parentName:"p"},"a")," and gives me back a recipe that returns a ",(0,r.kt)("em",{parentName:"p"},"b"),", then I can combine\nthe recipe ",(0,r.kt)("em",{parentName:"p"},"m a")," with the recipe ",(0,r.kt)("em",{parentName:"p"},"m b")," by taking the value ",(0,r.kt)("em",{parentName:"p"},"a")," and using\nit in the recipe that results in the value ",(0,r.kt)("em",{parentName:"p"},"b"),"."),(0,r.kt)("p",null,"An example will make this clear."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> getLine >>= putStrLn\nHaskell\nHaskell\n")),(0,r.kt)("p",null,"Here, the function ",(0,r.kt)("em",{parentName:"p"},"getLine")," is of type ",(0,r.kt)("em",{parentName:"p"},"IO String"),". The return value\n",(0,r.kt)("em",{parentName:"p"},"a")," is passed to the function ",(0,r.kt)("em",{parentName:"p"},"(a -",">"," m b)")," which then generates a\nrecipe ",(0,r.kt)("em",{parentName:"p"},"putStrLn")," with an input value of ",(0,r.kt)("em",{parentName:"p"},"a")," and an output of type ",(0,r.kt)("em",{parentName:"p"},"IO\n()"),". Then, ",(0,r.kt)("em",{parentName:"p"},"putStrLn")," performs its side effects and returns ",(0,r.kt)("em",{parentName:"p"},"Unit"),"."),(0,r.kt)("p",null,"There is another, very important, way to create ",(0,r.kt)("em",{parentName:"p"},"IO")," actions, and that\nis to create recipes that immediately return results without performing\nany side effects."),(0,r.kt)("p",null,"That is done with a function called ",(0,r.kt)("em",{parentName:"p"},"return"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :t return\nreturn :: Monad m => a -> m a\n")),(0,r.kt)("p",null,"Again, it is general for any Monad, we only need to think about ",(0,r.kt)("em",{parentName:"p"},"IO"),"\nright now."),(0,r.kt)("p",null,"It takes a value ",(0,r.kt)("em",{parentName:"p"},"a")," and returns a recipe that produces the value ",(0,r.kt)("em",{parentName:"p"},"a"),".\nIn the case of ",(0,r.kt)("em",{parentName:"p"},"return"),", the recipe does not actually create any side\neffects."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> return "Haskell" :: IO String\n"Haskell"\n')),(0,r.kt)("p",null,"We needed to specify the return type so that the REPL knows which Monad\nwe are using:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> :t return "Haskell" :: IO String\nreturn "Haskell" :: IO String :: IO String\n\nPrelude Week04.Contract> :t return "Haskell"\nreturn "Haskell" :: Monad m => m [Char]\n')),(0,r.kt)("p",null,"If we now go back to our ",(0,r.kt)("em",{parentName:"p"},"main")," program, we can now write relatively\ncomplex ",(0,r.kt)("em",{parentName:"p"},"IO")," actions. For example, we can define an ",(0,r.kt)("em",{parentName:"p"},"IO")," action that\nwill ask for two strings and print result of concatenating those two\nstrings to the console."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"main :: IO ()\nmain = bar\n\nbar :: IO ()\nbar = getLine >>= \\s ->\n      getLine >>= \\t ->\n      putStrLn (s ++ t)\n")),(0,r.kt)("p",null,"And then, when we run it, the program will wait for two inputs and then\noutput the concatenated result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.bash}"},"cabal run hello\none\ntwo\nonetwo\n")),(0,r.kt)("p",null,"This is enough now for our purposes, although we won\\'t need the ",(0,r.kt)("em",{parentName:"p"},"IO"),"\nMonad until perhaps later in the course when we talk about actually\ndeploying Plutus contracts. However, the ",(0,r.kt)("em",{parentName:"p"},"IO")," Monad is an important\nexample, and a good one to start with."),(0,r.kt)("p",null,"So, for now, let\\'s completely forget about ",(0,r.kt)("em",{parentName:"p"},"IO")," and just write pure,\nfunctional Haskell, using the ",(0,r.kt)("em",{parentName:"p"},"Maybe")," type."),(0,r.kt)("h3",{id:"maybe"},"Maybe"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Maybe")," type is one of the most useful types in Haskell."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Maybe\ntype Maybe :: * -> *\ndata Maybe a = Nothing | Just a\n   -- Defined in \u2018GHC.Maybe\u2019\ninstance Applicative Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Eq a => Eq (Maybe a) -- Defined in \u2018GHC.Maybe\u2019\ninstance Functor Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Monad Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Semigroup a => Monoid (Maybe a) -- Defined in \u2018GHC.Base\u2019\ninstance Ord a => Ord (Maybe a) -- Defined in \u2018GHC.Maybe\u2019\ninstance Semigroup a => Semigroup (Maybe a)\n-- Defined in \u2018GHC.Base\u2019\ninstance Show a => Show (Maybe a) -- Defined in \u2018GHC.Show\u2019\ninstance Read a => Read (Maybe a) -- Defined in \u2018GHC.Read\u2019\ninstance Foldable Maybe -- Defined in \u2018Data.Foldable\u2019\ninstance Traversable Maybe -- Defined in \u2018Data.Traversable\u2019\ninstance MonadFail Maybe -- Defined in \u2018Control.Monad.Fail\u2019\n")),(0,r.kt)("p",null,"It is often called something like ",(0,r.kt)("em",{parentName:"p"},"Optional")," in other programming\nlanguages."),(0,r.kt)("p",null,"It has two constructors - ",(0,r.kt)("em",{parentName:"p"},"Nothing"),", which takes no arguments, and\n",(0,r.kt)("em",{parentName:"p"},"Just"),", which takes one argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data Maybe a = Nothing | Just a\n")),(0,r.kt)("p",null,"Let\\'s look at an example."),(0,r.kt)("p",null,"In Haskell, if you want to pass a ",(0,r.kt)("em",{parentName:"p"},"String")," to a value that has a ",(0,r.kt)("em",{parentName:"p"},"read"),"\ninstance, you will normally do this with the ",(0,r.kt)("em",{parentName:"p"},"read")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Week04.Maybe> read "42" :: Int\n42\n')),(0,r.kt)("p",null,"But, ",(0,r.kt)("em",{parentName:"p"},"read")," is a bit unpleasant, because if we have something that\ncan\\'t be parsed as an ",(0,r.kt)("em",{parentName:"p"},"Int"),", then we get an error."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Week04.Maybe> read "42+u" :: Int\n*** Exception: Prelude.read: no parse\n')),(0,r.kt)("p",null,"Let\\'s import ",(0,r.kt)("em",{parentName:"p"},"readMaybe")," to do it in a better way."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Maybe> import Text.Read (readMaybe)\nPrelude Text.Read Week04.Contract>\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("em",{parentName:"p"},"readMaybe")," does the same as ",(0,r.kt)("em",{parentName:"p"},"read"),", but it returns a\n",(0,r.kt)("em",{parentName:"p"},"Maybe"),", and in the case where it cannot parse, it will return a ",(0,r.kt)("em",{parentName:"p"},"Maybe"),"\ncreated with the ",(0,r.kt)("em",{parentName:"p"},"Nothing")," constructor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Text.Read Week04.Contract> readMaybe "42" :: Maybe Int\nJust 42\n\nPrelude Text.Read Week04.Contract> readMaybe "42+u" :: Maybe Int\nNothing\n')),(0,r.kt)("p",null,"Let\\'s say we want to create a new function that returns a ",(0,r.kt)("em",{parentName:"p"},"Maybe"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"foo :: String -> String -> String -> Maybe Int\n")),(0,r.kt)("p",null,"The idea is that the function should try to parse all three ",(0,r.kt)("em",{parentName:"p"},"String"),"s as\n",(0,r.kt)("em",{parentName:"p"},"Int"),"s. If all the ",(0,r.kt)("em",{parentName:"p"},"String"),"s can be successfully parsed as ",(0,r.kt)("em",{parentName:"p"},"Int"),"s, then\nwe want to add those three ",(0,r.kt)("em",{parentName:"p"},"Int"),"s to get a sum. If one of the parses\nfails, we want to return ",(0,r.kt)("em",{parentName:"p"},"Nothing"),"."),(0,r.kt)("p",null,"One way to do that would be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo :: String -> String -> String -> Maybe Int\nfoo x y z = case readMaybe x of\n   Nothing -> Nothing\n   Just k  -> case readMaybe y of\n      Nothing -> Nothing\n      Just l  -> case readMaybe z of\n            Nothing -> Nothing\n            Just m  -> Just (k + l + m)\n")),(0,r.kt)("p",null,"Let\\'s see if it works. First, the case where is succeeds:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> :l Week04.Maybe \nPrelude Week04.Maybe> foo "1" "2" "3"\nJust 6\n')),(0,r.kt)("p",null,"But, if one of the values can\\'t be parsed, we get ",(0,r.kt)("em",{parentName:"p"},"Nothing"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Maybe> foo "" "2" "3"\nNothing\n')),(0,r.kt)("p",null,"The code is not ideal because we repeat the same pattern three times.\nEach time we have to consider the two cases - whether the result of the\nread is a ",(0,r.kt)("em",{parentName:"p"},"Just")," or a ",(0,r.kt)("em",{parentName:"p"},"Nothing"),"."),(0,r.kt)("p",null,"Ask Haskellers, we hate repetition like this."),(0,r.kt)("p",null,"The thing we want to do is very simple. We want to pass the three\n",(0,r.kt)("em",{parentName:"p"},"String"),"s and add the result, but with all those cases it is very noisy\nand very ugly. We want to abstract away this pattern."),(0,r.kt)("p",null,"One way to do that would be to define something like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"bindMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b\nbindMaybe Nothing = Nothing\nbindMaybe (Just x) f = f x\n")),(0,r.kt)("p",null,"Let\\'s write the same function again using ",(0,r.kt)("em",{parentName:"p"},"bindMaybe"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo' :: String -> String -> String -> Maybe Int\nfoo' x y z = readMaybe x `bindMaybe` \\k ->\n            readMaybe y `bindMaybe` \\l ->\n            readMaybe z `bindMaybe` \\m ->\n            Just (k + l + m)\n")),(0,r.kt)("p",null,"And then, in the REPL, we get the same results for ",(0,r.kt)("em",{parentName:"p"},"foo\\'")," as we got for\n",(0,r.kt)("em",{parentName:"p"},"foo"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Maybe> foo "1" "2" "3"\nJust 6\n\nPrelude Week04.Maybe> foo "" "2" "3"\nNothing\n')),(0,r.kt)("p",null,"This does exactly the same as ",(0,r.kt)("em",{parentName:"p"},"foo"),", but it is much more compact, there\nis far less noise, and the business logic is much clearer."),(0,r.kt)("p",null,"It may, or may not, help to view the function with it not being used\nwith infix notation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Text.Read Week04.Maybe> bindMaybe (readMaybe "42" :: Maybe Int) (\\x -> Just x)\nJust 42\n')),(0,r.kt)("p",null,"Here you can see the function clearly taking the ",(0,r.kt)("em",{parentName:"p"},"Maybe")," and then the\nfunction that takes the ",(0,r.kt)("em",{parentName:"p"},"a")," from the ",(0,r.kt)("em",{parentName:"p"},"Maybe")," and uses it as the input to\na function that returns a new ",(0,r.kt)("em",{parentName:"p"},"Maybe"),"."),(0,r.kt)("p",null,"This produces nothing useful, until we add the second ",(0,r.kt)("em",{parentName:"p"},"readMaybe")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Text.Read Week04.Maybe> bindMaybe (readMaybe "42" :: Maybe Int) (\\x -> bindMaybe (readMaybe "5" :: Maybe Int) (\\y -> Just (y + x)))\nJust 47\n')),(0,r.kt)("p",null,"In some ways ",(0,r.kt)("em",{parentName:"p"},"Nothing")," is a bit like an exception in other languages. If\nany of the computations returns ",(0,r.kt)("em",{parentName:"p"},"Nothing"),", the remainder of the\ncomputations in the block are not performed and ",(0,r.kt)("em",{parentName:"p"},"Nothing")," is returned."),(0,r.kt)("h3",{id:"either"},"Either"),(0,r.kt)("p",null,"Another very useful type in Haskell is the ",(0,r.kt)("em",{parentName:"p"},"Either")," type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Either\ntype Either :: * -> * -> *\ndata Either a b = Left a | Right b\n   -- Defined in \u2018Data.Either\u2019\ninstance Applicative (Either e) -- Defined in \u2018Data.Either\u2019\ninstance (Eq a, Eq b) => Eq (Either a b)\n-- Defined in \u2018Data.Either\u2019\ninstance Functor (Either a) -- Defined in \u2018Data.Either\u2019\ninstance Monad (Either e) -- Defined in \u2018Data.Either\u2019\ninstance (Ord a, Ord b) => Ord (Either a b)\n-- Defined in \u2018Data.Either\u2019\ninstance Semigroup (Either a b) -- Defined in \u2018Data.Either\u2019\ninstance (Show a, Show b) => Show (Either a b)\n-- Defined in \u2018Data.Either\u2019\ninstance (Read a, Read b) => Read (Either a b)\n-- Defined in \u2018Data.Either\u2019\ninstance Foldable (Either a) -- Defined in \u2018Data.Foldable\u2019\ninstance Traversable (Either a) -- Defined in \u2018Data.Traversable\u2019\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Either")," takes two parameters, ",(0,r.kt)("em",{parentName:"p"},"a")," and ",(0,r.kt)("em",{parentName:"p"},"b"),". Like ",(0,r.kt)("em",{parentName:"p"},"Maybe")," it has two\nconstructors, but unlike ",(0,r.kt)("em",{parentName:"p"},"Maybe")," both take a value. It can ",(0,r.kt)("em",{parentName:"p"},"Either")," be\nan ",(0,r.kt)("em",{parentName:"p"},"a")," or a ",(0,r.kt)("em",{parentName:"p"},"b"),". The two constructors are ",(0,r.kt)("em",{parentName:"p"},"Left")," and ",(0,r.kt)("em",{parentName:"p"},"Right"),"."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> Left "Haskell" :: Either String Int\nLeft "Haskell"\n')),(0,r.kt)("p",null,"Or"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> Right 7 :: Either String Int\nRight 7\n")),(0,r.kt)("p",null,"If we take the exception analogy a little further, then one issue with\n",(0,r.kt)("em",{parentName:"p"},"Maybe")," is that if we return ",(0,r.kt)("em",{parentName:"p"},"Nothing"),", there is no error message. But,\nif we want something that gives a message, we can replace ",(0,r.kt)("em",{parentName:"p"},"Maybe")," with\nan ",(0,r.kt)("em",{parentName:"p"},"Either")," type."),(0,r.kt)("p",null,"In that case, ",(0,r.kt)("em",{parentName:"p"},"Right")," can correspond to ",(0,r.kt)("em",{parentName:"p"},"Just")," and ",(0,r.kt)("em",{parentName:"p"},"Left")," can correspond\nto an error, as ",(0,r.kt)("em",{parentName:"p"},"Nothing")," did. But, depending on what type we choose for\n",(0,r.kt)("em",{parentName:"p"},"a"),", we can give appropriate error messages."),(0,r.kt)("p",null,"Let\\'s define something called ",(0,r.kt)("em",{parentName:"p"},"readEither")," and see what it does when it\ncan and when it cannot parse its input."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'readEither :: Read a => String -> Either String a\nreadEither s case readMaybe s of\n   Nothing -> Left $ "can\'t parse: " ++ s\n   Just a  -> Right a\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Either> readEither "42" :: Either String Int\nRight 42\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Either> readEither "42+u" :: Either String Int\nLeft "can\'t parse: 42+u"\n')),(0,r.kt)("p",null,"Using this, we can now rewrite ",(0,r.kt)("em",{parentName:"p"},"foo")," in terms of ",(0,r.kt)("em",{parentName:"p"},"Either"),". First, using\nthe long-winded method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo :: String -> String -> String -> Either String Int\nfoo x y z = case readEither x of\n   Left err -> Left err\n   Right k  -> case readEither y of\n      Left err -> Left err\n      Right l  -> case readEither z of\n            Left err -> Left err\n            Right m  -> Right (k + l + m)\n")),(0,r.kt)("p",null,"Let\\'s try it. First, the happy path:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Either> foo "1" "2" "3"\nRight 6\n')),(0,r.kt)("p",null,"Then, when we have a problem:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Either> foo "ays" "2" "3"\nLeft "can\'t parse: ays"\n')),(0,r.kt)("p",null,"But, we have the same problem that we had with ",(0,r.kt)("em",{parentName:"p"},"Maybe"),"; we have a lot of\nrepetition."),(0,r.kt)("p",null,"The solution is similar."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"bindEither :: Either String a -> (a -> Either String b) -> Either String b\nbindEither (Left err) _ = Left err\nbindEither (Right x)  f = f x\n\nfoo' :: String -> String -> String -> Either String Int\nfoo' x y z = readEither x `bindEither` \\k ->\n            readEither y `bindEither` \\l ->\n            readEither z `bindEither` \\m ->\n            Right (k + l + m)\n")),(0,r.kt)("p",null,"You can run this again in the REPL and it will behave in the same way as\nits long-winded version."),(0,r.kt)("h3",{id:"writer"},"Writer"),(0,r.kt)("p",null,"So far we have looked at three examples: ",(0,r.kt)("em",{parentName:"p"},"IO a"),", ",(0,r.kt)("em",{parentName:"p"},"Maybe a")," and ",(0,r.kt)("em",{parentName:"p"},"Either\nString a"),". ",(0,r.kt)("em",{parentName:"p"},"IO a")," represents plans that can involve side effects and,\nwhen executed, produce an ",(0,r.kt)("em",{parentName:"p"},"a"),". ",(0,r.kt)("em",{parentName:"p"},"Maybe a")," and ",(0,r.kt)("em",{parentName:"p"},"Either String a")," represent\ncomputations that can produce an ",(0,r.kt)("em",{parentName:"p"},"a")," but can also fail. The difference\nbetween ",(0,r.kt)("em",{parentName:"p"},"Maybe")," and ",(0,r.kt)("em",{parentName:"p"},"Either")," is just that ",(0,r.kt)("em",{parentName:"p"},"Maybe")," does not produce any\nerror message, but ",(0,r.kt)("em",{parentName:"p"},"Either")," does."),(0,r.kt)("p",null,"Now let\\'s look at a completely different example that captures the idea\nof computations that can also produce log output."),(0,r.kt)("p",null,"We can represent that with a type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data Writer a = Writer a [String]\n   deriving Show\n")),(0,r.kt)("p",null,"As an example, let\\'s write a function that returns a ",(0,r.kt)("em",{parentName:"p"},"Writer")," for an\n",(0,r.kt)("em",{parentName:"p"},"Int")," and writes a log message."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'number :: Int -> Writer Int\nnumber n = Writer n $ ["number: " ++ show n]\n')),(0,r.kt)("p",null,"In the REPL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Writer> number 42\nWriter 42 ["number: 42"]\n')),(0,r.kt)("p",null,"Now, let\\'s do something similar to that which we have done with ",(0,r.kt)("em",{parentName:"p"},"Maybe"),"\nand ",(0,r.kt)("em",{parentName:"p"},"Either"),"."),(0,r.kt)("p",null,"Let\\'s write a function that takes three logging computations that each\nproduce an ",(0,r.kt)("em",{parentName:"p"},"Int")," and we want to return a single computation that\nproduces the sum of those ",(0,r.kt)("em",{parentName:"p"},"Int"),"s."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo (Writer k xs) (Writer l ys) (Writer m zs) =\nWriter (K + l + m) $ xs ++ ys ++ zs\n")),(0,r.kt)("p",null,"In the REPL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Writer> foo (number 1) (number 2) (number 3)\nWriter 6 ["number: 1","number: 2","number: 3"]\n')),(0,r.kt)("p",null,"Now, let\\'s write another useful function that takes a list of message\nand producers a ",(0,r.kt)("em",{parentName:"p"},"Writer")," with no useful result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"tell :: [String] -> Writer ()\ntell = Writer ()\n")),(0,r.kt)("p",null,"Now, we can update ",(0,r.kt)("em",{parentName:"p"},"foo")," to add an extra log message showing the sum of\nthe numbers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'foo :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo (Writer k xs) (Writer l ys) (Writer m zs) =\nlet\n   s = k + l + m\n   Writer _ us = tell ["sum: " ++ show s]\nin\n   Writer s $ xs ++ ys ++ zs ++ us\n')),(0,r.kt)("p",null,"In the REPL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Writer> foo (number 1) (number 2) (number 3)\nWriter 6 ["number: 1","number: 2","number: 3","sum: 6"]\n')),(0,r.kt)("p",null,"As before, we can write a bind function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"bindWriter :: Writer a -> (a -> Writer b) -> Writer b\nbindWriter (Writer a xs) f =\nlet\n   Writer b ys = f a\nin\n   Writer b $ xs ++ ys\n")),(0,r.kt)("p",null,"Here, the ",(0,r.kt)("em",{parentName:"p"},"bindWriter")," function is returning the ",(0,r.kt)("em",{parentName:"p"},"Writer b")," and\nproducing log messages which are a concatenation of the ",(0,r.kt)("em",{parentName:"p"},"xs")," that we\npattern matched on input, and the ",(0,r.kt)("em",{parentName:"p"},"ys")," that we pattern matched when\ncalling ",(0,r.kt)("em",{parentName:"p"},"f a")," in order to produce the ",(0,r.kt)("em",{parentName:"p"},"Writer b"),"."),(0,r.kt)("p",null,"Now, we can rewrite ",(0,r.kt)("em",{parentName:"p"},"foo")," using ",(0,r.kt)("em",{parentName:"p"},"bindWriter")," and make it much nicer."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo' :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo' x y z = x `bindWriter` \\k ->\n            y `bindWriter` \\l ->\n            z `bindWriter` \\m ->\n            let s = k + l + m\n            in tell [\"sum: \" ++ show s] `bindWriter` \\_ ->\n               Writer s []\n")),(0,r.kt)("p",null,"What we did with ",(0,r.kt)("em",{parentName:"p"},"foo")," before, we can now do with ",(0,r.kt)("em",{parentName:"p"},"foo\\'"),", and we get\nthe same result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Writer> foo\' (number 1) (number 2) (number 3)\nWriter 6 ["number: 1","number: 2","number: 3","sum: 6"]\n')),(0,r.kt)("p",null,"Admittedly, it is longer than it was before, but it is much nicer. We no\nlonger need to do the pattern matching to extract the messages. We\ndon\\'t have to explicitly combine the log messages, where we could make\na mistake and forget one, or get the order wrong. Instead, we abstract\nall that away and can just concentrate on the business logic."),(0,r.kt)("p",null,"Although the pattern is the same as with ",(0,r.kt)("em",{parentName:"p"},"Maybe")," and ",(0,r.kt)("em",{parentName:"p"},"Either"),", note that\nthe special aspect of these computations is completely different. With\n",(0,r.kt)("em",{parentName:"p"},"Maybe")," and ",(0,r.kt)("em",{parentName:"p"},"Either")," we dealt with the notion of failure, whereas here,\nwith the ",(0,r.kt)("em",{parentName:"p"},"Writer"),", there is no failure, but we instead have additional\noutput."),(0,r.kt)("h3",{id:"what-is-a-monad"},"What is a Monad?"),(0,r.kt)("p",null,"Now, we are in a position to explain what a Monad is."),(0,r.kt)("p",null,"Looking back at the four examples, what did they have in common? In all\nfour cases, We had a type constructor with one type parameter - ",(0,r.kt)("em",{parentName:"p"},"IO"),",\n",(0,r.kt)("em",{parentName:"p"},"Maybe"),", ",(0,r.kt)("em",{parentName:"p"},"Either String")," and ",(0,r.kt)("em",{parentName:"p"},"Writer")," all take a type parameter."),(0,r.kt)("p",null,"And, for all four of these examples, we had a bind function. For ",(0,r.kt)("em",{parentName:"p"},"IO"),",\nwe had the ",(0,r.kt)("em",{parentName:"p"},">",">","=")," function and for the others we had the bind functions\nthat we wrote ourselves."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"bindWriter :: Writer a -> (a -> Writer b) -> Writer b\nbindEither :: Either String a -> (a -> Either String b) -> Either String b\nbindMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b\n")),(0,r.kt)("p",null,"How the bind works depends on the case. In the case of ",(0,r.kt)("em",{parentName:"p"},"IO")," it is\nbuilt-in magic, but you can think of it as just combining the two plans\ndescribing the actions to take during computation. For ",(0,r.kt)("em",{parentName:"p"},"bindMaybe")," and\n",(0,r.kt)("em",{parentName:"p"},"bindEither")," the logic is for the whole plan to fail if any part of it\nfails, and for ",(0,r.kt)("em",{parentName:"p"},"bindWriter"),", the logic was to combine the list of log\nmessages."),(0,r.kt)("p",null,"And that is the main idea of Monads. It\\'s a concept of computation with\nsome additional side effects, and the ability to bind two such\ncomputations together."),(0,r.kt)("p",null,"There is another aspect that we briefly mentioned in the case of ",(0,r.kt)("em",{parentName:"p"},"IO"),"\nbut not for the other examples - another thing that we can always do."),(0,r.kt)("p",null,"Whenever we have such a concept of computation with side effects, we\nalso also always have the ability to produce a computation of this kind\nthat ",(0,r.kt)("em",{parentName:"p"},"doesn\\'t")," have any side effects."),(0,r.kt)("p",null,"In the example of ",(0,r.kt)("em",{parentName:"p"},"IO"),", this was done with ",(0,r.kt)("em",{parentName:"p"},"return"),". Given an ",(0,r.kt)("em",{parentName:"p"},"a"),", you\ncan create an ",(0,r.kt)("em",{parentName:"p"},"IO a")," which is the recipe that always simply returns the\n",(0,r.kt)("em",{parentName:"p"},"a")," with no side effects. Each of the other example has this ability as\nwell, as shown below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"return              :: a -> IO a\nJust                :: a -> Maybe a\nRight               :: a -> Either String a\n(\\a -> Writer a []) :: a -> Writer a\n")),(0,r.kt)("p",null,"And it is the combination of these two features that defines a Monad."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ability to bind two computations together"),(0,r.kt)("li",{parentName:"ul"},"the possibility to construct a computation from a pure value without\nmaking use of any of the potential side effects")),(0,r.kt)("p",null,"If we look in the REPL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Monad\ntype Monad :: (* -> *) -> Constraint\nclass Applicative m => Monad m where\n(>>=) :: m a -> (a -> m b) -> m b\n(>>) :: m a -> m b -> m b\nreturn :: a -> m a\n{-# MINIMAL (>>=) #-}\n   -- Defined in \u2018GHC.Base\u2019\ninstance Monad (Either e) -- Defined in \u2018Data.Either\u2019\ninstance Monad [] -- Defined in \u2018GHC.Base\u2019\ninstance Monad Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Monad IO -- Defined in \u2018GHC.Base\u2019\ninstance Monad ((->) r) -- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b, Monoid c) => Monad ((,,,) a b c)\n-- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b) => Monad ((,,) a b)\n-- Defined in \u2018GHC.Base\u2019\ninstance Monoid a => Monad ((,) a) -- Defined in \u2018GHC.Base\u2019\n")),(0,r.kt)("p",null,"We see the bind function"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"(>>=) :: m a -> (a -> m b) -> m b\n")),(0,r.kt)("p",null,"And the ",(0,r.kt)("em",{parentName:"p"},"return")," function that takes a pure value and turns it into a\ncomputation that has potential for side effects, but does not use them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"return :: a -> m a\n")),(0,r.kt)("p",null,"The other function ",(0,r.kt)("em",{parentName:"p"},">",">")," can easily be defined in terms of ",(0,r.kt)("em",{parentName:"p"},">",">","="),", but\nis provided for convenience."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"(>>) :: m a -> m b -> m b\n")),(0,r.kt)("p",null,"What this function does is to throw away the result of the first\ncomputation, so you could define it in terms of ",(0,r.kt)("em",{parentName:"p"},">",">","=")," by just ignoring\nthe argument to the function parameter."),(0,r.kt)("p",null,"There\\'s another technical computation. We see that ",(0,r.kt)("em",{parentName:"p"},"Monad")," has the\nsuper class ",(0,r.kt)("em",{parentName:"p"},"Applicative"),", so every Monad is ",(0,r.kt)("em",{parentName:"p"},"Applicative"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Applicative\ntype Applicative :: (* -> *) -> Constraint\nclass Functor f => Applicative f where\npure :: a -> f a\n(<*>) :: f (a -> b) -> f a -> f b\nGHC.Base.liftA2 :: (a -> b -> c) -> f a -> f b -> f c\n(*>) :: f a -> f b -> f b\n(<*) :: f a -> f b -> f a\n{-# MINIMAL pure, ((<*>) | liftA2) #-}\n   -- Defined in \u2018GHC.Base\u2019\ninstance Applicative (Either e) -- Defined in \u2018Data.Either\u2019\ninstance Applicative [] -- Defined in \u2018GHC.Base\u2019\ninstance Applicative Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Applicative IO -- Defined in \u2018GHC.Base\u2019\ninstance Applicative ((->) r) -- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b, Monoid c) =>\n         Applicative ((,,,) a b c)\n-- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b) => Applicative ((,,) a b)\n-- Defined in \u2018GHC.Base\u2019\ninstance Monoid a => Applicative ((,) a) -- Defined in \u2018GHC.Base\u2019\n")),(0,r.kt)("p",null,"We see it has a bunch of functions, but we only need the first two."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"pure :: a -> f a\n(<*>) :: f (a -> b) -> f a -> f b\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("em",{parentName:"p"},"pure")," has the same type signature as ",(0,r.kt)("em",{parentName:"p"},"return"),". Then there\nis \\<","*",">"," (pronounced \\'ap\\') which looks a bit more complicated. But,\nthe truth is that, once you have ",(0,r.kt)("em",{parentName:"p"},"return")," and ",(0,r.kt)("em",{parentName:"p"},">",">","=")," in a Monad, we can\neasily define both ",(0,r.kt)("em",{parentName:"p"},"pure")," and \\<","*",">","."),(0,r.kt)("p",null,"We see that ",(0,r.kt)("em",{parentName:"p"},"Applicative")," also has a superclass ",(0,r.kt)("em",{parentName:"p"},"Functor"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Week04.Contract> :i Functor\ntype Functor :: (* -> *) -> Constraint\nclass Functor f where\nfmap :: (a -> b) -> f a -> f b\n(<$) :: a -> f b -> f a\n{-# MINIMAL fmap #-}\n   -- Defined in \u2018GHC.Base\u2019\ninstance Functor (Either a) -- Defined in \u2018Data.Either\u2019\ninstance Functor [] -- Defined in \u2018GHC.Base\u2019\ninstance Functor Maybe -- Defined in \u2018GHC.Base\u2019\ninstance Functor IO -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((->) r) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,,,) a b c) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,,) a b) -- Defined in \u2018GHC.Base\u2019\ninstance Functor ((,) a) -- Defined in \u2018GHC.Base\u2019\n")),(0,r.kt)("p",null,"As we mentioned in the context of ",(0,r.kt)("em",{parentName:"p"},"IO"),", ",(0,r.kt)("em",{parentName:"p"},"Functor")," has the ",(0,r.kt)("em",{parentName:"p"},"fmap"),"\nfunction which, given a function from ",(0,r.kt)("em",{parentName:"p"},"a")," to ",(0,r.kt)("em",{parentName:"p"},"b")," will turn an ",(0,r.kt)("em",{parentName:"p"},"f a")," into\nan ",(0,r.kt)("em",{parentName:"p"},"f b"),"."),(0,r.kt)("p",null,"The prototypical example for ",(0,r.kt)("em",{parentName:"p"},"fmap")," is lists where ",(0,r.kt)("em",{parentName:"p"},"fmap")," is just ",(0,r.kt)("em",{parentName:"p"},"map"),".\nGiven a function from ",(0,r.kt)("em",{parentName:"p"},"a")," to ",(0,r.kt)("em",{parentName:"p"},"b"),", you can create a list of type ",(0,r.kt)("em",{parentName:"p"},"b")," from\na list of type ",(0,r.kt)("em",{parentName:"p"},"a")," by applying the ",(0,r.kt)("em",{parentName:"p"},"map")," function to each of the\nelements of the list."),(0,r.kt)("p",null,"Again, once you have ",(0,r.kt)("em",{parentName:"p"},"return")," and ",(0,r.kt)("em",{parentName:"p"},">",">","="),", it is easy to define ",(0,r.kt)("em",{parentName:"p"},"fmap"),"."),(0,r.kt)("p",null,"So, whenever you want to define a Monad, you just define ",(0,r.kt)("em",{parentName:"p"},"return")," and\n",(0,r.kt)("em",{parentName:"p"},">",">","="),", and to make the compiler happy and to give instances for\n",(0,r.kt)("em",{parentName:"p"},"Functor")," and ",(0,r.kt)("em",{parentName:"p"},"Applicative"),", there\\'s always a standard way of doing it."),(0,r.kt)("p",null,"We can do this in the example of ",(0,r.kt)("em",{parentName:"p"},"Writer"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"import Control.Monad\n\ninstance Functor Writer where\n   fmap = liftM\n\ninstance Applicative Writer where\n   pure = return\n   (<*>) = ap\n\ninstance Monad Writer where\n   return a = Writer a []\n   (>>=) = bindWriter\n")),(0,r.kt)("p",null,"We don\\'t have to do the same for ",(0,r.kt)("em",{parentName:"p"},"Maybe"),", ",(0,r.kt)("em",{parentName:"p"},"Either")," or ",(0,r.kt)("em",{parentName:"p"},"IO")," because they\nare already Monads defined by the Prelude."),(0,r.kt)("h3",{id:"why-is-this-useful"},"Why Is This useful?"),(0,r.kt)("p",null,"It is always useful, in general, to identify a common pattern and give\nit a name."),(0,r.kt)("p",null,"But, maybe the most important advantage is that there are lots of\nfunctions that don\\'t care which Monad we are dealing with - they will\nwork with all Monads."),(0,r.kt)("p",null,"Let\\'s generalize the example where we compute the sum of three\nintegers. We use a ",(0,r.kt)("em",{parentName:"p"},"let")," in the example below for reasons that will\nbecome clear in moment."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"threeInts :: Monad m => m Int -> m Int -> m Int -> m Int\nthreeInts mx my mz =\n   mx >>= \\k ->\n   my >>= \\l ->\n   mz >>= \\m ->\n   let s = k + l + m in return s\n")),(0,r.kt)("p",null,"Now we have this function, we can return to the ",(0,r.kt)("em",{parentName:"p"},"Maybe")," example and\nrewrite it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo'' :: String -> String -> String -> Maybe Int\nfoo'' x y z = threeInts (readMaybe x) (readMaybe y) (readMaybe z)\n")),(0,r.kt)("p",null,"We can do the same for the ",(0,r.kt)("em",{parentName:"p"},"Either")," example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo'' :: String -> String -> String -> Either String Int\nfoo'' x y z = threeInts (readEither x) (readEither y) (readEither z)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Writer")," example is not exactly the same."),(0,r.kt)("p",null,"If we are happy not to have the log message for the sum, it is very\nsimple as it is already an instance of ",(0,r.kt)("em",{parentName:"p"},"threeInts"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo'' :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo'' x y z = threeInts\n")),(0,r.kt)("p",null,"However, if we want the final log message, it becomes a little more\ncomplicated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"foo'' :: Writer Int -> Writer Int -> Writer Int -> Writer Int\nfoo'' x y z = do\n   s <- threeInts x y z\n   tell [\"sum: \" ++ show s]\n   return s\n")),(0,r.kt)("p",null,"If you look into the Control.Monad module in the standard Haskell\nPrelude, you will see that there are many useful functions that you can\nuse for all Monads."),(0,r.kt)("p",null,"One way to think about a Monad is as a computation with a super power."),(0,r.kt)("p",null,"In the case of ",(0,r.kt)("em",{parentName:"p"},"IO"),", the super power would be having real-world\nside-effects. In the case of ",(0,r.kt)("em",{parentName:"p"},"Maybe"),", the super power is being able to\nfail. The super power of ",(0,r.kt)("em",{parentName:"p"},"Either")," is to fail with an error message. And\nin the case of ",(0,r.kt)("em",{parentName:"p"},"Writer"),", the super power is to log messages."),(0,r.kt)("p",null,"There is a saying in the Haskell community that Haskell has an\noverloaded semi-colon. The explanation for this is that in many\nimperative programming languages, you have semi-colons that end with a\nsemi-colon - each statement is executed one after the other, each\nseparated by a semi-colon. But, what exactly the semi-colon means\ndepends on the language. For example, there could be an exception, in\nwhich case computation would stop and wouldn\\'t continue with the next\nlines."),(0,r.kt)("p",null,"In a sense, ",(0,r.kt)("em",{parentName:"p"},"bind")," is like a semi-colon. And the cool thing about\nHaskell is that it is a programmable semi-colon. We get to say what the\nlogic is for combining two computations together."),(0,r.kt)("p",null,'Each Monad comes with its own \\"semi-colon\\".'),(0,r.kt)("h3",{id:"do-notation"},"\\'do\\' notation"),(0,r.kt)("p",null,"Because this pattern is so common and monadic computations are all over\nthe place, there is a special notation for this in Haskell, called ",(0,r.kt)("em",{parentName:"p"},"do"),"\nnotation."),(0,r.kt)("p",null,"It is syntactic sugar. Let\\'s rewrite ",(0,r.kt)("em",{parentName:"p"},"threeInts")," using ",(0,r.kt)("em",{parentName:"p"},"do")," notation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"threeInts' :: Monad m => m Int -> m Int -> m Int -> m Int\nthreeInts' mx my mz = do\n   k <- mx\n   l <- my\n   m <- mz\n   let s = k + l + m\n   return s\n")),(0,r.kt)("p",null,"This does exactly the same thing as the non-",(0,r.kt)("em",{parentName:"p"},"do")," version, but it has\nless noise."),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("em",{parentName:"p"},"let")," statement does not use an ",(0,r.kt)("em",{parentName:"p"},"in")," part. It does not\nneed to inside a ",(0,r.kt)("em",{parentName:"p"},"do")," block."),(0,r.kt)("p",null,"And that\\'s Monads. There is a lot more to say about them but hopefully\nyou now have an idea of what Monads are and how they work."),(0,r.kt)("p",null,"Often you are in a situation where you want several effects at once -for\nexample you may want optional failure ",(0,r.kt)("em",{parentName:"p"},"and")," log messages. There are ways\nto do that in Haskell. For example there are Monad Transformers where\none can basically build custom Monads with the features that you want."),(0,r.kt)("p",null,"There are other approaches. One is called Effect Systems, which has a\nsimilar objective. And this is incidentally what Plutus uses for\nimportant Monads. In particular the Contact Monad in the wallet, and the\nTrace Monad which is used to test Plutus code."),(0,r.kt)("p",null,"The good news is that you don\\'t need to understand Effect Systems to\nwork with these Monads. You just need to know that you are working with\na Monad, and what super powers it has."),(0,r.kt)("h2",{id:"plutus-monads"},"Plutus Monads"),(0,r.kt)("p",null,"Now that we have seen how to write monadic code, either by using bind\nand return or by using do notation, we can look a very important Monad,\nnamely the Contract Monad, which you may have already noticed in\nprevious code examples."),(0,r.kt)("p",null,"The Contract Monad defines code that will run in the wallet, which is\nthe off-chain part of Plutus."),(0,r.kt)("p",null,"But, before we go into details, we will talk about a second Monad, the\nEmulatorTrace monad."),(0,r.kt)("h3",{id:"the-emulatortrace-monad"},"The EmulatorTrace Monad"),(0,r.kt)("p",null,"You may have wondered if there is a way to execute Plutus code for\ntesting purposes without using the Plutus Playground. There is indeed,\nand this is done using the ",(0,r.kt)("em",{parentName:"p"},"EmulatorTrace")," Monad."),(0,r.kt)("p",null,"You can think of a program in this monad as what we do manually in the\n",(0,r.kt)("em",{parentName:"p"},"simulator")," tab of the playground. That is, we define the initial\nconditions, we define the actions such as which wallets invoke which\nendpoints with which parameters and we define the waiting periods\nbetween actions."),(0,r.kt)("p",null,"The relevant definitions are in the package ",(0,r.kt)("em",{parentName:"p"},"plutus-contract")," in module\n",(0,r.kt)("em",{parentName:"p"},"Plutus.Trace.Emulator"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"module Plutus.Trace.Emulator\n")),(0,r.kt)("p",null,"The most basic function is called ",(0,r.kt)("em",{parentName:"p"},"runEmulatorTrace"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"-- | Run an emulator trace to completion, returning a tuple of the final state\n-- of the emulator, the events, and any error, if any.\nrunEmulatorTrace\n    :: EmulatorConfig\n    -> EmulatorTrace ()\n    -> ([EmulatorEvent], Maybe EmulatorErr, EmulatorState)\nrunEmulatorTrace cfg trace =\n    (\\(xs :> (y, z)) -> (xs, y, z))\n    $ run\n    $ runReader ((initialDist . _initialChainState) cfg)\n    $ foldEmulatorStreamM (generalize list)\n    $ runEmulatorStream cfg trace\n")),(0,r.kt)("p",null,"It gets something called an ",(0,r.kt)("em",{parentName:"p"},"EmulatorConfig")," and an ",(0,r.kt)("em",{parentName:"p"},"EmulatorTrace ()"),",\nwhich is a pure computation where no real-world side effects are\ninvolved. It is a pure function that executes the trace on an emulated\nblockchain, and then gives a result as a list of ",(0,r.kt)("em",{parentName:"p"},"EmulatorEvent"),"s, maybe\nan error, if there was one, and then finally the final ",(0,r.kt)("em",{parentName:"p"},"EmulatorState"),"."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"EmulatorConfig")," is defined in a different module in the same package:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"module Wallet.Emulator.Stream\n\ndata EmulatorConfig =\nEmulatorConfig\n    { _initialChainState      :: InitialChainState -- ^ State of the blockchain at the beginning of the simulation. Can be given as a map of funds to wallets, or as a block of transactions.\n    } deriving (Eq, Show)\n\ntype InitialChainState = Either InitialDistribution Block\n")),(0,r.kt)("p",null,"We see it only has one field, which is of type ",(0,r.kt)("em",{parentName:"p"},"InitialChainState")," and\nit is either ",(0,r.kt)("em",{parentName:"p"},"InitialDistribution")," or ",(0,r.kt)("em",{parentName:"p"},"Block"),"."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"InitialDistribution")," is defined in another module in the same package,\nand it is a type synonym for a map of key value pairs of ",(0,r.kt)("em",{parentName:"p"},"Wallet"),"s to\n",(0,r.kt)("em",{parentName:"p"},"Value"),"s, as you would expect. ",(0,r.kt)("em",{parentName:"p"},"Value")," can be either lovelace or native\ntokens."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"module Plutus.Contract.Trace\n\ntype InitialDistribution = Map Wallet Value\n")),(0,r.kt)("p",null,"In the same module, we see something called ",(0,r.kt)("em",{parentName:"p"},"defaultDist")," which returns\na default distribution for all wallets. It does this by passing the 10\nwallets defined by ",(0,r.kt)("em",{parentName:"p"},"allWallets")," to ",(0,r.kt)("em",{parentName:"p"},"defaultDistFor")," which takes a list\nof wallets."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"-- | The wallets used in mockchain simulations by default. There are\n--   ten wallets because the emulator comes with ten private keys.\nallWallets :: [EM.Wallet]\nallWallets = EM.Wallet <$> [1 .. 10]\n\ndefaultDist :: InitialDistribution\ndefaultDist = defaultDistFor allWallets\n\ndefaultDistFor :: [EM.Wallet] -> InitialDistribution\ndefaultDistFor wallets = Map.fromList $ zip wallets (repeat (Ada.lovelaceValueOf 100_000_000))\n")),(0,r.kt)("p",null,"We can try this out in the REPL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Week04.Contract> import Plutus.Trace.Emulator\nPrelude Plutus.Trace.Emulator Week04.Contract> import Plutus.Contract.Trace\nPrelude Plutus.Trace.Emulator Plutus.Contract.Trace Week04.Contract> defaultDist\nfromList [(Wallet 1,Value (Map [(,Map [("",100000000)])])),(Wallet 2,Value (Map [(,Map [("",100000000)])])),(Wallet 3,Value (Map [(,Map [("",100000000)])])),(Wallet 4,Value (Map [(,Map [("",100000000)])])),(Wallet 5,Value (Map [(,Map [("",100000000)])])),(Wallet 6,Value (Map [(,Map [("",100000000)])])),(Wallet 7,Value (Map [(,Map [("",100000000)])])),(Wallet 8,Value (Map [(,Map [("",100000000)])])),(Wallet 9,Value (Map [(,Map [("",100000000)])])),(Wallet 10,Value (Map [(,Map [("",100000000)])]))]\n')),(0,r.kt)("p",null,"We can see that each of the 10 wallets has been given an initial\ndistribution of 100,000,000 lovelace."),(0,r.kt)("p",null,"We can also get the balances for a specific wallet or wallets:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Week04.Contract> defaultDistFor [Wallet 1]\nfromList [(Wallet 1,Value (Map [(,Map [("",100000000)])]))]\n')),(0,r.kt)("p",null,"If you want different initial values, of if you want native tokens, then\nyou have to specify that manually."),(0,r.kt)("p",null,"Let\\'s see what we need to run our first trace:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Week04.Contract> :t runEmulatorTrace\nrunEmulatorTrace\n:: EmulatorConfig\n-> EmulatorTrace ()\n-> ([Wallet.Emulator.MultiAgent.EmulatorEvent], Maybe EmulatorErr,\n      Wallet.Emulator.MultiAgent.EmulatorState)\n")),(0,r.kt)("p",null,"So, we need an ",(0,r.kt)("em",{parentName:"p"},"EmulatorConfig")," which we know takes an\n",(0,r.kt)("em",{parentName:"p"},"InitialChainState"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Week04.Contract> import Wallet.Emulator.Stream \nPrelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator.Stream Week04.Contract> :i InitialChainState \ntype InitialChainState :: *\ntype InitialChainState =\nEither InitialDistribution Ledger.Blockchain.Block\n      -- Defined in \u2018Wallet.Emulator.Stream\u2019\n")),(0,r.kt)("p",null,"If we take the ",(0,r.kt)("em",{parentName:"p"},"Left")," of the ",(0,r.kt)("em",{parentName:"p"},"defaultDist")," will will get an\n",(0,r.kt)("em",{parentName:"p"},"InitialDistribution"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator.Stream Week04.Contract> :t Left defaultDist\nLeft defaultDist :: Either InitialDistribution b\n")),(0,r.kt)("p",null,"Which we can then use to construct an ",(0,r.kt)("em",{parentName:"p"},"EmulatorConfig"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator.Stream Week04.Contract> EmulatorConfig $ Left defaultDist\nEmulatorConfig {_initialChainState = Left (fromList [(Wallet 1,Value (Map [(,Map [("",100000000)])])),(Wallet 2,Value (Map [(,Map [("",100000000)])])),(Wallet 3,Value (Map [(,Map [("",100000000)])])),(Wallet 4,Value (Map [(,Map [("",100000000)])])),(Wallet 5,Value (Map [(,Map [("",100000000)])])),(Wallet 6,Value (Map [(,Map [("",100000000)])])),(Wallet 7,Value (Map [(,Map [("",100000000)])])),(Wallet 8,Value (Map [(,Map [("",100000000)])])),(Wallet 9,Value (Map [(,Map [("",100000000)])])),(Wallet 10,Value (Map [(,Map [("",100000000)])]))])}\n')),(0,r.kt)("p",null,"So, let\\'s try out ",(0,r.kt)("em",{parentName:"p"},"runEmulatorTrace"),". Recall that, as well as and\n",(0,r.kt)("em",{parentName:"p"},"EmulatorConfig"),", we also need to pass in an ",(0,r.kt)("em",{parentName:"p"},"EmulatorTrace"),", and the\nmost simple one we can create is simply one that returns Unit - ",(0,r.kt)("em",{parentName:"p"},"return\n()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"runEmulatorTrace (EmulatorConfig $ Left defaultDist) $ return ()\n")),(0,r.kt)("p",null,"If you run this in the REPL you will get a crazy amount of data output\nto the console, even though we are not doing anything with the trace. If\nyou want to make it useful, you must somehow filter all this data down\nto something that sensible, and aggregate it in some way."),(0,r.kt)("p",null,"Luckily, there are other functions as well as ",(0,r.kt)("em",{parentName:"p"},"runEmulatorTrace"),". One of\nthem is ",(0,r.kt)("em",{parentName:"p"},"runEmulatorTraceIo")," which runs the emulation then outputs the\ntrace in a nice form on the screen."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"runEmulatorTraceIO\n:: EmulatorTrace ()\n-> IO ()\nrunEmulatorTraceIO = runEmulatorTraceIO' def def\n")),(0,r.kt)("p",null,"To use this function, we don\\'t need to specify an ",(0,r.kt)("em",{parentName:"p"},"EmulatorConfig")," like\nwe did before, because by default will will just use the default\ndistribution."),(0,r.kt)("p",null,"In the REPL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude...> runEmulatorTraceIO $ return ()\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.}"},'Slot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: SlotAdd Slot 2\nFinal balances\nWallet 1: \n{, ""}: 100000000\nWallet 2: \n{, ""}: 100000000\nWallet 3: \n{, ""}: 100000000\nWallet 4: \n{, ""}: 100000000\nWallet 5: \n{, ""}: 100000000\nWallet 6: \n{, ""}: 100000000\nWallet 7: \n{, ""}: 100000000\nWallet 8: \n{, ""}: 100000000\nWallet 9: \n{, ""}: 100000000\nWallet 10: \n{, ""}: 100000000\n')),(0,r.kt)("p",null,"And we see a much more manageable, concise output. Nothing happens, but\nwe see the Genesis transaction and then the final balances for each\nwallet."),(0,r.kt)("p",null,"If you want more control, there is also ",(0,r.kt)("em",{parentName:"p"},"runEmulatorTraceIO\\'"),", which\ndoes take an ",(0,r.kt)("em",{parentName:"p"},"EmulatorConfig"),", so we could specify a different\ndistribution."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"runEmulatorTraceIO'\n:: TraceConfig\n-> EmulatorConfig\n-> EmulatorTrace ()\n-> IO ()\nrunEmulatorTraceIO' tcfg cfg trace\n= runPrintEffect (outputHandle tcfg) $ runEmulatorTraceEff tcfg cfg trace\n")),(0,r.kt)("p",null,"It also takes a ",(0,r.kt)("em",{parentName:"p"},"TraceConfig"),", which has two fields."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"data TraceConfig = TraceConfig\n{ showEvent    :: EmulatorEvent' -> Maybe String\n-- ^ Function to decide how to print the particular events.\n, outputHandle :: Handle\n-- ^ Where to print the outputs to. Default: 'System.IO.stdout'\n}\n")),(0,r.kt)("p",null,"The first field, ",(0,r.kt)("em",{parentName:"p"},"showEvent")," is a function that specifies which\n",(0,r.kt)("em",{parentName:"p"},"EmulatorEvent"),"s are displayed and how they are displayed. It takes an\n",(0,r.kt)("em",{parentName:"p"},"EmulatorEvent")," as an argument and can return ",(0,r.kt)("em",{parentName:"p"},"Nothing")," it the event\nshould not be displayed, or a ",(0,r.kt)("em",{parentName:"p"},"Just")," with a ",(0,r.kt)("em",{parentName:"p"},"String")," showing how the\nevent will be displayed."),(0,r.kt)("p",null,"Here is the default ",(0,r.kt)("em",{parentName:"p"},"TraceConfig")," used by ",(0,r.kt)("em",{parentName:"p"},"runEmulatorTraceIO"),". We can\nsee that most events are ignored and that we only get output for some of\nthe events."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'instance Default TraceConfig where\ndef = TraceConfig\n            { showEvent     = defaultShowEvent\n            , outputHandle  = stdout\n            }\n\ndefaultShowEvent :: EmulatorEvent\' -> Maybe String\ndefaultShowEvent = \\case\nUserThreadEvent (UserLog msg)                                        -> Just $ "*** USER LOG: " <> msg\nInstanceEvent (ContractInstanceLog (ContractLog (A.String msg)) _ _) -> Just $ "*** CONTRACT LOG: " <> show msg\nInstanceEvent (ContractInstanceLog (StoppedWithError err)       _ _) -> Just $ "*** CONTRACT STOPPED WITH ERROR: " <> show err\nInstanceEvent (ContractInstanceLog NoRequestsHandled            _ _) -> Nothing\nInstanceEvent (ContractInstanceLog (HandledRequest _)           _ _) -> Nothing\nInstanceEvent (ContractInstanceLog (CurrentRequests _)          _ _) -> Nothing\nSchedulerEvent _                                                     -> Nothing\nChainIndexEvent _ _                                                  -> Nothing\nWalletEvent _ _                                                      -> Nothing\nev                                                                   -> Just . renderString . layoutPretty defaultLayoutOptions . pretty $ ev\n')),(0,r.kt)("p",null,"The second field is a handle which defaults to ",(0,r.kt)("em",{parentName:"p"},"stdout"),", but we could\nalso specify a file here."),(0,r.kt)("p",null,"Now let\\'s look at a more interesting trace, using the ",(0,r.kt)("em",{parentName:"p"},"Vesting"),"\ncontract from the last lecture."),(0,r.kt)("p",null,"First, we define a ",(0,r.kt)("em",{parentName:"p"},"Trace"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myTrace :: EmulatorTrace ()\nmyTrace = do\nh1 <- activateContractWallet (Wallet 1) endpoints\nh2 <- activateContractWallet (Wallet 2) endpoints\ncallEndpoint @"give" h1 $ GiveParams\n      { gpBeneficiary = pubKeyHash $ walletPubKey $ Wallet 2\n      , gpDeadline    = Slot 20\n      , gpAmount      = 1000\n      }\nvoid $ waitUntilSlot 20\ncallEndpoint @"grab" h2 ()\nvoid $ waitNSlots 1\n')),(0,r.kt)("p",null,"The first thing we have to do is to activate the wallets using the\nmonadic function ",(0,r.kt)("em",{parentName:"p"},"activateContractWallet"),". We bind the result of this\nfunction to ",(0,r.kt)("em",{parentName:"p"},"h1"),", and then bind the result of a second call (for Wallet\n2) to ",(0,r.kt)("em",{parentName:"p"},"h2"),". Those two values - ",(0,r.kt)("em",{parentName:"p"},"h1")," and ",(0,r.kt)("em",{parentName:"p"},"h2")," are handles to their\nrespective wallets."),(0,r.kt)("p",null,"Next, we use ",(0,r.kt)("em",{parentName:"p"},"callEndpoint")," to simulate Wallet 1 calling the ",(0,r.kt)("em",{parentName:"p"},"give"),"\nendpoint, with the shown parameters. We then wait for 20 slots. The\nfunction ",(0,r.kt)("em",{parentName:"p"},"waitUntilSlot")," actually returns a value representing the slot\nthat was reached, but, as we are not interested in that value here, we\nuse ",(0,r.kt)("em",{parentName:"p"},"void")," to ignore it. We then simulate the call to the ",(0,r.kt)("em",{parentName:"p"},"grab"),"\nendpoint by Wallet 2."),(0,r.kt)("p",null,"Now, we can write a function to call ",(0,r.kt)("em",{parentName:"p"},"runEmulatorTraceIO")," with out\n",(0,r.kt)("em",{parentName:"p"},"Trace"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"test :: IO ()\ntest = runEmulatorTraceIO myTrace\n")),(0,r.kt)("p",null,"And, we can then run this in the REPL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.}"},'Slot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Contract instance started\nSlot 00001: 00000000-0000-4000-8000-000000000001 {Contract instance for wallet 2}:\n  Contract instance started\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Receive endpoint call: Object (fromList [("tag",String "give"),("value",Object (fromList [("unEndpointValue",Object (fromList [("gpAmount",Number 1000.0),("gpBeneficiary",Object (fromList [("getPubKeyHash",String "39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f")])),("gpDeadline",Object (fromList [("getSlot",Number 20.0)]))]))]))])\nSlot 00001: W1: TxSubmit: 49f326a21c09ba52eddee46b65bdb5fb33b3444745e9af1510a68f9043696eba\nSlot 00001: TxnValidate 49f326a21c09ba52eddee46b65bdb5fb33b3444745e9af1510a68f9043696eba\nSlot 00001: SlotAdd Slot 2\nSlot 00002: *** CONTRACT LOG: "made a gift of 1000 lovelace to 39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f with deadline Slot {getSlot = 20}"\nSlot 00002: SlotAdd Slot 3\nSlot 00003: SlotAdd Slot 4\nSlot 00004: SlotAdd Slot 5\nSlot 00005: SlotAdd Slot 6\nSlot 00006: SlotAdd Slot 7\nSlot 00007: SlotAdd Slot 8\nSlot 00008: SlotAdd Slot 9\nSlot 00009: SlotAdd Slot 10\nSlot 00010: SlotAdd Slot 11\nSlot 00011: SlotAdd Slot 12\nSlot 00012: SlotAdd Slot 13\nSlot 00013: SlotAdd Slot 14\nSlot 00014: SlotAdd Slot 15\nSlot 00015: SlotAdd Slot 16\nSlot 00016: SlotAdd Slot 17\nSlot 00017: SlotAdd Slot 18\nSlot 00018: SlotAdd Slot 19\nSlot 00019: SlotAdd Slot 20\nSlot 00020: 00000000-0000-4000-8000-000000000001 {Contract instance for wallet 2}:\n  Receive endpoint call: Object (fromList [("tag",String "grab"),("value",Object (fromList [("unEndpointValue",Array [])]))])\nSlot 00020: W2: TxSubmit: d9a2028384b4472242371f27cb51727f5c7c04327972e4278d1f69f606019a8b\nSlot 00020: TxnValidate d9a2028384b4472242371f27cb51727f5c7c04327972e4278d1f69f606019a8b\nSlot 00020: SlotAdd Slot 21\nSlot 00021: *** CONTRACT LOG: "collected gifts"\nSlot 00021: SlotAdd Slot 22\nFinal balances\nWallet 1: \n    {, ""}: 99998990\nWallet 2: \n    {, ""}: 100000990\nWallet 3: \n    {, ""}: 100000000\nWallet 4: \n    {, ""}: 100000000\nWallet 5: \n    {, ""}: 100000000\nWallet 6: \n    {, ""}: 100000000\nWallet 7: \n    {, ""}: 100000000\nWallet 8: \n    {, ""}: 100000000\nWallet 9: \n    {, ""}: 100000000\nWallet 10: \n    {, ""}: 100000000\n')),(0,r.kt)("p",null,"This output is very similar to the output we see in the playground. We\ncan see the Genesis transaction as well as both the ",(0,r.kt)("em",{parentName:"p"},"give")," and ",(0,r.kt)("em",{parentName:"p"},"grab"),"\ntransactions from the ",(0,r.kt)("em",{parentName:"p"},"Trace"),". We can also see some log output from the\ncontract itself, prefixed with ",(0,r.kt)("em",{parentName:"p"},"CONTRACT LOG"),"."),(0,r.kt)("p",null,"We can also log from inside the ",(0,r.kt)("em",{parentName:"p"},"Trace")," monad. We could, for example,\nlof the result of the final ",(0,r.kt)("em",{parentName:"p"},"waitNSlots")," call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myTrace :: EmulatorTrace ()\nmyTrace = do\n...\n...\ns <- waitNSlots 1\nExtras.logInfo $ "reached slot " ++ show s\n')),(0,r.kt)("p",null,"We would then see this output when we run the emulation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.}"},'...\nSlot 00020: SlotAdd Slot 21\nSlot 00021: *** USER LOG: reached slot Slot {getSlot = 21}\nSlot 00021: *** CONTRACT LOG: "collected gifts"\nSlot 00021: SlotAdd Slot 22\n...\n')),(0,r.kt)("p",null,"Now let\\'s look at the Contract Monad."),(0,r.kt)("h3",{id:"the-contract-monad"},"The Contract Monad"),(0,r.kt)("p",null,"The purpose of the Contract Monad is to define off-chain code that runs\nin the wallet. It has four type parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"newtype Contract w s e a = Contract { unContract :: Eff (ContractEffs w s e) a }\n      deriving newtype (Functor, Applicative, Monad)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"a")," is the same as in every Monad - it denotes the result type of\nthe computation."),(0,r.kt)("p",null,"We will go into the other three in more detail later but just briefly:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"w is like our Writer monad example, it allows us to write log\nmessages of type ",(0,r.kt)("em",{parentName:"li"},"w"),"."),(0,r.kt)("li",{parentName:"ul"},"s describes the blockchain capabilities, e.g. waiting for a slot,\nsubmitting transactions, getting the wallet\\'s public key. It can\nalso contain specific endpoints."),(0,r.kt)("li",{parentName:"ul"},"e describes the type of error messages that this monad can throw.")),(0,r.kt)("p",null,"Let\\'s write an example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myContract1 :: Contract () BlockchainActions Text ()\nmyContract1 = Contract.logInfo @String "Hello from the contract!"\n')),(0,r.kt)("p",null,"Here, we pass a ",(0,r.kt)("em",{parentName:"p"},"Contract")," constructed with ",(0,r.kt)("em",{parentName:"p"},"Unit")," as the ",(0,r.kt)("em",{parentName:"p"},"w")," type and\n",(0,r.kt)("em",{parentName:"p"},"BlockchainActions")," as the second argument, ",(0,r.kt)("em",{parentName:"p"},"s"),". This gives us access to\nall the blockchain actions - the only thing we can\\'t do is to call\nspecific endpoints."),(0,r.kt)("p",null,"For ",(0,r.kt)("em",{parentName:"p"},"e")," - the error message type, we use ",(0,r.kt)("em",{parentName:"p"},"Text"),". ",(0,r.kt)("em",{parentName:"p"},"Text")," is a Haskell\ntype which is like ",(0,r.kt)("em",{parentName:"p"},"String"),", but it is much more efficient."),(0,r.kt)("p",null,"We don\\'t want a specific result, so we use ",(0,r.kt)("em",{parentName:"p"},"Unit")," for the type ",(0,r.kt)("em",{parentName:"p"},"a"),"."),(0,r.kt)("p",null,"For the function body, we write a log message. We use ",(0,r.kt)("em",{parentName:"p"},"\\@String"),"\nbecause, we have imported the type ",(0,r.kt)("em",{parentName:"p"},"Data.Text")," and we have used the\n",(0,r.kt)("em",{parentName:"p"},"OverloadedStrings")," GHC compiler option, so the compiler needs to know\nwhat type we are referencing - a ",(0,r.kt)("em",{parentName:"p"},"Text")," or a ",(0,r.kt)("em",{parentName:"p"},"String"),". We can use\n",(0,r.kt)("em",{parentName:"p"},"\\@String")," if we also use the compiler option ",(0,r.kt)("em",{parentName:"p"},"TypeApplications"),"."),(0,r.kt)("p",null,"Let\\'s now define a ",(0,r.kt)("em",{parentName:"p"},"Trace")," that starts the contract in the wallet, and\na ",(0,r.kt)("em",{parentName:"p"},"test")," function to run it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"myTrace1 :: EmulatorTrace ()\nmyTrace1 = void $ activateContractWallet (Wallet 1) myContract1\n\ntest1 :: IO ()\ntest1 = runEmulatorTraceIO myTrace1\n")),(0,r.kt)("p",null,"If we run this in the REPL, we will see our log message from the\ncontract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.Prelude",metastring:"Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test1","Plutus.Trace.Emulator":!0,"Plutus.Contract.Trace":!0,"Wallet.Emulator":!0,"Week04.Trace":!0,"Wallet.Emulator.Stream":!0,"Week04.Contract>":!0,test1:!0},'Slot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract instance started\nSlot 00001: *** CONTRACT LOG: \\"Hello from the contract!\\"\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract instance stopped (no errors)\nSlot 00001: SlotAdd Slot 2\nFinal balances\nWallet 1: \n{, \\"\\"}: 100000000\nWallet 2: \n{, \\"\\"}: 100000000\nWallet 3: \n{, \\"\\"}: 100000000\nWallet 4: \n{, \\"\\"}: 100000000\nWallet 5: \n{, \\"\\"}: 100000000\nWallet 6: \n{, \\"\\"}: 100000000\nWallet 7: \n{, \\"\\"}: 100000000\nWallet 8: \n{, \\"\\"}: 100000000\nWallet 9: \n{, \\"\\"}: 100000000\nWallet 10: \n{, \\"\\"}: 100000000}\n')),(0,r.kt)("p",null,"Now, let\\'s throw an exception."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myContract1 :: Contract () BlockchainActions Text ()\nmyContract1 = do\nvoid $ Contract.throwError "BOOM!"\nContract.logInfo @String "Hello from the contract!"\n')),(0,r.kt)("p",null,"Recall that we chose the type ",(0,r.kt)("em",{parentName:"p"},"Text")," as the error message."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test1\nSlot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract instance started\nSlot 00001: *** CONTRACT STOPPED WITH ERROR: "\\"BOOM!\\""\nSlot 00001: SlotAdd Slot 2\nFinal balances\nWallet 1: \n{, ""}: 100000000\nWallet 2: \n{, ""}: 100000000\nWallet 3: \n{, ""}: 100000000\nWallet 4: \n{, ""}: 100000000\nWallet 5: \n{, ""}: 100000000\nWallet 6: \n{, ""}: 100000000\nWallet 7: \n{, ""}: 100000000\nWallet 8: \n{, ""}: 100000000\nWallet 9: \n{, ""}: 100000000\nWallet 10: \n{, ""}: 100000000\n')),(0,r.kt)("p",null,"Now, we don\\'t get the log message, but we do get told that the contract\nstopped with an error and we see our exception message."),(0,r.kt)("p",null,"Another thing you can do is to handle exceptions. We will use the\n",(0,r.kt)("em",{parentName:"p"},"handleError")," function from module ",(0,r.kt)("em",{parentName:"p"},"Plutus.Contract.Types"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"handleError ::\n      forall w s e e' a.\n      (e -> Contract w s e' a)\n      -> Contract w s e a\n      -> Contract w s e' a\nhandleError f (Contract c) = Contract c' where\n      c' = E.handleError @e (raiseUnderN @'[E.Error e'] c) (fmap unContract f)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"handleError")," function takes an error handler and a ",(0,r.kt)("em",{parentName:"p"},"Contract"),"\ninstance. The error handler takes an argument of type ",(0,r.kt)("em",{parentName:"p"},"e")," from our\ncontract, and returns a new ",(0,r.kt)("em",{parentName:"p"},"Contract")," with the same type parameters as\nthe first, but we can change the type of the ",(0,r.kt)("em",{parentName:"p"},"e")," argument - the error\ntype, which is expressed in the return ",(0,r.kt)("em",{parentName:"p"},"Contract")," argument list as\n",(0,r.kt)("em",{parentName:"p"},"e\\'"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myContract2 :: Contract () BlockchainActions Void ()\nmyContract2 = Contract.handleError\n      (\\err -> Contract.logError $ "Caught error: " ++ unpack err)\n      myContract1\n\nmyTrace2 :: EmulatorTrace ()\nmyTrace2 = void $ activateContractWallet (Wallet 1) myContract2\n\ntest2 :: IO ()\ntest2 = runEmulatorTraceIO myTrace2\n')),(0,r.kt)("p",null,"We use the type ",(0,r.kt)("em",{parentName:"p"},"Void")," as the error type. ",(0,r.kt)("em",{parentName:"p"},"Void")," is a type that can hold\nno value, so, by using this type we are saying that there cannot be any\nerrors for this contract."),(0,r.kt)("p",null,"::: {.note}\n::: {.title}\nNote\n:::"),(0,r.kt)("p",null,"The function ",(0,r.kt)("em",{parentName:"p"},"unpack")," is defined in the ",(0,r.kt)("em",{parentName:"p"},"Data.Text")," module. It converts\na value of type ",(0,r.kt)("em",{parentName:"p"},"Text")," to a value of type ",(0,r.kt)("em",{parentName:"p"},"String"),".\n:::"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test2\nSlot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract instance started\nSlot 00001: *** CONTRACT LOG: "Caught error: BOOM!"\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract instance stopped (no errors)\nSlot 00001: SlotAdd Slot 2\nFinal balances\n...\n')),(0,r.kt)("p",null,'We no longer get the error message, but, instead we get a message from\nthe error handler showing the exception that was thrown by Contract1.\nNote that we still do not get the message \\"Hello from the contract!\\".\nContract 1 still stopped processing after its error, but there was no\noverall contract error due to the exception being caught and handled.'),(0,r.kt)("p",null,"Of course, exceptions can also happen even if they are not explicitly\nthrown by your contract code. There are operations, such as submitting a\ntransaction where there are insufficient inputs to make a payment for an\noutput, where Plutus will throw an exception."),(0,r.kt)("p",null,"Next, let\\'s look at the ",(0,r.kt)("em",{parentName:"p"},"s")," parameter, the second parameter to\n",(0,r.kt)("em",{parentName:"p"},"Contract"),", that determines the available blockchain actions."),(0,r.kt)("p",null,"In the first two examples we just used the ",(0,r.kt)("em",{parentName:"p"},"BlockChainActions")," type\nwhich has all the standard functionality but without support for\nspecific endpoints. If we want support for specific endpoints, we must\nuse a different type."),(0,r.kt)("p",null,"The way that is usually done is by using a type synonym. The following\nexample will create a type synonym ",(0,r.kt)("em",{parentName:"p"},"MySchema")," that has all the\ncapabilities of ",(0,r.kt)("em",{parentName:"p"},"BlockChainActions")," but with the addition of being able\nto call endpoint ",(0,r.kt)("em",{parentName:"p"},"foo")," with an argument of type ",(0,r.kt)("em",{parentName:"p"},"Int"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'type MySchema = BlockchainActions .\\/ Endpoint "foo" Int\n')),(0,r.kt)("p",null,"::: {.note}\n::: {.title}\nNote\n:::"),(0,r.kt)("p",null,"The operator ",(0,r.kt)("em",{parentName:"p"},".","\\","/")," is a type operator - it operates on types, not\nvalues. In order to use this we need to use the ",(0,r.kt)("em",{parentName:"p"},"TypeOperators")," and\n",(0,r.kt)("em",{parentName:"p"},"DataKinds")," compiler options.\n:::"),(0,r.kt)("p",null,"Now, we can use the ",(0,r.kt)("em",{parentName:"p"},"MySchema")," type to define our contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myContract3 :: Contract () MySchema Text ()\nmyContract3 = do\n      n <- endpoint @"foo"\n      Contract.logInfo n\n')),(0,r.kt)("p",null,"This contract will block until the endpoint ",(0,r.kt)("em",{parentName:"p"},"foo")," is called with, in our\ncase, an ",(0,r.kt)("em",{parentName:"p"},"Int"),". Then the value of the ",(0,r.kt)("em",{parentName:"p"},"Int")," parameter will be bound to\n",(0,r.kt)("em",{parentName:"p"},"n"),". Because of this, it is no longer enough for us to just activate the\ncontract to test it. Now, we must invoke the endpoint as well."),(0,r.kt)("p",null,"In order to do this, we now need to handle from\n",(0,r.kt)("em",{parentName:"p"},"activateContractWallet"),", which we can then use to call the endpoint."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},'myTrace3 :: EmulatorTrace ()\nmyTrace3 = do\n      h <- activateContractWallet (Wallet 1) myContract3\n      callEndpoint @"foo" h 42\n\ntest3 :: IO ()\ntest3 = runEmulatorTraceIO myTrace3\n')),(0,r.kt)("p",null,"Running this in the REPL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test3\nSlot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\n...\nReceive endpoint call: Object (fromList [("tag",String "foo"),("value",Object (fromList [("unEndpointValue",Number 42.0)]))])\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\nContract log: Number 42.0\n...\nFinal balances\n...\nWallet 10: \n{, ""}: 100000000\n')),(0,r.kt)("p",null,"Finally, let\\'s look at the first type parameter, the writer. The ",(0,r.kt)("em",{parentName:"p"},"w"),"\ncannot be an arbitrary type, it must be an instance of the type class\n",(0,r.kt)("em",{parentName:"p"},"Monoid"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> :i Monoid\ntype Monoid :: * -> Constraint\nclass Semigroup a => Monoid a where\nmempty :: a\nmappend :: a -> a -> a\nmconcat :: [a] -> a\n{-# MINIMAL mempty #-}\n      -- Defined in \u2018GHC.Base\u2019\ninstance Monoid [a] -- Defined in \u2018GHC.Base\u2019\ninstance Monoid Ordering -- Defined in \u2018GHC.Base\u2019\ninstance Semigroup a => Monoid (Maybe a) -- Defined in \u2018GHC.Base\u2019\ninstance Monoid a => Monoid (IO a) -- Defined in \u2018GHC.Base\u2019\ninstance Monoid b => Monoid (a -> b) -- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>\n      Monoid (a, b, c, d, e)\n-- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b, Monoid c, Monoid d) =>\n      Monoid (a, b, c, d)\n-- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)\n-- Defined in \u2018GHC.Base\u2019\ninstance (Monoid a, Monoid b) => Monoid (a, b)\n-- Defined in \u2018GHC.Base\u2019\ninstance Monoid () -- Defined in \u2018GHC.Base\u2019\n")),(0,r.kt)("p",null,"This is a very important and very common type class in Haskell. It\ndefines ",(0,r.kt)("em",{parentName:"p"},"mempty")," and ",(0,r.kt)("em",{parentName:"p"},"mappend"),"."),(0,r.kt)("p",null,"The function ",(0,r.kt)("em",{parentName:"p"},"mempty")," is like the neutral element, and ",(0,r.kt)("em",{parentName:"p"},"mappend"),"\ncombines two elements of this type to create a new element of the same\ntype."),(0,r.kt)("p",null,"The prime example of a ",(0,r.kt)("em",{parentName:"p"},"Monoid")," is ",(0,r.kt)("em",{parentName:"p"},"List"),", when ",(0,r.kt)("em",{parentName:"p"},"mempty")," is the empty\nlist ",(0,r.kt)("em",{parentName:"p"},"[","]"),", and ",(0,r.kt)("em",{parentName:"p"},"mappend")," is concatenation ",(0,r.kt)("em",{parentName:"p"},"++"),"."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"Prelude> mempty :: [Int]\n[]\nPrelude> mappend [1, 2, 3 :: Int] [4, 5, 6]\n[1,2,3,4,5,6]\n")),(0,r.kt)("p",null,"The are many, many other examples of the ",(0,r.kt)("em",{parentName:"p"},"Monoid")," type, and we will see\nother instances in this course."),(0,r.kt)("p",null,"But for now, let\\'s stick with lists and write our last example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"myContract4 :: Contract [Int] BlockchainActions Text ()\nmyContract4 = do\n    void $ Contract.waitNSlots 10\n    tell [1]\n    void $ Contract.waitNSlots 10\n    tell [2]\n    void $ Contract.waitNSlots 10\n")),(0,r.kt)("p",null,"Rather than using ",(0,r.kt)("em",{parentName:"p"},"Unit")," as our ",(0,r.kt)("em",{parentName:"p"},"w")," type, we are using ",(0,r.kt)("em",{parentName:"p"},"[","Int","]"),". This\nallows us to use the ",(0,r.kt)("em",{parentName:"p"},"tell")," function as shown."),(0,r.kt)("p",null,"This now gives us access to those messages during the trace, using the\n",(0,r.kt)("em",{parentName:"p"},"observableState")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.haskell}"},"myTrace4 :: EmulatorTrace ()\nmyTrace4 = do\n    h <- activateContractWallet (Wallet 1) myContract4\n\n    void $ Emulator.waitNSlots 5\n    xs <- observableState h\n    Extras.logInfo $ show xs\n\n    void $ Emulator.waitNSlots 10\n    ys <- observableState h\n    Extras.logInfo $ show ys\n\n    void $ Emulator.waitNSlots 10\n    zs <- observableState h\n    Extras.logInfo $ show zs\n\ntest4 :: IO ()\ntest4 = runEmulatorTraceIO myTrace4\n")),(0,r.kt)("p",null,"If we run this in the REPL, we can see the ",(0,r.kt)("em",{parentName:"p"},"USER LOG")," messages created\nusing the ",(0,r.kt)("em",{parentName:"p"},"tell")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-{.}"},'Prelude Plutus.Trace.Emulator Plutus.Contract.Trace Wallet.Emulator Week04.Trace Wallet.Emulator.Stream Week04.Contract> test4\nSlot 00000: TxnValidate af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8\nSlot 00000: SlotAdd Slot 1\nSlot 00001: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Contract instance started\nSlot 00001: SlotAdd Slot 2\n...\nSlot 00005: SlotAdd Slot 6\nSlot 00006: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Sending contract state to Thread 0\nSlot 00006: SlotAdd Slot 7\nSlot 00007: *** USER LOG: []\nSlot 00007: SlotAdd Slot 8\n...\nSlot 00015: SlotAdd Slot 16\nSlot 00016: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Sending contract state to Thread 0\nSlot 00016: SlotAdd Slot 17\nSlot 00017: *** USER LOG: [1]\nSlot 00017: SlotAdd Slot 18\n...\nSlot 00025: SlotAdd Slot 26\nSlot 00026: 00000000-0000-4000-8000-000000000000 {Contract instance for wallet 1}:\n  Sending contract state to Thread 0\nSlot 00026: SlotAdd Slot 27\nSlot 00027: *** USER LOG: [1,2]\nFinal balances\nWallet 1: \n    {, ""}: 100000000\nWallet 2: \n    {, ""}: 100000000\n...\nWallet 10: \n    {, ""}: 100000000\n')),(0,r.kt)("p",null,"Using this mechanism, it is possible to pass information from the\ncontract running in the wallet to the outside world. Using endpoints we\ncan pass information into a contract. And using the ",(0,r.kt)("em",{parentName:"p"},"tell")," mechanism we\ncan get information out of the wallet."))}h.isMDXComponent=!0}}]);